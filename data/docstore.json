{"0":{"pageContent":"--\n\ntitle: useState\n\n--\n\n<Intro>\n\n`useState` is a React Hook that lets you add a [state variable](/learn/state-a-components-memory) to your component.\n\n```js\n\nconst [state, setState] = useState(initialState)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useState(initialState)` {/*usestate*/}\n\nCall `useState` at the top level of your component to declare a [state variable.](/learn/state-a-components-memory)\n\n```js\n\nimport { useState } from 'react';\n\nfunction MyComponent() {\n\nconst [age, setAge] = useState(28);\n\nconst [name, setName] = useState('Taylor');\n\nconst [todos, setTodos] = useState(() => createTodos());\n\n// ...\n\n```\n\nThe convention is to name state variables like `[something, setSomething]` using [array destructuring.](https://javascript.info/destructuring-assignment)\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"1":{"pageContent":"[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`initialState`: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.\n\nIf you pass a function as `initialState`, it will be treated as an _initializer function_. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. [See an example below.](#avoiding-recreating-the-initial-state)\n\n#### Returns {/*returns*/}\n\n`useState` returns an array with exactly two values:\n\n1. The current state. During the first render, it will match the `initialState` you have passed.\n\n2. The [`set` function](#setstate) that lets you update the state to a different value and trigger a re-render.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"2":{"pageContent":"2. The [`set` function](#setstate) that lets you update the state to a different value and trigger a re-render.\n\n#### Caveats {/*caveats*/}\n\n`useState` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n\nIn Strict Mode, React will **call your initializer function twice** in order to [help you find accidental impurities.](#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.\n\n--\n\n### `set` functions, like `setSomething(nextState)` {/*setstate*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"3":{"pageContent":"--\n\n### `set` functions, like `setSomething(nextState)` {/*setstate*/}\n\nThe `set` function returned by `useState` lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:\n\n```js\n\nconst [name, setName] = useState('Edward');\n\nfunction handleClick() {\n\nsetName('Taylor');\n\nsetAge(a => a + 1);\n\n// ...\n\n```\n\n#### Parameters {/*setstate-parameters*/}\n\n`nextState`: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"4":{"pageContent":"setAge(a => a + 1);\n\n// ...\n\n```\n\n#### Parameters {/*setstate-parameters*/}\n\n`nextState`: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.\n\nIf you pass a function as `nextState`, it will be treated as an _updater function_. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. [See an example below.](#updating-state-based-on-the-previous-state)\n\n#### Returns {/*setstate-returns*/}\n\n`set` functions do not have a return value.\n\n#### Caveats {/*setstate-caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"5":{"pageContent":"#### Returns {/*setstate-returns*/}\n\n`set` functions do not have a return value.\n\n#### Caveats {/*setstate-caveats*/}\n\nThe `set` function **only updates the state variable for the *next* render**. If you read the state variable after calling the `set` function, [you will still get the old value](#ive-updated-the-state-but-logging-gives-me-the-old-value) that was on the screen before your call.\n\nIf the new value you provide is identical to the current `state`, as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison, React will **skip re-rendering the component and its children.** This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn't affect your code.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"6":{"pageContent":"React [batches state updates.](/learn/queueing-a-series-of-state-updates) It updates the screen **after all the event handlers have run** and have called their `set` functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use [`flushSync`.](/reference/react-dom/flushSync)\n\nCalling the `set` function *during rendering* is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to **store information from the previous renders**. [See an example below.](#storing-information-from-previous-renders)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"7":{"pageContent":"In Strict Mode, React will **call your updater function twice** in order to [help you find accidental impurities.](#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.\n\n--\n\n## Usage {/*usage*/}\n\n### Adding state to a component {/*adding-state-to-a-component*/}\n\nCall `useState` at the top level of your component to declare one or more [state variables.](/learn/state-a-components-memory)\n\n```js [[1, 4, \"age\"], [2, 4, \"setAge\"], [3, 4, \"42\"], [1, 5, \"name\"], [2, 5, \"setName\"], [3, 5, \"'Taylor'\"]]\n\nimport { useState } from 'react';\n\nfunction MyComponent() {\n\nconst [age, setAge] = useState(42);\n\nconst [name, setName] = useState('Taylor');\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"8":{"pageContent":"import { useState } from 'react';\n\nfunction MyComponent() {\n\nconst [age, setAge] = useState(42);\n\nconst [name, setName] = useState('Taylor');\n\n// ...\n\n```\n\nThe convention is to name state variables like `[something, setSomething]` using [array destructuring.](https://javascript.info/destructuring-assignment)\n\n`useState` returns an array with exactly two items:\n\n1. The <CodeStep step={1}>current state</CodeStep> of this state variable, initially set to the <CodeStep step={3}>initial state</CodeStep> you provided.\n\n2. The <CodeStep step={2}>`set` function</CodeStep> that lets you change it to any other value in response to interaction.\n\nTo update whatâ€™s on the screen, call the `set` function with some next state:\n\n```js [[2, 2, \"setName\"]]\n\nfunction handleClick() {\n\nsetName('Robin');\n\n}\n\n```\n\nReact will store the next state, render your component again with the new values, and update the UI.\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"9":{"pageContent":"```js [[2, 2, \"setName\"]]\n\nfunction handleClick() {\n\nsetName('Robin');\n\n}\n\n```\n\nReact will store the next state, render your component again with the new values, and update the UI.\n\n<Pitfall>\n\nCalling the `set` function [**does not** change the current state in the already executing code](#ive-updated-the-state-but-logging-gives-me-the-old-value):\n\n```js {3}\n\nfunction handleClick() {\n\nsetName('Robin');\n\nconsole.log(name); // Still \"Taylor\"!\n\n}\n\n```\n\nIt only affects what `useState` will return starting from the *next* render.\n\n</Pitfall>\n\n<Recipes titleText=\"Basic useState examples\" titleId=\"examples-basic\">\n\n#### Counter (number) {/*counter-number*/}\n\nIn this example, the `count` state variable holds a number. Clicking the button increments it.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n\nconst [count, setCount] = useState(0);\n\nfunction handleClick() {\n\nsetCount(count + 1);\n\n}\n\nreturn (\n\n<button onClick={handleClick}>\n\nYou pressed me {count} times\n\n</button>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"10":{"pageContent":"const [count, setCount] = useState(0);\n\nfunction handleClick() {\n\nsetCount(count + 1);\n\n}\n\nreturn (\n\n<button onClick={handleClick}>\n\nYou pressed me {count} times\n\n</button>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Text field (string) {/*text-field-string*/}\n\nIn this example, the `text` state variable holds a string. When you type, `handleChange` reads the latest input value from the browser input DOM element, and calls `setText` to update the state. This allows you to display the current `text` below.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function MyInput() {\n\nconst [text, setText] = useState('hello');\n\nfunction handleChange(e) {\n\nsetText(e.target.value);\n\n}\n\nreturn (\n\n<>\n\n<input value={text} onChange={handleChange} />\n\n<p>You typed: {text}</p>\n\n<button onClick={() => setText('hello')}>\n\nReset\n\n</button>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Checkbox (boolean) {/*checkbox-boolean*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"11":{"pageContent":"<p>You typed: {text}</p>\n\n<button onClick={() => setText('hello')}>\n\nReset\n\n</button>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Checkbox (boolean) {/*checkbox-boolean*/}\n\nIn this example, the `liked` state variable holds a boolean. When you click the input, `setLiked` updates the `liked` state variable with whether the browser checkbox input is checked. The `liked` variable is used to render the text below the checkbox.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function MyCheckbox() {\n\nconst [liked, setLiked] = useState(true);\n\nfunction handleChange(e) {\n\nsetLiked(e.target.checked);\n\n}\n\nreturn (\n\n<>\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={liked}\n\nonChange={handleChange}\n\n/>\n\nI liked this\n\n</label>\n\n<p>You {liked ? 'liked' : 'did not like'} this.</p>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Form (two variables) {/*form-two-variables*/}\n\nYou can declare more than one state variable in the same component. Each state variable is completely independent.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"12":{"pageContent":"You can declare more than one state variable in the same component. Each state variable is completely independent.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function Form() {\n\nconst [name, setName] = useState('Taylor');\n\nconst [age, setAge] = useState(42);\n\nreturn (\n\n<>\n\n<input\n\nvalue={name}\n\nonChange={e => setName(e.target.value)}\n\n/>\n\n<button onClick={() => setAge(age + 1)}>\n\nIncrement age\n\n</button>\n\n<p>Hello, {name}. You are {age}.</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Updating state based on the previous state {/*updating-state-based-on-the-previous-state*/}\n\nSuppose the `age` is `42`. This handler calls `setAge(age + 1)` three times:\n\n```js\n\nfunction handleClick() {\n\nsetAge(age + 1); // setAge(42 + 1)\n\nsetAge(age + 1); // setAge(42 + 1)\n\nsetAge(age + 1); // setAge(42 + 1)\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"13":{"pageContent":"```js\n\nfunction handleClick() {\n\nsetAge(age + 1); // setAge(42 + 1)\n\nsetAge(age + 1); // setAge(42 + 1)\n\nsetAge(age + 1); // setAge(42 + 1)\n\n}\n\n```\n\nHowever, after one click, `age` will only be `43` rather than `45`! This is because calling the `set` function [does not update](/learn/state-as-a-snapshot) the `age` state variable in the already running code. So each `setAge(age + 1)` call becomes `setAge(43)`.\n\nTo solve this problem, **you may pass an *updater function*** to `setAge` instead of the next state:\n\n```js [[1, 2, \"a\", 0], [2, 2, \"a + 1\"], [1, 3, \"a\", 0], [2, 3, \"a + 1\"], [1, 4, \"a\", 0], [2, 4, \"a + 1\"]]\n\nfunction handleClick() {\n\nsetAge(a => a + 1); // setAge(42 => 43)\n\nsetAge(a => a + 1); // setAge(43 => 44)\n\nsetAge(a => a + 1); // setAge(44 => 45)\n\n}\n\n```\n\nHere, `a => a + 1` is your updater function. It takes the <CodeStep step={1}>pending state</CodeStep> and calculates the <CodeStep step={2}>next state</CodeStep> from it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"14":{"pageContent":"}\n\n```\n\nHere, `a => a + 1` is your updater function. It takes the <CodeStep step={1}>pending state</CodeStep> and calculates the <CodeStep step={2}>next state</CodeStep> from it.\n\nReact puts your updater functions in a [queue.](/learn/queueing-a-series-of-state-updates) Then, during the next render, it will call them in the same order:\n\n1. `a => a + 1` will receive `42` as the pending state and return `43` as the next state.\n\n1. `a => a + 1` will receive `43` as the pending state and return `44` as the next state.\n\n1. `a => a + 1` will receive `44` as the pending state and return `45` as the next state.\n\nThere are no other queued updates, so React will store `45` as the current state in the end.\n\nBy convention, it's common to name the pending state argument for the first letter of the state variable name, like `a` for `age`. However, you may also call it like `prevAge` or something else that you find clearer.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"15":{"pageContent":"React may [call your updaters twice](#my-initializer-or-updater-function-runs-twice) in development to verify that they are [pure.](/learn/keeping-components-pure)\n\n<DeepDive>\n\n#### Is using an updater always preferred? {/*is-using-an-updater-always-preferred*/}\n\nYou might hear a recommendation to always write code like `setAge(a => a + 1)` if the state you're setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.\n\nIn most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the `age` state variable would be updated before the next click. This means there is no risk of a click handler seeing a \"stale\" `age` at the beginning of the event handler.\n\nHowever, if you do multiple updates within the same event, updaters can be helpful. They're also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"16":{"pageContent":"If you prefer consistency over slightly more verbose syntax, it's reasonable to always write an updater if the state you're setting is calculated from the previous state. If it's calculated from the previous state of some *other* state variable, you might want to combine them into one object and [use a reducer.](/learn/extracting-state-logic-into-a-reducer)\n\n</DeepDive>\n\n<Recipes titleText=\"The difference between passing an updater and passing the next state directly\" titleId=\"examples-updater\">\n\n#### Passing the updater function {/*passing-the-updater-function*/}\n\nThis example passes the updater function, so the \"+3\" button works.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n\nconst [age, setAge] = useState(42);\n\nfunction increment() {\n\nsetAge(a => a + 1);\n\n}\n\nreturn (\n\n<>\n\n<h1>Your age: {age}</h1>\n\n<button onClick={() => {\n\nincrement();\n\nincrement();\n\nincrement();\n\n}}>+3</button>\n\n<button onClick={() => {\n\nincrement();\n\n}}>+1</button>\n\n</>\n\n);\n\n}\n\n```\n\n```css","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"17":{"pageContent":"setAge(a => a + 1);\n\n}\n\nreturn (\n\n<>\n\n<h1>Your age: {age}</h1>\n\n<button onClick={() => {\n\nincrement();\n\nincrement();\n\nincrement();\n\n}}>+3</button>\n\n<button onClick={() => {\n\nincrement();\n\n}}>+1</button>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin: 10px; font-size: 20px; }\n\nh1 { display: block; margin: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Passing the next state directly {/*passing-the-next-state-directly*/}\n\nThis example **does not** pass the updater function, so the \"+3\" button **doesn't work as intended**.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n\nconst [age, setAge] = useState(42);\n\nfunction increment() {\n\nsetAge(age + 1);\n\n}\n\nreturn (\n\n<>\n\n<h1>Your age: {age}</h1>\n\n<button onClick={() => {\n\nincrement();\n\nincrement();\n\nincrement();\n\n}}>+3</button>\n\n<button onClick={() => {\n\nincrement();\n\n}}>+1</button>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin: 10px; font-size: 20px; }\n\nh1 { display: block; margin: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"18":{"pageContent":"<button onClick={() => {\n\nincrement();\n\n}}>+1</button>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin: 10px; font-size: 20px; }\n\nh1 { display: block; margin: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Updating objects and arrays in state {/*updating-objects-and-arrays-in-state*/}\n\nYou can put objects and arrays into state. In React, state is considered read-only, so **you should *replace* it rather than *mutate* your existing objects**. For example, if you have a `form` object in state, don't update it like this:\n\n```js\n\n// ðŸš© Don't mutate an object in state like this:\n\nform.firstName = 'Taylor';\n\n```\n\nInstead, replace the whole object by creating a new one:\n\n```js\n\n// âœ… Replace state with a new object\n\nsetForm({\n\n...form,\n\nfirstName: 'Taylor'\n\n});\n\n```\n\nRead [updating objects in state](/learn/updating-objects-in-state) and [updating arrays in state](/learn/updating-arrays-in-state) to learn more.\n\n<Recipes titleText=\"Examples of objects and arrays in state\" titleId=\"examples-objects\">","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"19":{"pageContent":"<Recipes titleText=\"Examples of objects and arrays in state\" titleId=\"examples-objects\">\n\n#### Form (object) {/*form-object*/}\n\nIn this example, the `form` state variable holds an object. Each input has a change handler that calls `setForm` with the next state of the entire form. The `{ ...form }` spread syntax ensures that the state object is replaced rather than mutated.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function Form() {\n\nconst [form, setForm] = useState({\n\nfirstName: 'Barbara',\n\nlastName: 'Hepworth',\n\nemail: 'bhepworth@sculpture.com',\n\n});\n\nreturn (\n\n<>\n\n<label>\n\nFirst name:\n\n<input\n\nvalue={form.firstName}\n\nonChange={e => {\n\nsetForm({\n\n...form,\n\nfirstName: e.target.value\n\n});\n\n}}\n\n/>\n\n</label>\n\n<label>\n\nLast name:\n\n<input\n\nvalue={form.lastName}\n\nonChange={e => {\n\nsetForm({\n\n...form,\n\nlastName: e.target.value\n\n});\n\n}}\n\n/>\n\n</label>\n\n<label>\n\nEmail:\n\n<input\n\nvalue={form.email}\n\nonChange={e => {\n\nsetForm({\n\n...form,\n\nemail: e.target.value\n\n});\n\n}}\n\n/>\n\n</label>\n\n<p>\n\n{form.firstName}{' '}\n\n{form.lastName}{' '}\n\n({form.email})\n\n</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"20":{"pageContent":"});\n\n}}\n\n/>\n\n</label>\n\n<label>\n\nEmail:\n\n<input\n\nvalue={form.email}\n\nonChange={e => {\n\nsetForm({\n\n...form,\n\nemail: e.target.value\n\n});\n\n}}\n\n/>\n\n</label>\n\n<p>\n\n{form.firstName}{' '}\n\n{form.lastName}{' '}\n\n({form.email})\n\n</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nlabel { display: block; }\n\ninput { margin-left: 5px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Form (nested object) {/*form-nested-object*/}\n\nIn this example, the state is more nested. When you update nested state, you need to create a copy of the object you're updating, as well as any objects \"containing\" it on the way upwards. Read [updating a nested object](/learn/updating-objects-in-state#updating-a-nested-object) to learn more.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function Form() {\n\nconst [person, setPerson] = useState({\n\nname: 'Niki de Saint Phalle',\n\nartwork: {\n\ntitle: 'Blue Nana',\n\ncity: 'Hamburg',\n\nimage: 'https://i.imgur.com/Sd1AgUOm.jpg',\n\n}\n\n});\n\nfunction handleNameChange(e) {\n\nsetPerson({\n\n...person,\n\nname: e.target.value\n\n});\n\n}\n\nfunction handleTitleChange(e) {\n\nsetPerson({\n\n...person,\n\nartwork: {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"21":{"pageContent":"city: 'Hamburg',\n\nimage: 'https://i.imgur.com/Sd1AgUOm.jpg',\n\n}\n\n});\n\nfunction handleNameChange(e) {\n\nsetPerson({\n\n...person,\n\nname: e.target.value\n\n});\n\n}\n\nfunction handleTitleChange(e) {\n\nsetPerson({\n\n...person,\n\nartwork: {\n\n...person.artwork,\n\ntitle: e.target.value\n\n}\n\n});\n\n}\n\nfunction handleCityChange(e) {\n\nsetPerson({\n\n...person,\n\nartwork: {\n\n...person.artwork,\n\ncity: e.target.value\n\n}\n\n});\n\n}\n\nfunction handleImageChange(e) {\n\nsetPerson({\n\n...person,\n\nartwork: {\n\n...person.artwork,\n\nimage: e.target.value\n\n}\n\n});\n\n}\n\nreturn (\n\n<>\n\n<label>\n\nName:\n\n<input\n\nvalue={person.name}\n\nonChange={handleNameChange}\n\n/>\n\n</label>\n\n<label>\n\nTitle:\n\n<input\n\nvalue={person.artwork.title}\n\nonChange={handleTitleChange}\n\n/>\n\n</label>\n\n<label>\n\nCity:\n\n<input\n\nvalue={person.artwork.city}\n\nonChange={handleCityChange}\n\n/>\n\n</label>\n\n<label>\n\nImage:\n\n<input\n\nvalue={person.artwork.image}\n\nonChange={handleImageChange}\n\n/>\n\n</label>\n\n<p>\n\n<i>{person.artwork.title}</i>\n\n{' by '}\n\n{person.name}\n\n<br />\n\n(located in {person.artwork.city})\n\n</p>\n\n<img\n\nsrc={person.artwork.image}\n\nalt={person.artwork.title}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nlabel { display: block; }","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"22":{"pageContent":"<p>\n\n<i>{person.artwork.title}</i>\n\n{' by '}\n\n{person.name}\n\n<br />\n\n(located in {person.artwork.city})\n\n</p>\n\n<img\n\nsrc={person.artwork.image}\n\nalt={person.artwork.title}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nlabel { display: block; }\n\ninput { margin-left: 5px; margin-bottom: 5px; }\n\nimg { width: 200px; height: 200px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### List (array) {/*list-array*/}\n\nIn this example, the `todos` state variable holds an array. Each button handler calls `setTodos` with the next version of that array. The `[...todos]` spread syntax, `todos.map()` and `todos.filter()` ensure the state array is replaced rather than mutated.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport AddTodo from './AddTodo.js';\n\nimport TaskList from './TaskList.js';\n\nlet nextId = 3;\n\nconst initialTodos = [\n\n{ id: 0, title: 'Buy milk', done: true },\n\n{ id: 1, title: 'Eat tacos', done: false },\n\n{ id: 2, title: 'Brew tea', done: false },\n\n];\n\nexport default function TaskApp() {\n\nconst [todos, setTodos] = useState(initialTodos);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"23":{"pageContent":"{ id: 1, title: 'Eat tacos', done: false },\n\n{ id: 2, title: 'Brew tea', done: false },\n\n];\n\nexport default function TaskApp() {\n\nconst [todos, setTodos] = useState(initialTodos);\n\nfunction handleAddTodo(title) {\n\nsetTodos([\n\n...todos,\n\n{\n\nid: nextId++,\n\ntitle: title,\n\ndone: false\n\n}\n\n]);\n\n}\n\nfunction handleChangeTodo(nextTodo) {\n\nsetTodos(todos.map(t => {\n\nif (t.id === nextTodo.id) {\n\nreturn nextTodo;\n\n} else {\n\nreturn t;\n\n}\n\n}));\n\n}\n\nfunction handleDeleteTodo(todoId) {\n\nsetTodos(\n\ntodos.filter(t => t.id !== todoId)\n\n);\n\n}\n\nreturn (\n\n<>\n\n<AddTodo\n\nonAddTodo={handleAddTodo}\n\n/>\n\n<TaskList\n\ntodos={todos}\n\nonChangeTodo={handleChangeTodo}\n\nonDeleteTodo={handleDeleteTodo}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js AddTodo.js\n\nimport { useState } from 'react';\n\nexport default function AddTodo({ onAddTodo }) {\n\nconst [title, setTitle] = useState('');\n\nreturn (\n\n<>\n\n<input\n\nplaceholder=\"Add todo\"\n\nvalue={title}\n\nonChange={e => setTitle(e.target.value)}\n\n/>\n\n<button onClick={() => {\n\nsetTitle('');\n\nonAddTodo(title);\n\n}}>Add</button>\n\n</>\n\n)\n\n}\n\n```\n\n```js TaskList.js\n\nimport { useState } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"24":{"pageContent":"value={title}\n\nonChange={e => setTitle(e.target.value)}\n\n/>\n\n<button onClick={() => {\n\nsetTitle('');\n\nonAddTodo(title);\n\n}}>Add</button>\n\n</>\n\n)\n\n}\n\n```\n\n```js TaskList.js\n\nimport { useState } from 'react';\n\nexport default function TaskList({\n\ntodos,\n\nonChangeTodo,\n\nonDeleteTodo\n\n}) {\n\nreturn (\n\n<ul>\n\n{todos.map(todo => (\n\n<li key={todo.id}>\n\n<Task\n\ntodo={todo}\n\nonChange={onChangeTodo}\n\nonDelete={onDeleteTodo}\n\n/>\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\nfunction Task({ todo, onChange, onDelete }) {\n\nconst [isEditing, setIsEditing] = useState(false);\n\nlet todoContent;\n\nif (isEditing) {\n\ntodoContent = (\n\n<>\n\n<input\n\nvalue={todo.title}\n\nonChange={e => {\n\nonChange({\n\n...todo,\n\ntitle: e.target.value\n\n});\n\n}} />\n\n<button onClick={() => setIsEditing(false)}>\n\nSave\n\n</button>\n\n</>\n\n);\n\n} else {\n\ntodoContent = (\n\n<>\n\n{todo.title}\n\n<button onClick={() => setIsEditing(true)}>\n\nEdit\n\n</button>\n\n</>\n\n);\n\n}\n\nreturn (\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={todo.done}\n\nonChange={e => {\n\nonChange({\n\n...todo,\n\ndone: e.target.checked\n\n});\n\n}}\n\n/>\n\n{todoContent}\n\n<button onClick={() => onDelete(todo.id)}>\n\nDelete\n\n</button>\n\n</label>\n\n);\n\n}\n\n```\n\n```css","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"25":{"pageContent":"<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={todo.done}\n\nonChange={e => {\n\nonChange({\n\n...todo,\n\ndone: e.target.checked\n\n});\n\n}}\n\n/>\n\n{todoContent}\n\n<button onClick={() => onDelete(todo.id)}>\n\nDelete\n\n</button>\n\n</label>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin: 5px; }\n\nli { list-style-type: none; }\n\nul, li { margin: 0; padding: 0; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Writing concise update logic with Immer {/*writing-concise-update-logic-with-immer*/}\n\nIf updating arrays and objects without mutation feels tedious, you can use a library like [Immer](https://github.com/immerjs/use-immer) to reduce repetitive code. Immer lets you write concise code as if you were mutating objects, but under the hood it performs immutable updates:\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport { useImmer } from 'use-immer';\n\nlet nextId = 3;\n\nconst initialList = [\n\n{ id: 0, title: 'Big Bellies', seen: false },\n\n{ id: 1, title: 'Lunar Landscape', seen: false },\n\n{ id: 2, title: 'Terracotta Army', seen: true },\n\n];\n\nexport default function BucketList() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"26":{"pageContent":"{ id: 0, title: 'Big Bellies', seen: false },\n\n{ id: 1, title: 'Lunar Landscape', seen: false },\n\n{ id: 2, title: 'Terracotta Army', seen: true },\n\n];\n\nexport default function BucketList() {\n\nconst [list, updateList] = useImmer(initialList);\n\nfunction handleToggle(artworkId, nextSeen) {\n\nupdateList(draft => {\n\nconst artwork = draft.find(a =>\n\na.id === artworkId\n\n);\n\nartwork.seen = nextSeen;\n\n});\n\n}\n\nreturn (\n\n<>\n\n<h1>Art Bucket List</h1>\n\n<h2>My list of art to see:</h2>\n\n<ItemList\n\nartworks={list}\n\nonToggle={handleToggle} />\n\n</>\n\n);\n\n}\n\nfunction ItemList({ artworks, onToggle }) {\n\nreturn (\n\n<ul>\n\n{artworks.map(artwork => (\n\n<li key={artwork.id}>\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={artwork.seen}\n\nonChange={e => {\n\nonToggle(\n\nartwork.id,\n\ne.target.checked\n\n);\n\n}}\n\n/>\n\n{artwork.title}\n\n</label>\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n```\n\n```json package.json\n\n{\n\n\"dependencies\": {\n\n\"immer\": \"1.7.3\",\n\n\"react\": \"latest\",\n\n\"react-dom\": \"latest\",\n\n\"react-scripts\": \"latest\",\n\n\"use-immer\": \"0.5.1\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"27":{"pageContent":"{\n\n\"dependencies\": {\n\n\"immer\": \"1.7.3\",\n\n\"react\": \"latest\",\n\n\"react-dom\": \"latest\",\n\n\"react-scripts\": \"latest\",\n\n\"use-immer\": \"0.5.1\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Avoiding recreating the initial state {/*avoiding-recreating-the-initial-state*/}\n\nReact saves the initial state once and ignores it on the next renders.\n\n```js\n\nfunction TodoList() {\n\nconst [todos, setTodos] = useState(createInitialTodos());\n\n// ...\n\n```\n\nAlthough the result of `createInitialTodos()` is only used for the initial render, you're still calling this function on every render. This can be wasteful if it's creating large arrays or performing expensive calculations.\n\nTo solve this, you may **pass it as an _initializer_ function** to `useState` instead:\n\n```js\n\nfunction TodoList() {\n\nconst [todos, setTodos] = useState(createInitialTodos);\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"28":{"pageContent":"To solve this, you may **pass it as an _initializer_ function** to `useState` instead:\n\n```js\n\nfunction TodoList() {\n\nconst [todos, setTodos] = useState(createInitialTodos);\n\n// ...\n\n```\n\nNotice that youâ€™re passing `createInitialTodos`, which is the *function itself*, and not `createInitialTodos()`, which is the result of calling it. If you pass a function to `useState`, React will only call it during initialization.\n\nReact may [call your initializers twice](#my-initializer-or-updater-function-runs-twice) in development to verify that they are [pure.](/learn/keeping-components-pure)\n\n<Recipes titleText=\"The difference between passing an initializer and passing the initial state directly\" titleId=\"examples-initializer\">\n\n#### Passing the initializer function {/*passing-the-initializer-function*/}\n\nThis example passes the initializer function, so the `createInitialTodos` function only runs during initialization. It does not run when component re-renders, such as when you type into the input.\n\n<Sandpack>\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"29":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nfunction createInitialTodos() {\n\nconst initialTodos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ninitialTodos.push({\n\nid: i,\n\ntext: 'Item ' + (i + 1)\n\n});\n\n}\n\nreturn initialTodos;\n\n}\n\nexport default function TodoList() {\n\nconst [todos, setTodos] = useState(createInitialTodos);\n\nconst [text, setText] = useState('');\n\nreturn (\n\n<>\n\n<input\n\nvalue={text}\n\nonChange={e => setText(e.target.value)}\n\n/>\n\n<button onClick={() => {\n\nsetText('');\n\nsetTodos([{\n\nid: todos.length,\n\ntext: text\n\n}, ...todos]);\n\n}}>Add</button>\n\n<ul>\n\n{todos.map(item => (\n\n<li key={item.id}>\n\n{item.text}\n\n</li>\n\n))}\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Passing the initial state directly {/*passing-the-initial-state-directly*/}\n\nThis example **does not** pass the initializer function, so the `createInitialTodos` function runs on every render, such as when you type into the input. There is no observable difference in behavior, but this code is less efficient.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nfunction createInitialTodos() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"30":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nfunction createInitialTodos() {\n\nconst initialTodos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ninitialTodos.push({\n\nid: i,\n\ntext: 'Item ' + (i + 1)\n\n});\n\n}\n\nreturn initialTodos;\n\n}\n\nexport default function TodoList() {\n\nconst [todos, setTodos] = useState(createInitialTodos());\n\nconst [text, setText] = useState('');\n\nreturn (\n\n<>\n\n<input\n\nvalue={text}\n\nonChange={e => setText(e.target.value)}\n\n/>\n\n<button onClick={() => {\n\nsetText('');\n\nsetTodos([{\n\nid: todos.length,\n\ntext: text\n\n}, ...todos]);\n\n}}>Add</button>\n\n<ul>\n\n{todos.map(item => (\n\n<li key={item.id}>\n\n{item.text}\n\n</li>\n\n))}\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Resetting state with a key {/*resetting-state-with-a-key*/}\n\nTypically, you might encounter the `key` attribute when [rendering lists.](/learn/rendering-lists) However, it also serves another purpose.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"31":{"pageContent":"Typically, you might encounter the `key` attribute when [rendering lists.](/learn/rendering-lists) However, it also serves another purpose.\n\nYou can **reset a component's state by passing a different `key` to a component.** In this example, the Reset button changes the `version` state variable, which we pass as a `key` to the `Form`. When the `key` changes, React re-creates the `Form` component (and all of its children) from scratch, so its state gets reset.\n\nRead [preserving and resetting state](/learn/preserving-and-resetting-state) to learn more.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nexport default function App() {\n\nconst [version, setVersion] = useState(0);\n\nfunction handleReset() {\n\nsetVersion(version + 1);\n\n}\n\nreturn (\n\n<>\n\n<button onClick={handleReset}>Reset</button>\n\n<Form key={version} />\n\n</>\n\n);\n\n}\n\nfunction Form() {\n\nconst [name, setName] = useState('Taylor');\n\nreturn (\n\n<>\n\n<input\n\nvalue={name}\n\nonChange={e => setName(e.target.value)}\n\n/>\n\n<p>Hello, {name}.</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"32":{"pageContent":"<Form key={version} />\n\n</>\n\n);\n\n}\n\nfunction Form() {\n\nconst [name, setName] = useState('Taylor');\n\nreturn (\n\n<>\n\n<input\n\nvalue={name}\n\nonChange={e => setName(e.target.value)}\n\n/>\n\n<p>Hello, {name}.</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-bottom: 20px; }\n\n```\n\n</Sandpack>\n\n--\n\n### Storing information from previous renders {/*storing-information-from-previous-renders*/}\n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering -- for example, you might want to change a state variable when a prop changes.\n\nIn most cases, you don't need this:\n\n**If the value you need can be computed entirely from the current props or other state, [remove that redundant state altogether.](/learn/choosing-the-state-structure#avoid-redundant-state)** If you're worried about recomputing too often, the [`useMemo` Hook](/reference/react/useMemo) can help.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"33":{"pageContent":"If you want to reset the entire component tree's state, [pass a different `key` to your component.](#resetting-state-with-a-key)\n\nIf you can, update all the relevant state in the event handlers.\n\nIn the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a `set` function while your component is rendering.\n\nHere's an example. This `CountLabel` component displays the `count` prop passed to it:\n\n```js CountLabel.js\n\nexport default function CountLabel({ count }) {\n\nreturn <h1>{count}</h1>\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"34":{"pageContent":"Here's an example. This `CountLabel` component displays the `count` prop passed to it:\n\n```js CountLabel.js\n\nexport default function CountLabel({ count }) {\n\nreturn <h1>{count}</h1>\n\n}\n\n```\n\nSay you want to show whether the counter has *increased or decreased* since the last change. The `count` prop doesn't tell you this -- you need to keep track of its previous value. Add the `prevCount` state variable to track it. Add another state variable called `trend` to hold whether the count has increased or decreased. Compare `prevCount` with `count`, and if they're not equal, update both `prevCount` and `trend`. Now you can show both the current count prop and *how it has changed since the last render*.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport CountLabel from './CountLabel.js';\n\nexport default function App() {\n\nconst [count, setCount] = useState(0);\n\nreturn (\n\n<>\n\n<button onClick={() => setCount(count + 1)}>\n\nIncrement\n\n</button>\n\n<button onClick={() => setCount(count - 1)}>\n\nDecrement\n\n</button>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"35":{"pageContent":"const [count, setCount] = useState(0);\n\nreturn (\n\n<>\n\n<button onClick={() => setCount(count + 1)}>\n\nIncrement\n\n</button>\n\n<button onClick={() => setCount(count - 1)}>\n\nDecrement\n\n</button>\n\n<CountLabel count={count} />\n\n</>\n\n);\n\n}\n\n```\n\n```js CountLabel.js active\n\nimport { useState } from 'react';\n\nexport default function CountLabel({ count }) {\n\nconst [prevCount, setPrevCount] = useState(count);\n\nconst [trend, setTrend] = useState(null);\n\nif (prevCount !== count) {\n\nsetPrevCount(count);\n\nsetTrend(count > prevCount ? 'increasing' : 'decreasing');\n\n}\n\nreturn (\n\n<>\n\n<h1>{count}</h1>\n\n{trend && <p>The count is {trend}</p>}\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin-bottom: 10px; }\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"36":{"pageContent":"setTrend(count > prevCount ? 'increasing' : 'decreasing');\n\n}\n\nreturn (\n\n<>\n\n<h1>{count}</h1>\n\n{trend && <p>The count is {trend}</p>}\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin-bottom: 10px; }\n\n```\n\n</Sandpack>\n\nNote that if you call a `set` function while rendering, it must be inside a condition like `prevCount !== count`, and there must be a call like `setPrevCount(count)` inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the *currently rendering* component like this. Calling the `set` function of *another* component during rendering is an error. Finally, your `set` call should still [update state without mutation](#updating-objects-and-arrays-in-state) -- this special case doesn't mean you can break other rules of [pure functions.](/learn/keeping-components-pure)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"37":{"pageContent":"This pattern can be hard to understand and is usually best avoided. However, it's better than updating state in an effect. When you call the `set` function during render, React will re-render that component immediately after your component exits with a `return` statement, and before rendering the children. This way, children don't need to render twice. The rest of your component function will still execute (and the result will be thrown away), but if your condition is below all the calls to Hooks, you may add an early `return;` inside it to restart rendering earlier.\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### I've updated the state, but logging gives me the old value {/*ive-updated-the-state-but-logging-gives-me-the-old-value*/}\n\nCalling the `set` function **does not change state in the running code**:\n\n```js {4,5,8}\n\nfunction handleClick() {\n\nconsole.log(count);  // 0\n\nsetCount(count + 1); // Request a re-render with 1\n\nconsole.log(count);  // Still 0!\n\nsetTimeout(() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"38":{"pageContent":"```js {4,5,8}\n\nfunction handleClick() {\n\nconsole.log(count);  // 0\n\nsetCount(count + 1); // Request a re-render with 1\n\nconsole.log(count);  // Still 0!\n\nsetTimeout(() => {\n\nconsole.log(count); // Also 0!\n\n}, 5000);\n\n}\n\n```\n\nThis is because [states behaves like a snapshot.](/learn/state-as-a-snapshot) Updating state requests another render with the new state value, but does not affect the `count` JavaScript variable in your already-running event handler.\n\nIf you need to use the next state, you can save it in a variable before passing it to the `set` function:\n\n```js\n\nconst nextCount = count + 1;\n\nsetCount(nextCount);\n\nconsole.log(count);     // 0\n\nconsole.log(nextCount); // 1\n\n```\n\n--\n\n### I've updated the state, but the screen doesn't update {/*ive-updated-the-state-but-the-screen-doesnt-update*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"39":{"pageContent":"setCount(nextCount);\n\nconsole.log(count);     // 0\n\nconsole.log(nextCount); // 1\n\n```\n\n--\n\n### I've updated the state, but the screen doesn't update {/*ive-updated-the-state-but-the-screen-doesnt-update*/}\n\nReact will **ignore your update if the next state is equal to the previous state,** as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. This usually happens when you change an object or an array in state directly:\n\n```js\n\nobj.x = 10;  // ðŸš© Wrong: mutating existing object\n\nsetObj(obj); // ðŸš© Doesn't do anything\n\n```\n\nYou mutated an existing `obj` object and passed it back to `setObj`, so React ignored the update. To fix this, you need to ensure that you're always [_replacing_ objects and arrays in state instead of _mutating_ them](#updating-objects-and-arrays-in-state):\n\n```js\n\n// âœ… Correct: creating a new object\n\nsetObj({\n\n...obj,\n\nx: 10\n\n});\n\n```\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"40":{"pageContent":"```js\n\n// âœ… Correct: creating a new object\n\nsetObj({\n\n...obj,\n\nx: 10\n\n});\n\n```\n\n--\n\n### I'm getting an error: \"Too many re-renders\" {/*im-getting-an-error-too-many-re-renders*/}\n\nYou might get an error that says: `Too many re-renders. React limits the number of renders to prevent an infinite loop.` Typically, this means that you're unconditionally setting state *during render*, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n\n```js {1-2}\n\n// ðŸš© Wrong: calls the handler during render\n\nreturn <button onClick={handleClick()}>Click me</button>\n\n// âœ… Correct: passes down the event handler\n\nreturn <button onClick={handleClick}>Click me</button>\n\n// âœ… Correct: passes down an inline function\n\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"41":{"pageContent":"return <button onClick={handleClick}>Click me</button>\n\n// âœ… Correct: passes down an inline function\n\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n\n```\n\nIf you can't find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific `set` function call responsible for the error.\n\n--\n\n### My initializer or updater function runs twice {/*my-initializer-or-updater-function-runs-twice*/}\n\nIn [Strict Mode](/reference/react/StrictMode), React will call some of your functions twice instead of once:\n\n```js {2,5-6,11-12}\n\nfunction TodoList() {\n\n// This component function will run twice for every render.\n\nconst [todos, setTodos] = useState(() => {\n\n// This initializer function will run twice during initialization.\n\nreturn createTodos();\n\n});\n\nfunction handleClick() {\n\nsetTodos(prevTodos => {\n\n// This updater function will run twice for every click.\n\nreturn [...prevTodos, createTodo()];\n\n});\n\n}\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"42":{"pageContent":"return createTodos();\n\n});\n\nfunction handleClick() {\n\nsetTodos(prevTodos => {\n\n// This updater function will run twice for every click.\n\nreturn [...prevTodos, createTodo()];\n\n});\n\n}\n\n// ...\n\n```\n\nThis is expected and shouldn't break your code.\n\nThis **development-only** behavior helps you [keep components pure.](/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn't affect your logic. However, if they are accidentally impure, this helps you notice the mistakes and fix it.\n\nFor example, this impure updater function mutates an array in state:\n\n```js {2,3}\n\nsetTodos(prevTodos => {\n\n// ðŸš© Mistake: mutating state\n\nprevTodos.push(createTodo());\n\n});\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"43":{"pageContent":"For example, this impure updater function mutates an array in state:\n\n```js {2,3}\n\nsetTodos(prevTodos => {\n\n// ðŸš© Mistake: mutating state\n\nprevTodos.push(createTodo());\n\n});\n\n```\n\nBecause React calls your updater function twice, you'll see the todo was added twice, so you'll know that there is a mistake. In this example, you can fix the mistake by [replacing the array instead of mutating it](#updating-objects-and-arrays-in-state):\n\n```js {2,3}\n\nsetTodos(prevTodos => {\n\n// âœ… Correct: replacing with new state\n\nreturn [...prevTodos, createTodo()];\n\n});\n\n```\n\nNow that this updater function is pure, calling it an extra time doesn't make a difference in behavior. This is why React calling it twice helps you find mistakes. **Only component, initializer, and updater functions need to be pure.** Event handlers don't need to be pure, so React will never call your event handlers twice.\n\nRead [keeping components pure](/learn/keeping-components-pure) to learn more.\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"44":{"pageContent":"Read [keeping components pure](/learn/keeping-components-pure) to learn more.\n\n--\n\n### I'm trying to set state to a function, but it gets called instead {/*im-trying-to-set-state-to-a-function-but-it-gets-called-instead*/}\n\nYou can't put a function into state like this:\n\n```js\n\nconst [fn, setFn] = useState(someFunction);\n\nfunction handleClick() {\n\nsetFn(someOtherFunction);\n\n}\n\n```\n\nBecause you're passing a function, React assumes that `someFunction` is an [initializer function](#avoiding-recreating-the-initial-state), and that `someOtherFunction` is an [updater function](#updating-state-based-on-the-previous-state), so it tries to call them and store the result. To actually *store* a function, you have to put `() =>` before them in both cases. Then React will store the functions you pass.\n\n```js {1,4}\n\nconst [fn, setFn] = useState(() => someFunction);\n\nfunction handleClick() {\n\nsetFn(() => someOtherFunction);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useState.md"}},"45":{"pageContent":"--\n\ntitle: useImperativeHandle\n\n--\n\n<Intro>\n\n`useImperativeHandle` is a React Hook that lets you customize the handle exposed as a [ref.](/learn/manipulating-the-dom-with-refs)\n\n```js\n\nuseImperativeHandle(ref, createHandle, dependencies?)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useImperativeHandle(ref, createHandle, dependencies?)` {/*useimperativehandle*/}\n\nCall `useImperativeHandle` at the top level of your component to customize the ref handle it exposes:\n\n```js\n\nimport { forwardRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\n// ... your methods ...\n\n};\n\n}, []);\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`ref`: The `ref` you received as the second argument from the [`forwardRef` render function.](/reference/react/forwardRef#render-function)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"46":{"pageContent":"#### Parameters {/*parameters*/}\n\n`ref`: The `ref` you received as the second argument from the [`forwardRef` render function.](/reference/react/forwardRef#render-function)\n\n`createHandle`: A function that takes no arguments and returns the ref handle you want to expose. The ref handle you return can have any type. Usually, you will return an object with the methods you want to expose.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"47":{"pageContent":"**optional** `dependencies`: The list of all reactive values referenced inside of the `createHandle` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm. If a re-render resulted in a change to some dependency, or if you did not specify the dependencies at all, your `createHandle` function will re-execute, and the newly created handle will be assigned to the ref.\n\n#### Returns {/*returns*/}\n\n`useImperativeHandle` returns `undefined`.\n\n--\n\n## Usage {/*usage*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"48":{"pageContent":"#### Returns {/*returns*/}\n\n`useImperativeHandle` returns `undefined`.\n\n--\n\n## Usage {/*usage*/}\n\n### Exposing a custom ref handle to the parent component {/*exposing-a-custom-ref-handle-to-the-parent-component*/}\n\nBy default, components don't expose their DOM nodes to parent components. For example, if you want the parent component of `MyInput` to [have access](/learn/manipulating-the-dom-with-refs) to the `<input>` DOM node, you have to opt in with [`forwardRef`:](/reference/react/forwardRef)\n\n```js {4}\n\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nreturn <input {...props} ref={ref} />;\n\n});\n\n```\n\nWith the code above, [a ref to `MyInput` will receive the `<input>` DOM node.](/reference/react/forwardRef#exposing-a-dom-node-to-the-parent-component) However, you can expose a custom value instead. To customize the exposed handle, call `useImperativeHandle` at the top level of your component:\n\n```js {4-8}\n\nimport { forwardRef, useImperativeHandle } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"49":{"pageContent":"```js {4-8}\n\nimport { forwardRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\n// ... your methods ...\n\n};\n\n}, []);\n\nreturn <input {...props} />;\n\n});\n\n```\n\nNote that in the code above, the `ref` is no longer forwarded to the `<input>`.\n\nFor example, suppose you don't want to expose the entire `<input>` DOM node, but you want to expose two of its methods: `focus` and `scrollIntoView`. To do this, keep the real browser DOM in a separate ref. Then use `useImperativeHandle` to expose a handle with only the methods that you want the parent component to call:\n\n```js {7-14}\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst inputRef = useRef(null);\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\nfocus() {\n\ninputRef.current.focus();\n\n},\n\nscrollIntoView() {\n\ninputRef.current.scrollIntoView();\n\n},\n\n};\n\n}, []);\n\nreturn <input {...props} ref={inputRef} />;\n\n});\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"50":{"pageContent":"useImperativeHandle(ref, () => {\n\nreturn {\n\nfocus() {\n\ninputRef.current.focus();\n\n},\n\nscrollIntoView() {\n\ninputRef.current.scrollIntoView();\n\n},\n\n};\n\n}, []);\n\nreturn <input {...props} ref={inputRef} />;\n\n});\n\n```\n\nNow, if the parent component gets a ref to `MyInput`, it will be able to call the `focus` and `scrollIntoView` methods on it. However, it will not have full access to the underlying `<input>` DOM node.\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nref.current.focus();\n\n// This won't work because the DOM node isn't exposed:\n\n// ref.current.style.opacity = 0.5;\n\n}\n\nreturn (\n\n<form>\n\n<MyInput label=\"Enter your name:\" ref={ref} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\n```js MyInput.js\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst inputRef = useRef(null);\n\nuseImperativeHandle(ref, () => {\n\nreturn {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"51":{"pageContent":"import { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst inputRef = useRef(null);\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\nfocus() {\n\ninputRef.current.focus();\n\n},\n\nscrollIntoView() {\n\ninputRef.current.scrollIntoView();\n\n},\n\n};\n\n}, []);\n\nreturn <input {...props} ref={inputRef} />;\n\n});\n\nexport default MyInput;\n\n```\n\n```css\n\ninput {\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Exposing your own imperative methods {/*exposing-your-own-imperative-methods*/}\n\nThe methods you expose via an imperative handle don't have to match the DOM methods exactly. For example, the `Post` component in the example below exposes a `scrollAndFocusAddComment` method via an imperative handle. This lets the parent `Page` scroll the list of comments *and* focus the input field when you click the button:\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport Post from './Post.js';\n\nexport default function Page() {\n\nconst postRef = useRef(null);\n\nfunction handleClick() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"52":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport Post from './Post.js';\n\nexport default function Page() {\n\nconst postRef = useRef(null);\n\nfunction handleClick() {\n\npostRef.current.scrollAndFocusAddComment();\n\n}\n\nreturn (\n\n<>\n\n<button onClick={handleClick}>\n\nWrite a comment\n\n</button>\n\n<Post ref={postRef} />\n\n</>\n\n);\n\n}\n\n```\n\n```js Post.js\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nimport CommentList from './CommentList.js';\n\nimport AddComment from './AddComment.js';\n\nconst Post = forwardRef((props, ref) => {\n\nconst commentsRef = useRef(null);\n\nconst addCommentRef = useRef(null);\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\nscrollAndFocusAddComment() {\n\ncommentsRef.current.scrollToBottom();\n\naddCommentRef.current.focus();\n\n}\n\n};\n\n}, []);\n\nreturn (\n\n<>\n\n<article>\n\n<p>Welcome to my blog!</p>\n\n</article>\n\n<CommentList ref={commentsRef} />\n\n<AddComment ref={addCommentRef} />\n\n</>\n\n);\n\n});\n\nexport default Post;\n\n```\n\n```js CommentList.js\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"53":{"pageContent":"</article>\n\n<CommentList ref={commentsRef} />\n\n<AddComment ref={addCommentRef} />\n\n</>\n\n);\n\n});\n\nexport default Post;\n\n```\n\n```js CommentList.js\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst CommentList = forwardRef(function CommentList(props, ref) {\n\nconst divRef = useRef(null);\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\nscrollToBottom() {\n\nconst node = divRef.current;\n\nnode.scrollTop = node.scrollHeight;\n\n}\n\n};\n\n}, []);\n\nlet comments = [];\n\nfor (let i = 0; i < 50; i++) {\n\ncomments.push(<p key={i}>Comment #{i}</p>);\n\n}\n\nreturn (\n\n<div className=\"CommentList\" ref={divRef}>\n\n{comments}\n\n</div>\n\n);\n\n});\n\nexport default CommentList;\n\n```\n\n```js AddComment.js\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst AddComment = forwardRef(function AddComment(props, ref) {\n\nreturn <input placeholder=\"Add comment...\" ref={ref} />;\n\n});\n\nexport default AddComment;\n\n```\n\n```css\n\n.CommentList {\n\nheight: 100px;\n\noverflow: scroll;\n\nborder: 1px solid black;\n\nmargin-top: 20px;\n\nmargin-bottom: 20px;\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"54":{"pageContent":"});\n\nexport default AddComment;\n\n```\n\n```css\n\n.CommentList {\n\nheight: 100px;\n\noverflow: scroll;\n\nborder: 1px solid black;\n\nmargin-top: 20px;\n\nmargin-bottom: 20px;\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\n*Do not overuse refs.** You should only use refs for *imperative* behaviors that you can't express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.\n\n*If you can express something as a prop, you should not use a ref.** For example, instead of exposing an imperative handle like `{ open, close }` from a `Modal` component, it is better to take `isOpen` as a prop like `<Modal isOpen={isOpen} />`. [Effects](/learn/synchronizing-with-effects) can help you expose imperative behaviors via props.\n\n</Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useImperativeHandle.md"}},"55":{"pageContent":"--\n\ntitle: \"Built-in React APIs\"\n\n--\n\n<Intro>\n\nIn addition to [Hooks](/reference/react) and [Components](/reference/react/components), the `react` package exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.\n\n</Intro>\n\n--\n\n[`createContext`](/reference/react/createContext) lets you define and provide context to the child components. Used with [`useContext`.](/reference/react/useContext)\n\n[`forwardRef`](/reference/react/forwardRef) lets your component expose a DOM node as a ref to the parent. Used with [`useRef`.](/reference/react/useRef)\n\n[`lazy`](/reference/react/lazy) lets you defer loading a component's code until it's rendered for the first time.\n\n[`memo`](/reference/react/memo) lets your component skip re-renders with same props. Used with [`useMemo`](/reference/react/useMemo) and [`useCallback`.](/reference/react/useCallback)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/apis.md"}},"56":{"pageContent":"[`memo`](/reference/react/memo) lets your component skip re-renders with same props. Used with [`useMemo`](/reference/react/useMemo) and [`useCallback`.](/reference/react/useCallback)\n\n[`startTransition`](/reference/react/startTransition) lets you mark a state update as non-urgent. Similar to [`useTransition`.](/reference/react/useTransition)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/apis.md"}},"57":{"pageContent":"--\n\ntitle: useCallback\n\n--\n\n<Intro>\n\n`useCallback` is a React Hook that lets you cache a function definition between re-renders.\n\n```js\n\nconst cachedFn = useCallback(fn, dependencies)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useCallback(fn, dependencies)` {/*usecallback*/}\n\nCall `useCallback` at the top level of your component to cache a function definition between re-renders:\n\n```js {4,9}\n\nimport { useCallback } from 'react';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n\nconst handleSubmit = useCallback((orderDetails) => {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}, [productId, referrer]);\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"58":{"pageContent":"post('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}, [productId, referrer]);\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`fn`: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On subsequent renders, React will give you the same function again if the `dependencies` have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"59":{"pageContent":"`dependencies`: The list of all reactive values referenced inside of the `fn` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm.\n\n#### Returns {/*returns*/}\n\nOn the initial render, `useCallback` returns the `fn` function you have passed.\n\nDuring subsequent renders, it will either return an already stored `fn`  function from the last render (if the dependencies haven't changed), or return the `fn` function you have passed during this render.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"60":{"pageContent":"#### Caveats {/*caveats*/}\n\n`useCallback` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"61":{"pageContent":"React **will not throw away the cached function unless there is a specific reason to do that.** For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache--for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on `useCallback` as a performance optimization. Otherwise, a [state variable](/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead) or a [ref](/reference/react/useRef#avoiding-recreating-the-ref-contents) may be more appropriate.\n\n--\n\n## Usage {/*usage*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"62":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Skipping re-rendering of components {/*skipping-re-rendering-of-components*/}\n\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let's first look at the syntax for how to do this, and then see in which cases it's useful.\n\nTo cache a function between re-renders of your component, wrap its definition into the `useCallback` Hook:\n\n```js [[3, 4, \"handleSubmit\"], [2, 9, \"[productId, referrer]\"]]\n\nimport { useCallback } from 'react';\n\nfunction ProductPage({ productId, referrer, theme }) {\n\nconst handleSubmit = useCallback((orderDetails) => {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}, [productId, referrer]);\n\n// ...\n\n```\n\nYou need to pass two things to `useCallback`:\n\n1. A function definition that you want to cache between re-renders.\n\n2. A <CodeStep step={2}>list of dependencies</CodeStep> including every value within your component that's used inside your function.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"63":{"pageContent":"1. A function definition that you want to cache between re-renders.\n\n2. A <CodeStep step={2}>list of dependencies</CodeStep> including every value within your component that's used inside your function.\n\nOn the initial render, the <CodeStep step={3}>returned function</CodeStep> you'll get from `useCallback` will be the function you passed.\n\nOn the following renders, React will compare the <CodeStep step={2}>dependencies</CodeStep> with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), `useCallback` will return the same function as before. Otherwise, `useCallback` will return the function you passed on *this* render.\n\nIn other words, `useCallback` caches a function between re-renders until its dependencies change.\n\n*Let's walk through an example to see when this is useful.**","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"64":{"pageContent":"In other words, `useCallback` caches a function between re-renders until its dependencies change.\n\n*Let's walk through an example to see when this is useful.**\n\nSay you're passing a `handleSubmit` function down from the `ProductPage` to the `ShippingForm` component:\n\n```js {5}\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n// ...\n\nreturn (\n\n<div className={theme}>\n\n<ShippingForm onSubmit={handleSubmit} />\n\n</div>\n\n);\n\n```\n\nYou've noticed that toggling the `theme` prop freezes the app for a moment, but if you remove `<ShippingForm />` from your JSX, it feels fast. This tells you that it's worth trying to optimize the `ShippingForm` component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"65":{"pageContent":"*By default, when a component re-renders, React re-renders all of its children recursively.** This is why, when `ProductPage` re-renders with a different `theme`, the `ShippingForm` component *also* re-renders. This is fine for components that don't require much calculation to re-render. But if you've verified that a re-render is slow, you can tell `ShippingForm` to skip re-rendering when its props are the same as on last render by wrapping it in [`memo`:](/reference/react/memo)\n\n```js {3,5}\n\nimport { memo } from 'react';\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n\n// ...\n\n});\n\n```\n\n*With this change, `ShippingForm` will skip re-rendering if all of its props are the *same* as on the last render.** This is where caching a function becomes important! Imagine that you defined `handleSubmit` without `useCallback`:\n\n```js {2,3,8,12-13}\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n// Every time the theme changes, this will be a different function...","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"66":{"pageContent":"```js {2,3,8,12-13}\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n// Every time the theme changes, this will be a different function...\n\nfunction handleSubmit(orderDetails) {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}\n\nreturn (\n\n<div className={theme}>\n\n{/* ... so ShippingForm's props will never be the same, and it will re-render every time */}\n\n<ShippingForm onSubmit={handleSubmit} />\n\n</div>\n\n);\n\n}\n\n```\n\n*In JavaScript, a `function () {}` or `() => {}` always creates a _different_ function,** similar to how the `{}` object literal always creates a new object. Normally, this wouldn't be a problem, but it means that `ShippingForm` props will never be the same, and your [`memo`](/reference/react/memo) optimization won't work. This is where `useCallback` comes in handy:\n\n```js {2,3,8,12-13}\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n// Tell React to cache your function between re-renders...\n\nconst handleSubmit = useCallback((orderDetails) => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"67":{"pageContent":"```js {2,3,8,12-13}\n\nfunction ProductPage({ productId, referrer, theme }) {\n\n// Tell React to cache your function between re-renders...\n\nconst handleSubmit = useCallback((orderDetails) => {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}, [productId, referrer]); // ...so as long as these dependencies don't change...\n\nreturn (\n\n<div className={theme}>\n\n{/* ...ShippingForm will receive the same props and can skip re-rendering */}\n\n<ShippingForm onSubmit={handleSubmit} />\n\n</div>\n\n);\n\n}\n\n```\n\n*By wrapping `handleSubmit` in `useCallback`, you ensure that it's the *same* function between the re-renders** (until dependencies change). You don't *have to* wrap a function in `useCallback` unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in [`memo`,](/reference/react/memo) and this lets it skip re-rendering. There are a few other reasons you might need `useCallback` which are described further on this page.\n\n<Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"68":{"pageContent":"<Note>\n\n*You should only rely on `useCallback` as a performance optimization.** If your code doesn't work without it, find the underlying problem and fix it first. Then you may add `useCallback` to improve performance.\n\n</Note>\n\n<DeepDive>\n\n#### How is useCallback related to useMemo? {/*how-is-usecallback-related-to-usememo*/}\n\nYou will often see [`useMemo`](/reference/react/useMemo) alongside `useCallback`. They are both useful when you're trying to optimize a child component. They let you [memoize](https://en.wikipedia.org/wiki/Memoization) (or, in other words, cache) something you're passing down:\n\n```js {6-8,10-15,19}\n\nimport { useMemo, useCallback } from 'react';\n\nfunction ProductPage({ productId, referrer }) {\n\nconst product = useData('/product/' + productId);\n\nconst requirements = useMemo(() => { // Calls your function and caches its result\n\nreturn computeRequirements(product);\n\n}, [product]);\n\nconst handleSubmit = useCallback((orderDetails) => { // Caches your function itself","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"69":{"pageContent":"return computeRequirements(product);\n\n}, [product]);\n\nconst handleSubmit = useCallback((orderDetails) => { // Caches your function itself\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}, [productId, referrer]);\n\nreturn (\n\n<div className={theme}>\n\n<ShippingForm requirements={requirements} onSubmit={handleSubmit} />\n\n</div>\n\n);\n\n}\n\n```\n\nThe difference is in *what* they're letting you cache:\n\n**[`useMemo`](/reference/react/useMemo) caches the *result* of calling your function.** In this example, it caches the result of calling `computeRequirements(product)` so that it doesn't change unless `product` has changed. This lets you pass the `requirements` object down without unnecessarily re-rendering `ShippingForm`. When necessary, React will call the function you've passed during rendering to calculate the result.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"70":{"pageContent":"**`useCallback` caches *the function itself.*** Unlike `useMemo`, it does not call the function you provide. Instead, it caches the function you provided so that `handleSubmit` *itself* doesn't change unless `productId` or `referrer` has changed. This lets you pass the `handleSubmit` function down without unnecessarily re-rendering `ShippingForm`. Your code won't be called until the user submits the form.\n\nIf you're already familiar with [`useMemo`,](/reference/react/useMemo) you might find it helpful to think of `useCallback` as this:\n\n```js\n\n// Simplified implementation (inside React)\n\nfunction useCallback(fn, dependencies) {\n\nreturn useMemo(() => fn, dependencies);\n\n}\n\n```\n\n[Read more about the difference between `useMemo` and `useCallback`.](/reference/react/useMemo#memoizing-a-function)\n\n</DeepDive>\n\n<DeepDive>\n\n#### Should you add useCallback everywhere? {/*should-you-add-usecallback-everywhere*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"71":{"pageContent":"</DeepDive>\n\n<DeepDive>\n\n#### Should you add useCallback everywhere? {/*should-you-add-usecallback-everywhere*/}\n\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\n\nCaching a function with `useCallback`  is only valuable in a few cases:\n\nYou pass it as a prop to a component wrapped in [`memo`.](/reference/react/memo) You want to skip re-rendering if the value hasn't changed. Memoization lets your component re-render only when dependencies aren't the same.\n\nThe function you're passing is later used as a dependency of some Hook. For example, another function wrapped in `useCallback` depends on it, or you depend on this function from [`useEffect.`](/reference/react/useEffect)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"72":{"pageContent":"There is no benefit to wrapping a function in `useCallback` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that's \"always new\" is enough to break memoization for an entire component.\n\nNote that `useCallback` does not prevent *creating* the function. You're always creating a function (and that's fine!), but React ignores it and gives you back a cached function if dependencies haven't changed.\n\n*In practice, you can make a lot of memoization unnecessary by following a few principles:**\n\n1. When a component visually wraps other components, let it [accept JSX as children.](/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don't need to re-render.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"73":{"pageContent":"1. Prefer local state and don't [lift state up](/learn/sharing-state-between-components) any further than necessary. For example, don't keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n\n1. Keep your [rendering logic pure.](/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it's a bug in your component! Fix the bug instead of adding memoization.\n\n1. Avoid [unnecessary Effects that update state.](/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n\n1. Try to [remove unnecessary dependencies from your Effects.](/learn/removing-effect-dependencies) For example, instead of memoization, it's often simpler to move some object or a function inside an Effect or outside the component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"74":{"pageContent":"If a specific interaction still feels laggy, [use the React Developer Tools profiler](/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it's good to follow them in any case. In the long term, we're researching [doing granular memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.\n\n</DeepDive>\n\n<Recipes titleText=\"The difference between useCallback and declaring a function directly\" titleId=\"examples-rerendering\">\n\n#### Skipping re-rendering with `useCallback` and `memo` {/*skipping-re-rendering-with-usecallback-and-memo*/}\n\nIn this example, the `ShippingForm` component is **artificially slowed down** so that you can see what happens when a React component you're rendering is genuinely slow. Try incrementing the counter and toggling the theme.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"75":{"pageContent":"Incrementing the counter feels slow because it forces the slowed down `ShippingForm` to re-render. That's expected because the counter has changed, and so you need to reflect the user's new choice on the screen.\n\nNext, try toggling the theme. **Thanks to `useCallback` together with [`memo`](/reference/react/memo), itâ€™s fast despite the artificial slowdown!** `ShippingForm` skipped re-rendering because the `handleSubmit` function has not changed. The `handleSubmit` function has not changed because both `productId` and `referral` (your `useCallback` dependencies) haven't changed since last render.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport ProductPage from './ProductPage.js';\n\nexport default function App() {\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<ProductPage\n\nreferrerId=\"wizard_of_oz\"\n\nproductId={123}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"76":{"pageContent":"type=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<ProductPage\n\nreferrerId=\"wizard_of_oz\"\n\nproductId={123}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js ProductPage.js active\n\nimport { useCallback } from 'react';\n\nimport ShippingForm from './ShippingForm.js';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n\nconst handleSubmit = useCallback((orderDetails) => {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}, [productId, referrer]);\n\nreturn (\n\n<div className={theme}>\n\n<ShippingForm onSubmit={handleSubmit} />\n\n</div>\n\n);\n\n}\n\nfunction post(url, data) {\n\n// Imagine this sends a request...\n\nconsole.log('POST /' + url);\n\nconsole.log(data);\n\n}\n\n```\n\n```js ShippingForm.js\n\nimport { memo, useState } from 'react';\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n\nconst [count, setCount] = useState(1);\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering <ShippingForm />');\n\nlet startTime = performance.now();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"77":{"pageContent":"const ShippingForm = memo(function ShippingForm({ onSubmit }) {\n\nconst [count, setCount] = useState(1);\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering <ShippingForm />');\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 500) {\n\n// Do nothing for 500 ms to emulate extremely slow code\n\n}\n\nfunction handleSubmit(e) {\n\ne.preventDefault();\n\nconst formData = new FormData(e.target);\n\nconst orderDetails = {\n\n...Object.fromEntries(formData),\n\ncount\n\n};\n\nonSubmit(orderDetails);\n\n}\n\nreturn (\n\n<form onSubmit={handleSubmit}>\n\n<p><b>Note: <code>ShippingForm</code> is artificially slowed down!</b></p>\n\n<label>\n\nNumber of items:\n\n<button type=\"button\" onClick={() => setCount(count - 1)}>â€“</button>\n\n{count}\n\n<button type=\"button\" onClick={() => setCount(count + 1)}>+</button>\n\n</label>\n\n<label>\n\nStreet:\n\n<input name=\"street\" />\n\n</label>\n\n<label>\n\nCity:\n\n<input name=\"city\" />\n\n</label>\n\n<label>\n\nPostal code:\n\n<input name=\"zipCode\" />\n\n</label>\n\n<button type=\"submit\">Submit</button>\n\n</form>\n\n);\n\n});\n\nexport default ShippingForm;\n\n```\n\n```css\n\nlabel {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"78":{"pageContent":"</label>\n\n<label>\n\nCity:\n\n<input name=\"city\" />\n\n</label>\n\n<label>\n\nPostal code:\n\n<input name=\"zipCode\" />\n\n</label>\n\n<button type=\"submit\">Submit</button>\n\n</form>\n\n);\n\n});\n\nexport default ShippingForm;\n\n```\n\n```css\n\nlabel {\n\ndisplay: block; margin-top: 10px;\n\n}\n\ninput {\n\nmargin-left: 5px;\n\n}\n\nbutton[type=\"button\"] {\n\nmargin: 5px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Always re-rendering a component {/*always-re-rendering-a-component*/}\n\nIn this example, the `ShoppingForm` implementation is also **artificially slowed down** so that you can see what happens when some React component you're rendering is genuinely slow. Try incrementing the counter and toggling the theme.\n\nUnlike in the previous example, toggling the theme is also slow now! This is because **there is no `useCallback` call in this version,** so `handleSubmit` is always a new function, and the slowed down `ShoppingForm` component can't skip re-rendering.\n\n<Sandpack>\n\n```js App.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"79":{"pageContent":"<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport ProductPage from './ProductPage.js';\n\nexport default function App() {\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<ProductPage\n\nreferrerId=\"wizard_of_oz\"\n\nproductId={123}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js ProductPage.js active\n\nimport ShippingForm from './ShippingForm.js';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n\nfunction handleSubmit(orderDetails) {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}\n\nreturn (\n\n<div className={theme}>\n\n<ShippingForm onSubmit={handleSubmit} />\n\n</div>\n\n);\n\n}\n\nfunction post(url, data) {\n\n// Imagine this sends a request...\n\nconsole.log('POST /' + url);\n\nconsole.log(data);\n\n}\n\n```\n\n```js ShippingForm.js\n\nimport { memo, useState } from 'react';\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n\nconst [count, setCount] = useState(1);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"80":{"pageContent":"console.log(data);\n\n}\n\n```\n\n```js ShippingForm.js\n\nimport { memo, useState } from 'react';\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n\nconst [count, setCount] = useState(1);\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering <ShippingForm />');\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 500) {\n\n// Do nothing for 500 ms to emulate extremely slow code\n\n}\n\nfunction handleSubmit(e) {\n\ne.preventDefault();\n\nconst formData = new FormData(e.target);\n\nconst orderDetails = {\n\n...Object.fromEntries(formData),\n\ncount\n\n};\n\nonSubmit(orderDetails);\n\n}\n\nreturn (\n\n<form onSubmit={handleSubmit}>\n\n<p><b>Note: <code>ShippingForm</code> is artificially slowed down!</b></p>\n\n<label>\n\nNumber of items:\n\n<button type=\"button\" onClick={() => setCount(count - 1)}>â€“</button>\n\n{count}\n\n<button type=\"button\" onClick={() => setCount(count + 1)}>+</button>\n\n</label>\n\n<label>\n\nStreet:\n\n<input name=\"street\" />\n\n</label>\n\n<label>\n\nCity:\n\n<input name=\"city\" />\n\n</label>\n\n<label>\n\nPostal code:\n\n<input name=\"zipCode\" />\n\n</label>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"81":{"pageContent":"</label>\n\n<label>\n\nStreet:\n\n<input name=\"street\" />\n\n</label>\n\n<label>\n\nCity:\n\n<input name=\"city\" />\n\n</label>\n\n<label>\n\nPostal code:\n\n<input name=\"zipCode\" />\n\n</label>\n\n<button type=\"submit\">Submit</button>\n\n</form>\n\n);\n\n});\n\nexport default ShippingForm;\n\n```\n\n```css\n\nlabel {\n\ndisplay: block; margin-top: 10px;\n\n}\n\ninput {\n\nmargin-left: 5px;\n\n}\n\nbutton[type=\"button\"] {\n\nmargin: 5px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\nHowever, here is the same code **with the artificial slowdown removed.** Does the lack of `useCallback` feel noticeable or not?\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport ProductPage from './ProductPage.js';\n\nexport default function App() {\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<ProductPage\n\nreferrerId=\"wizard_of_oz\"\n\nproductId={123}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js ProductPage.js active","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"82":{"pageContent":"onChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<ProductPage\n\nreferrerId=\"wizard_of_oz\"\n\nproductId={123}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js ProductPage.js active\n\nimport ShippingForm from './ShippingForm.js';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n\nfunction handleSubmit(orderDetails) {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}\n\nreturn (\n\n<div className={theme}>\n\n<ShippingForm onSubmit={handleSubmit} />\n\n</div>\n\n);\n\n}\n\nfunction post(url, data) {\n\n// Imagine this sends a request...\n\nconsole.log('POST /' + url);\n\nconsole.log(data);\n\n}\n\n```\n\n```js ShippingForm.js\n\nimport { memo, useState } from 'react';\n\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n\nconst [count, setCount] = useState(1);\n\nconsole.log('Rendering <ShippingForm />');\n\nfunction handleSubmit(e) {\n\ne.preventDefault();\n\nconst formData = new FormData(e.target);\n\nconst orderDetails = {\n\n...Object.fromEntries(formData),\n\ncount\n\n};\n\nonSubmit(orderDetails);\n\n}\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"83":{"pageContent":"function handleSubmit(e) {\n\ne.preventDefault();\n\nconst formData = new FormData(e.target);\n\nconst orderDetails = {\n\n...Object.fromEntries(formData),\n\ncount\n\n};\n\nonSubmit(orderDetails);\n\n}\n\nreturn (\n\n<form onSubmit={handleSubmit}>\n\n<label>\n\nNumber of items:\n\n<button type=\"button\" onClick={() => setCount(count - 1)}>â€“</button>\n\n{count}\n\n<button type=\"button\" onClick={() => setCount(count + 1)}>+</button>\n\n</label>\n\n<label>\n\nStreet:\n\n<input name=\"street\" />\n\n</label>\n\n<label>\n\nCity:\n\n<input name=\"city\" />\n\n</label>\n\n<label>\n\nPostal code:\n\n<input name=\"zipCode\" />\n\n</label>\n\n<button type=\"submit\">Submit</button>\n\n</form>\n\n);\n\n});\n\nexport default ShippingForm;\n\n```\n\n```css\n\nlabel {\n\ndisplay: block; margin-top: 10px;\n\n}\n\ninput {\n\nmargin-left: 5px;\n\n}\n\nbutton[type=\"button\"] {\n\nmargin: 5px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\nQuite often, code without memoization works fine. If your interactions are fast enough, you don't need memoization.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"84":{"pageContent":"color: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\nQuite often, code without memoization works fine. If your interactions are fast enough, you don't need memoization.\n\nKeep in mind that you need to run React in production mode, disable [React Developer Tools](/learn/react-developer-tools), and use devices similar to the ones your app's users have in order to get a realistic sense of what's actually slowing down your app.\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Updating state from a memoized callback {/*updating-state-from-a-memoized-callback*/}\n\nSometimes, you might need to update state based on previous state from a memoized callback.\n\nThis `handleAddTodo` function specifies `todos` as a dependency because it computes the next todos from it:\n\n```js {6,7}\n\nfunction TodoList() {\n\nconst [todos, setTodos] = useState([]);\n\nconst handleAddTodo = useCallback((text) => {\n\nconst newTodo = { id: nextId++, text };\n\nsetTodos([...todos, newTodo]);\n\n}, [todos]);\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"85":{"pageContent":"function TodoList() {\n\nconst [todos, setTodos] = useState([]);\n\nconst handleAddTodo = useCallback((text) => {\n\nconst newTodo = { id: nextId++, text };\n\nsetTodos([...todos, newTodo]);\n\n}, [todos]);\n\n// ...\n\n```\n\nYou'll usually want your memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an [updater function](/reference/react/useState#updating-state-based-on-the-previous-state) instead:\n\n```js {6,7}\n\nfunction TodoList() {\n\nconst [todos, setTodos] = useState([]);\n\nconst handleAddTodo = useCallback((text) => {\n\nconst newTodo = { id: nextId++, text };\n\nsetTodos(todos => [...todos, newTodo]);\n\n}, []); // âœ… No need for the todos dependency\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"86":{"pageContent":"const handleAddTodo = useCallback((text) => {\n\nconst newTodo = { id: nextId++, text };\n\nsetTodos(todos => [...todos, newTodo]);\n\n}, []); // âœ… No need for the todos dependency\n\n// ...\n\n```\n\nHere, instead of making `todos` a dependency of your function and reading it there, you pass an instruction about *how* to update the state (`todos => [...todos, newTodo]`) to React. [Read more about updater functions.](/reference/react/useState#updating-state-based-on-the-previous-state)\n\n--\n\n### Preventing an Effect from firing too often {/*preventing-an-effect-from-firing-too-often*/}\n\nSometimes, you might want to call a function from inside an [Effect:](/learn/synchronizing-with-effects)\n\n```js {4-9,12}\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nfunction createOptions() {\n\nreturn {\n\nserverUrl: 'https://localhost:1234',\n\nroomId: roomId\n\n};\n\n}\n\nuseEffect(() => {\n\nconst options = createOptions();\n\nconst connection = createConnection();\n\nconnection.connect();\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"87":{"pageContent":"return {\n\nserverUrl: 'https://localhost:1234',\n\nroomId: roomId\n\n};\n\n}\n\nuseEffect(() => {\n\nconst options = createOptions();\n\nconst connection = createConnection();\n\nconnection.connect();\n\n// ...\n\n```\n\nThis creates a problem. [Every reactive value must be declared as a dependency of your Effect.](/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency) However, if you declare `createOptions` as a dependency, it will cause your Effect to constantly reconnect to the chat room:\n\n```js {6}\n\nuseEffect(() => {\n\nconst options = createOptions();\n\nconst connection = createConnection();\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [createOptions]); // ðŸ”´ Problem: This dependency changes on every render\n\n// ...\n\n```\n\nTo solve this, you can wrap the function you need to call from an Effect into `useCallback`:\n\n```js {4-9,16}\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nconst createOptions = useCallback(() => {\n\nreturn {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"88":{"pageContent":"```js {4-9,16}\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nconst createOptions = useCallback(() => {\n\nreturn {\n\nserverUrl: 'https://localhost:1234',\n\nroomId: roomId\n\n};\n\n}, [roomId]); // âœ… Only changes when roomId changes\n\nuseEffect(() => {\n\nconst options = createOptions();\n\nconst connection = createConnection();\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [createOptions]); // âœ… Only changes when createOptions changes\n\n// ...\n\n```\n\nThis ensures that the `createOptions` function is the same between re-renders if the `roomId` is the same. **However, it's even better to remove the need for a function dependency.** Move your function *inside* the Effect:\n\n```js {5-10,16}\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nuseEffect(() => {\n\nfunction createOptions() { // âœ… No need for useCallback or function dependencies!\n\nreturn {\n\nserverUrl: 'https://localhost:1234',\n\nroomId: roomId\n\n};\n\n}\n\nconst options = createOptions();\n\nconst connection = createConnection();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"89":{"pageContent":"return {\n\nserverUrl: 'https://localhost:1234',\n\nroomId: roomId\n\n};\n\n}\n\nconst options = createOptions();\n\nconst connection = createConnection();\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]); // âœ… Only changes when roomId changes\n\n// ...\n\n```\n\nNow your code is simpler and doesn't need `useCallback`. [Learn more about removing Effect dependencies.](/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect)\n\n--\n\n### Optimizing a custom Hook {/*optimizing-a-custom-hook*/}\n\nIf you're writing a [custom Hook,](/learn/reusing-logic-with-custom-hooks) it's recommended to wrap any functions that it returns into `useCallback`:\n\n```js {4-6,8-10}\n\nfunction useRouter() {\n\nconst { dispatch } = useContext(RouterStateContext);\n\nconst navigate = useCallback((url) => {\n\ndispatch({ type: 'navigate', url });\n\n}, [dispatch]);\n\nconst goBack = useCallback(() => {\n\ndispatch({ type: 'back' });\n\n}, [dispatch]);\n\nreturn {\n\nnavigate,\n\ngoBack,\n\n};\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"90":{"pageContent":"const navigate = useCallback((url) => {\n\ndispatch({ type: 'navigate', url });\n\n}, [dispatch]);\n\nconst goBack = useCallback(() => {\n\ndispatch({ type: 'back' });\n\n}, [dispatch]);\n\nreturn {\n\nnavigate,\n\ngoBack,\n\n};\n\n}\n\n```\n\nThis ensures that the consumers of your Hook can optimize their own code when needed.\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### Every time my component renders, `useCallback` returns a different function {/*every-time-my-component-renders-usecallback-returns-a-different-function*/}\n\nMake sure you've specified the dependency array as a second argument!\n\nIf you forget the dependency array, `useCallback` will return a new function every time:\n\n```js {7}\n\nfunction ProductPage({ productId, referrer }) {\n\nconst handleSubmit = useCallback((orderDetails) => {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}); // ðŸ”´ Returns a new function every time: no dependency array\n\n// ...\n\n```\n\nThis is the corrected version passing the dependency array as a second argument:\n\n```js {7}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"91":{"pageContent":"referrer,\n\norderDetails,\n\n});\n\n}); // ðŸ”´ Returns a new function every time: no dependency array\n\n// ...\n\n```\n\nThis is the corrected version passing the dependency array as a second argument:\n\n```js {7}\n\nfunction ProductPage({ productId, referrer }) {\n\nconst handleSubmit = useCallback((orderDetails) => {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails,\n\n});\n\n}, [productId, referrer]); // âœ… Does not return a new function unnecessarily\n\n// ...\n\n```\n\nIf this doesn't help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\n\n```js {5}\n\nconst handleSubmit = useCallback((orderDetails) => {\n\n// ..\n\n}, [productId, referrer]);\n\nconsole.log([productId, referrer]);\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"92":{"pageContent":"```js {5}\n\nconst handleSubmit = useCallback((orderDetails) => {\n\n// ..\n\n}, [productId, referrer]);\n\nconsole.log([productId, referrer]);\n\n```\n\nYou can then right-click on the arrays from different re-renders in the console and select \"Store as a global variable\" for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:\n\n```js\n\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\n\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\n\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n\n```\n\nWhen you find which dependency is breaking memoization, either find a way to remove it, or [memoize it as well.](/reference/react/useMemo#memoizing-a-dependency-of-another-hook)\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"93":{"pageContent":"```\n\nWhen you find which dependency is breaking memoization, either find a way to remove it, or [memoize it as well.](/reference/react/useMemo#memoizing-a-dependency-of-another-hook)\n\n--\n\n### I need to call `useCallback` for each list item in a loop, but it's not allowed {/*i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed*/}\n\nSuppose the `Chart` component is wrapped in [`memo`](/reference/react/memo). You want to skip re-rendering every `Chart` in the list when the `ReportList` component re-renders. However, you can't call `useCallback` in a loop:\n\n```js {5-14}\n\nfunction ReportList({ items }) {\n\nreturn (\n\n<article>\n\n{items.map(item => {\n\n// ðŸ”´ You can't call useCallback in a loop like this:\n\nconst handleClick = useCallback(() => {\n\nsendReport(item)\n\n}, [item]);\n\nreturn (\n\n<figure key={item.id}>\n\n<Chart onClick={handleClick} />\n\n</figure>\n\n);\n\n})}\n\n</article>\n\n);\n\n}\n\n```\n\nInstead, extract a component for an individual item, and put `useCallback` there:\n\n```js {5,12-21}\n\nfunction ReportList({ items }) {\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"94":{"pageContent":"<Chart onClick={handleClick} />\n\n</figure>\n\n);\n\n})}\n\n</article>\n\n);\n\n}\n\n```\n\nInstead, extract a component for an individual item, and put `useCallback` there:\n\n```js {5,12-21}\n\nfunction ReportList({ items }) {\n\nreturn (\n\n<article>\n\n{items.map(item =>\n\n<Report key={item.id} item={item} />\n\n)}\n\n</article>\n\n);\n\n}\n\nfunction Report({ item }) {\n\n// âœ… Call useCallback at the top level:\n\nconst handleClick = useCallback(() => {\n\nsendReport(item)\n\n}, [item]);\n\nreturn (\n\n<figure>\n\n<Chart onClick={handleClick} />\n\n</figure>\n\n);\n\n}\n\n```\n\nAlternatively, you could remove `useCallback` in the last snippet and instead wrap `Report` itself in [`memo`.](/reference/react/memo) If the `item` prop does not change, `Report` will skip re-rendering, so `Chart` will skip re-rendering too:\n\n```js {5,6-8,15}\n\nfunction ReportList({ items }) {\n\n// ...\n\n}\n\nconst Report = memo(function Report({ item }) {\n\nfunction handleClick() {\n\nsendReport(item);\n\n}\n\nreturn (\n\n<figure>\n\n<Chart data={data} />\n\n</figure>\n\n);\n\n});\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useCallback.md"}},"95":{"pageContent":"--\n\ntitle: useDeferredValue\n\n--\n\n<Intro>\n\n`useDeferredValue` is a React Hook that lets you defer updating a part of the UI.\n\n```js\n\nconst deferredValue = useDeferredValue(value)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useDeferredValue(value)` {/*usedeferredvalue*/}\n\nCall `useDeferredValue` at the top level of your component to get a deferred version of that value.\n\n```js\n\nimport { useState, useDeferredValue } from 'react';\n\nfunction SearchPage() {\n\nconst [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`value`: The value you want to defer. It can have any type.\n\n#### Returns {/*returns*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"96":{"pageContent":"// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`value`: The value you want to defer. It can have any type.\n\n#### Returns {/*returns*/}\n\nDuring the initial render, the returned deferred value will be the same as the value you provided. During updates, React will first attempt a re-render with the old value (so the returned value will match the old value), and then try another re-render in background with the new value (so the returned value will match the updated value).\n\n#### Caveats {/*caveats*/}\n\nThe values you pass to `useDeferredValue` should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to `useDeferredValue`, it will be different on every render, causing unnecessary background re-renders.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"97":{"pageContent":"When `useDeferredValue` receives a different value (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there's another update to the `value`, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.\n\n`useDeferredValue` is integrated with [`<Suspense>`.](/reference/react/Suspense) If the background update caused by a new value suspends the UI, the user will not see the fallback. They will keep seeing the old deferred value until the data loads.\n\n`useDeferredValue` does not by itself prevent extra network requests.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"98":{"pageContent":"`useDeferredValue` does not by itself prevent extra network requests.\n\nThere is no fixed delay caused by `useDeferredValue` itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. However, any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.\n\nThe background re-render caused by `useDeferredValue` does not fire Effects until it's committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.\n\n--\n\n## Usage {/*usage*/}\n\n### Showing stale content while fresh content is loading {/*showing-stale-content-while-fresh-content-is-loading*/}\n\nCall `useDeferredValue` at the top level of your component to defer updating some part of your UI.\n\n```js [[1, 5, \"query\"], [2, 5, \"deferredQuery\"]]\n\nimport { useState, useDeferredValue } from 'react';\n\nfunction SearchPage() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"99":{"pageContent":"```js [[1, 5, \"query\"], [2, 5, \"deferredQuery\"]]\n\nimport { useState, useDeferredValue } from 'react';\n\nfunction SearchPage() {\n\nconst [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\n// ...\n\n}\n\n```\n\nDuring the initial render, the <CodeStep step={2}>deferred value</CodeStep> will be the same as the <CodeStep step={1}>value</CodeStep> you provided.\n\nDuring updates, the <CodeStep step={2}>deferred value</CodeStep> will \"lag behind\" the latest <CodeStep step={1}>value</CodeStep>. In particular, React will first re-render *without* updating the deferred value, and then try to re-render with the newly received value in background.\n\n*Let's walk through an example to see when this is useful.**\n\n<Note>\n\nThis example assumes you use one of Suspense-enabled data sources:\n\nData fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/advanced-features/react-18)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"100":{"pageContent":"Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/advanced-features/react-18)\n\nLazy-loading component code with [`lazy`](/reference/react/lazy)\n\n[Learn more about Suspense and its limitations.](/reference/react/Suspense)\n\n</Note>\n\nIn this example, the `SearchResults` component [suspends](/reference/react/Suspense#displaying-a-fallback-while-content-is-loading) while fetching the search results. Try typing `\"a\"`, waiting for the results, and then editing it to `\"ab\"`. The results for `\"a\"` will get replaced by the loading fallback.\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState } from 'react';\n\nimport SearchResults from './SearchResults.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"101":{"pageContent":"\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState } from 'react';\n\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<SearchResults query={query} />\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```\n\n```js SearchResults.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function SearchResults({ query }) {\n\nif (query === '') {\n\nreturn null;\n\n}\n\nconst albums = use(fetchData(`/search?q=${query}`));\n\nif (albums.length === 0) {\n\nreturn <p>No matches for <i>\"{query}\"</i></p>;\n\n}\n\nreturn (\n\n<ul>\n\n{albums.map(album => (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"102":{"pageContent":"if (query === '') {\n\nreturn null;\n\n}\n\nconst albums = use(fetchData(`/search?q=${query}`));\n\nif (albums.length === 0) {\n\nreturn <p>No matches for <i>\"{query}\"</i></p>;\n\n}\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"103":{"pageContent":"// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/search?q=')) {\n\nreturn await getSearchResults(url.slice('/search?q='.length));\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getSearchResults(query) {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nconst allAlbums = [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"104":{"pageContent":"id: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\nconst lowerQuery = query.trim().toLowerCase();\n\nreturn allAlbums.filter(album => {\n\nconst lowerTitle = album.title.toLowerCase();\n\nreturn (\n\nlowerTitle.startsWith(lowerQuery) ||\n\nlowerTitle.indexOf(' ' + lowerQuery) !== -1\n\n)\n\n});\n\n}\n\n```\n\n```css\n\ninput { margin: 10px; }\n\n```\n\n</Sandpack>\n\nA common alternative UI pattern is to *defer* updating the list of results and to keep showing the previous results until the new results are ready. The `useDeferredValue` Hook lets you pass a deferred version of the query down:\n\n```js {3,11}\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"105":{"pageContent":"```js {3,11}\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<SearchResults query={deferredQuery} />\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```\n\nThe `query` will update immediately, so the input will display the new value. However, the `deferredQuery` will keep its previous value until the data has loaded, so `SearchResults` will show the stale results for a bit.\n\nEnter `\"a\"` in the example below, wait for the results to load, and then edit the input to `\"ab\"`. Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"106":{"pageContent":"{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState, useDeferredValue } from 'react';\n\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<SearchResults query={deferredQuery} />\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```\n\n```js SearchResults.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"107":{"pageContent":"// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function SearchResults({ query }) {\n\nif (query === '') {\n\nreturn null;\n\n}\n\nconst albums = use(fetchData(`/search?q=${query}`));\n\nif (albums.length === 0) {\n\nreturn <p>No matches for <i>\"{query}\"</i></p>;\n\n}\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"108":{"pageContent":"} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/search?q=')) {\n\nreturn await getSearchResults(url.slice('/search?q='.length));\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getSearchResults(query) {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nconst allAlbums = [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"109":{"pageContent":"setTimeout(resolve, 500);\n\n});\n\nconst allAlbums = [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\nconst lowerQuery = query.trim().toLowerCase();\n\nreturn allAlbums.filter(album => {\n\nconst lowerTitle = album.title.toLowerCase();\n\nreturn (\n\nlowerTitle.startsWith(lowerQuery) ||\n\nlowerTitle.indexOf(' ' + lowerQuery) !== -1\n\n)\n\n});\n\n}\n\n```\n\n```css\n\ninput { margin: 10px; }\n\n```\n\n</Sandpack>\n\n<DeepDive>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"110":{"pageContent":"const lowerTitle = album.title.toLowerCase();\n\nreturn (\n\nlowerTitle.startsWith(lowerQuery) ||\n\nlowerTitle.indexOf(' ' + lowerQuery) !== -1\n\n)\n\n});\n\n}\n\n```\n\n```css\n\ninput { margin: 10px; }\n\n```\n\n</Sandpack>\n\n<DeepDive>\n\n#### How does deferring a value work under the hood? {/*how-does-deferring-a-value-work-under-the-hood*/}\n\nYou can think of it as happening in two steps:\n\n1. **First, React re-renders with the new `query` (`\"ab\"`) but with the old `deferredQuery` (still `\"a\")`.** The `deferredQuery` value, which you pass to the result list, is *deferred:* it \"lags behind\" the `query` value.\n\n2. **In background, React tries to re-render with *both* `query` and `deferredQuery` updated to `\"ab\"`.** If this re-render completes, React will show it on the screen. However, if it suspends (the results for `\"ab\"` have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"111":{"pageContent":"The deferred \"background\" rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.\n\nNote that there is still a network request per each keystroke. What's being deferred here is displaying results (until they're ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn't fetch again.\n\n</DeepDive>\n\n--\n\n### Indicating that the content is stale {/*indicating-that-the-content-is-stale*/}\n\nIn the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:\n\n```js {2}\n\n<div style={{","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"112":{"pageContent":"```js {2}\n\n<div style={{\n\nopacity: query !== deferredQuery ? 0.5 : 1,\n\n}}>\n\n<SearchResults query={deferredQuery} />\n\n</div>\n\n```\n\nWith this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState, useDeferredValue } from 'react';\n\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\nconst isStale = query !== deferredQuery;\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"113":{"pageContent":"const deferredQuery = useDeferredValue(query);\n\nconst isStale = query !== deferredQuery;\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<div style={{\n\nopacity: isStale ? 0.5 : 1,\n\ntransition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'\n\n}}>\n\n<SearchResults query={deferredQuery} />\n\n</div>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```\n\n```js SearchResults.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function SearchResults({ query }) {\n\nif (query === '') {\n\nreturn null;\n\n}\n\nconst albums = use(fetchData(`/search?q=${query}`));\n\nif (albums.length === 0) {\n\nreturn <p>No matches for <i>\"{query}\"</i></p>;\n\n}\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"114":{"pageContent":"return null;\n\n}\n\nconst albums = use(fetchData(`/search?q=${query}`));\n\nif (albums.length === 0) {\n\nreturn <p>No matches for <i>\"{query}\"</i></p>;\n\n}\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"115":{"pageContent":"// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/search?q=')) {\n\nreturn await getSearchResults(url.slice('/search?q='.length));\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getSearchResults(query) {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nconst allAlbums = [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"116":{"pageContent":"}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\nconst lowerQuery = query.trim().toLowerCase();\n\nreturn allAlbums.filter(album => {\n\nconst lowerTitle = album.title.toLowerCase();\n\nreturn (\n\nlowerTitle.startsWith(lowerQuery) ||\n\nlowerTitle.indexOf(' ' + lowerQuery) !== -1\n\n)\n\n});\n\n}\n\n```\n\n```css\n\ninput { margin: 10px; }\n\n```\n\n</Sandpack>\n\n--\n\n### Deferring re-rendering for a part of the UI {/*deferring-re-rendering-for-a-part-of-the-ui*/}\n\nYou can also apply `useDeferredValue` as a performance optimization. It is useful when a part of your UI is slow to re-render, there's no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"117":{"pageContent":"Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:\n\n```js\n\nfunction App() {\n\nconst [text, setText] = useState('');\n\nreturn (\n\n<>\n\n<input value={text} onChange={e => setText(e.target.value)} />\n\n<SlowList text={text} />\n\n</>\n\n);\n\n}\n\n```\n\nFirst, optimize `SlowList` to skip re-rendering when its props are the same. To do this, [wrap it in `memo`:](/reference/react/memo#skipping-re-rendering-when-props-are-unchanged)\n\n```js {1,3}\n\nconst SlowList = memo(function SlowList({ text }) {\n\n// ...\n\n});\n\n```\n\nHowever, this only helps if the `SlowList` props are *the same* as during the previous render. The problem you're facing now is that it's slow when they're *different,* and when you actually need to show different visual output.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"118":{"pageContent":"Concretely, the main performance problem is that whenever you type into the input, the `SlowList` receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, `useDeferredValue` lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):\n\n```js {3,7}\n\nfunction App() {\n\nconst [text, setText] = useState('');\n\nconst deferredText = useDeferredValue(text);\n\nreturn (\n\n<>\n\n<input value={text} onChange={e => setText(e.target.value)} />\n\n<SlowList text={deferredText} />\n\n</>\n\n);\n\n}\n\n```\n\nThis does not make re-rendering of the `SlowList` faster. However, it tells React that re-rendering the list can be deprioritized so that it doesn't block the keystrokes. The list will \"lag behind\" the input and then \"catch up\". Like before, React will attempt to update the list as soon as possible, but it will not block the user from typing again.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"119":{"pageContent":"<Recipes titleText=\"The difference between useDeferredValue and unoptimized re-rendering\" titleId=\"examples\">\n\n#### Deferred re-rendering of the list {/*deferred-re-rendering-of-the-list*/}\n\nIn this example, each item in the `SlowList` component is **artificially slowed down** so that you can see how `useDeferredValue` lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list \"lags behind\" it.\n\n<Sandpack>\n\n```js\n\nimport { useState, useDeferredValue } from 'react';\n\nimport SlowList from './SlowList.js';\n\nexport default function App() {\n\nconst [text, setText] = useState('');\n\nconst deferredText = useDeferredValue(text);\n\nreturn (\n\n<>\n\n<input value={text} onChange={e => setText(e.target.value)} />\n\n<SlowList text={deferredText} />\n\n</>\n\n);\n\n}\n\n```\n\n```js SlowList.js\n\nimport { memo } from 'react';\n\nconst SlowList = memo(function SlowList({ text }) {\n\n// Log once. The actual slowdown is inside SlowItem.\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering 250 <SlowItem />');\n\nlet items = [];","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"120":{"pageContent":"const SlowList = memo(function SlowList({ text }) {\n\n// Log once. The actual slowdown is inside SlowItem.\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering 250 <SlowItem />');\n\nlet items = [];\n\nfor (let i = 0; i < 250; i++) {\n\nitems.push(<SlowItem key={i} text={text} />);\n\n}\n\nreturn (\n\n<ul className=\"items\">\n\n{items}\n\n</ul>\n\n);\n\n});\n\nfunction SlowItem({ text }) {\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 1) {\n\n// Do nothing for 1 ms per item to emulate extremely slow code\n\n}\n\nreturn (\n\n<li className=\"item\">\n\nText: {text}\n\n</li>\n\n)\n\n}\n\nexport default SlowList;\n\n```\n\n```css\n\n.items {\n\npadding: 0;\n\n}\n\n.item {\n\nlist-style: none;\n\ndisplay: block;\n\nheight: 40px;\n\npadding: 5px;\n\nmargin-top: 10px;\n\nborder-radius: 4px;\n\nborder: 1px solid #aaa;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Unoptimized re-rendering of the list {/*unoptimized-re-rendering-of-the-list*/}\n\nIn this example, each item in the `SlowList` component is **artificially slowed down**, but there is no `useDeferredValue`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"121":{"pageContent":"In this example, each item in the `SlowList` component is **artificially slowed down**, but there is no `useDeferredValue`.\n\nNotice how typing into the input feels very janky. This is because without `useDeferredValue`, each keystroke forces the entire list to re-render immediately in a non-interruptible way.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport SlowList from './SlowList.js';\n\nexport default function App() {\n\nconst [text, setText] = useState('');\n\nreturn (\n\n<>\n\n<input value={text} onChange={e => setText(e.target.value)} />\n\n<SlowList text={text} />\n\n</>\n\n);\n\n}\n\n```\n\n```js SlowList.js\n\nimport { memo } from 'react';\n\nconst SlowList = memo(function SlowList({ text }) {\n\n// Log once. The actual slowdown is inside SlowItem.\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering 250 <SlowItem />');\n\nlet items = [];\n\nfor (let i = 0; i < 250; i++) {\n\nitems.push(<SlowItem key={i} text={text} />);\n\n}\n\nreturn (\n\n<ul className=\"items\">\n\n{items}\n\n</ul>\n\n);\n\n});\n\nfunction SlowItem({ text }) {\n\nlet startTime = performance.now();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"122":{"pageContent":"for (let i = 0; i < 250; i++) {\n\nitems.push(<SlowItem key={i} text={text} />);\n\n}\n\nreturn (\n\n<ul className=\"items\">\n\n{items}\n\n</ul>\n\n);\n\n});\n\nfunction SlowItem({ text }) {\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 1) {\n\n// Do nothing for 1 ms per item to emulate extremely slow code\n\n}\n\nreturn (\n\n<li className=\"item\">\n\nText: {text}\n\n</li>\n\n)\n\n}\n\nexport default SlowList;\n\n```\n\n```css\n\n.items {\n\npadding: 0;\n\n}\n\n.item {\n\nlist-style: none;\n\ndisplay: block;\n\nheight: 40px;\n\npadding: 5px;\n\nmargin-top: 10px;\n\nborder-radius: 4px;\n\nborder: 1px solid #aaa;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"123":{"pageContent":"```\n\n```css\n\n.items {\n\npadding: 0;\n\n}\n\n.item {\n\nlist-style: none;\n\ndisplay: block;\n\nheight: 40px;\n\npadding: 5px;\n\nmargin-top: 10px;\n\nborder-radius: 4px;\n\nborder: 1px solid #aaa;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n<Pitfall>\n\nThis optimization requires `SlowList` to be wrapped in [`memo`.](/reference/react/memo) This is because whenever the `text` changes, React needs to be able to re-render the parent component quickly. During that re-render, `deferredText` still has its previous value, so `SlowList` is able to skip re-rendering (its props have not changed). Without [`memo`,](/reference/react/memo) it would have to re-render anyway, defeating the point of the optimization.\n\n</Pitfall>\n\n<DeepDive>\n\n#### How is deferring a value different from debouncing and throttling? {/*how-is-deferring-a-value-different-from-debouncing-and-throttling*/}\n\nThere are two common optimization techniques you might have used before in this scenario:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"124":{"pageContent":"There are two common optimization techniques you might have used before in this scenario:\n\n*Debouncing* means you'd wait for the user to stop typing (e.g. for a second) before updating the list.\n\n*Throttling* means you'd update the list every once in a while (e.g. at most once a second).\n\nWhile these techniques are helpful in some cases, `useDeferredValue` is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user's device.\n\nUnlike debouncing or throttling, it doesn't require choosing any fixed delay. If the user's device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn't be noticeable. If the user's device is slow, the list would \"lag behind\" the input proportionally to how slow the device is.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"125":{"pageContent":"Also, unlike with debouncing or throttling, deferred re-renders done by `useDeferredValue` are interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in background again. By contrast, debouncing and throttling still produce a janky experience because they're *blocking:* they merely postpone the moment when rendering blocks the keystroke.\n\nIf the work you're optimizing doesn't happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.\n\n</DeepDive>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDeferredValue.md"}},"126":{"pageContent":"--\n\ntitle: \"Built-in React Components\"\n\n--\n\n<Intro>\n\nReact exposes a few built-in components that you can use in your JSX.\n\n</Intro>\n\n--\n\n## Built-in components {/*built-in-components*/}\n\n[`<Fragment>`](/reference/react/Fragment), alternatively written as `<>...</>`, lets you group multiple JSX nodes together.\n\n[`<Profiler>`](/reference/react/Profiler) lets you measure rendering performance of a React tree programmatically.\n\n[`<Suspense>`](/reference/react/Suspense) lets you display a fallback while the child components are loading.\n\n[`<StrictMode>`](/reference/react/StrictMode) enables extra development-only checks that help you find bugs early.\n\n--\n\n## Your own components {/*your-own-components*/}\n\nYou can also [define your own components](/learn/your-first-component) as JavaScript functions.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/components.md"}},"127":{"pageContent":"--\n\ntitle: PureComponent\n\n--\n\n<Pitfall>\n\nWe recommend to define components as functions instead of classes. [See how to migrate.](#alternatives)\n\n</Pitfall>\n\n<Intro>\n\n`PureComponent` is similar to [`Component`](/reference/react/Component) but it skips re-renders for same props and state. Class components are still supported by React, but we don't recommend using them in new code.\n\n```js\n\nclass Greeting extends PureComponent {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `PureComponent` {/*purecomponent*/}\n\nTo skip re-rendering a class component for same props and state, extend `PureComponent` instead of [`Component`:](/reference/react/Component)\n\n```js\n\nimport { PureComponent } from 'react';\n\nclass Greeting extends PureComponent {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/PureComponent.md"}},"128":{"pageContent":"```js\n\nimport { PureComponent } from 'react';\n\nclass Greeting extends PureComponent {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\n`PureComponent` is a subclass of `Component` and supports [all the `Component` APIs.](/reference/react/Component#reference) Extending `PureComponent` is equivalent to defining a custom [`shouldComponentUpdate`](/reference/react/Component#shouldcomponentupdate) method that shallowly compares props and state.\n\n[See more examples below.](#usage)\n\n--\n\n## Usage {/*usage*/}\n\n### Skipping unnecessary re-renders for class components {/*skipping-unnecessary-re-renders-for-class-components*/}\n\nReact normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state. [Class components](/reference/react/Component) can opt into this behavior by extending `PureComponent`:\n\n```js {1}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/PureComponent.md"}},"129":{"pageContent":"```js {1}\n\nclass Greeting extends PureComponent {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\nA React component should always have [pure rendering logic.](/learn/keeping-components-pure) This means that it must return the same output if its props, state, and context haven't changed. By using `PureComponent`, you are telling React that your component complies with this requirement, so React doesn't need to re-render as long as its props and state haven't changed. However, your component will still re-render if a context that it's using changes.\n\nIn this example, notice that the `Greeting` component re-renders whenever `name` is changed (because that's one of its props), but not when `address` is changed (because it's not passed to `Greeting` as a prop):\n\n<Sandpack>\n\n```js\n\nimport { PureComponent, useState } from 'react';\n\nclass Greeting extends PureComponent {\n\nrender() {\n\nconsole.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());","metadata":{"source":"reactjs.org/beta/src/content/reference/react/PureComponent.md"}},"130":{"pageContent":"<Sandpack>\n\n```js\n\nimport { PureComponent, useState } from 'react';\n\nclass Greeting extends PureComponent {\n\nrender() {\n\nconsole.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n\nreturn <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;\n\n}\n\n}\n\nexport default function MyApp() {\n\nconst [name, setName] = useState('');\n\nconst [address, setAddress] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nName{': '}\n\n<input value={name} onChange={e => setName(e.target.value)} />\n\n</label>\n\n<label>\n\nAddress{': '}\n\n<input value={address} onChange={e => setAddress(e.target.value)} />\n\n</label>\n\n<Greeting name={name} />\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-bottom: 16px;\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\nWe recommend to define components as functions instead of classes. [See how to migrate.](#alternatives)\n\n</Pitfall>\n\n--\n\n## Alternatives {/*alternatives*/}\n\n### Migrating from a `PureComponent` class component to a function {/*migrating-from-a-purecomponent-class-component-to-a-function*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/PureComponent.md"}},"131":{"pageContent":"</Pitfall>\n\n--\n\n## Alternatives {/*alternatives*/}\n\n### Migrating from a `PureComponent` class component to a function {/*migrating-from-a-purecomponent-class-component-to-a-function*/}\n\nWe recommend to use function components instead of [class components](/reference/react/Component) in the new code. If you have some existing class components using `PureComponent`, here is how you can convert them. This is the original code:\n\n<Sandpack>\n\n```js\n\nimport { PureComponent, useState } from 'react';\n\nclass Greeting extends PureComponent {\n\nrender() {\n\nconsole.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n\nreturn <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;\n\n}\n\n}\n\nexport default function MyApp() {\n\nconst [name, setName] = useState('');\n\nconst [address, setAddress] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nName{': '}\n\n<input value={name} onChange={e => setName(e.target.value)} />\n\n</label>\n\n<label>\n\nAddress{': '}\n\n<input value={address} onChange={e => setAddress(e.target.value)} />\n\n</label>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/PureComponent.md"}},"132":{"pageContent":"return (\n\n<>\n\n<label>\n\nName{': '}\n\n<input value={name} onChange={e => setName(e.target.value)} />\n\n</label>\n\n<label>\n\nAddress{': '}\n\n<input value={address} onChange={e => setAddress(e.target.value)} />\n\n</label>\n\n<Greeting name={name} />\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-bottom: 16px;\n\n}\n\n```\n\n</Sandpack>\n\nWhen you [convert this component from a class to a function,](/reference/react/Component#alternatives) wrap it in [`memo`:](/reference/react/memo)\n\n<Sandpack>\n\n```js\n\nimport { memo, useState } from 'react';\n\nconst Greeting = memo(function Greeting({ name }) {\n\nconsole.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n\nreturn <h3>Hello{name && ', '}{name}!</h3>;\n\n});\n\nexport default function MyApp() {\n\nconst [name, setName] = useState('');\n\nconst [address, setAddress] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nName{': '}\n\n<input value={name} onChange={e => setName(e.target.value)} />\n\n</label>\n\n<label>\n\nAddress{': '}\n\n<input value={address} onChange={e => setAddress(e.target.value)} />\n\n</label>\n\n<Greeting name={name} />\n\n</>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/PureComponent.md"}},"133":{"pageContent":"<input value={name} onChange={e => setName(e.target.value)} />\n\n</label>\n\n<label>\n\nAddress{': '}\n\n<input value={address} onChange={e => setAddress(e.target.value)} />\n\n</label>\n\n<Greeting name={name} />\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-bottom: 16px;\n\n}\n\n```\n\n</Sandpack>\n\n<Note>\n\nUnlike `PureComponent`, [`memo`](/reference/react/memo) does not compare the new and the old state. In function components, calling the [`set` function](/reference/react/useState#setstate) with the same state [already prevents re-renders by default,](/reference/react/memo#updating-a-memoized-component-using-state) even without `memo`.\n\n</Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/PureComponent.md"}},"134":{"pageContent":"--\n\ntitle: useSyncExternalStore\n\n--\n\n<Intro>\n\n`useSyncExternalStore` is a React Hook that lets you subscribe to an external store.\n\n```js\n\nconst snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)` {/*usesyncexternalstore*/}\n\nCall `useSyncExternalStore` at the top level of your component to read a value from an external data store.\n\n```js\n\nimport { useSyncExternalStore } from 'react';\n\nimport { todosStore } from './todoStore.js';\n\nfunction TodosApp() {\n\nconst todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n\n// ...\n\n}\n\n```\n\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n\n1. The `subscribe` function should subscribe to the store and return a function that unsubscribes.\n\n2. The `getSnapshot` function should read a snapshot of the data from the store.\n\n[See more examples below.](#usage)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"135":{"pageContent":"2. The `getSnapshot` function should read a snapshot of the data from the store.\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`subscribe`: A function that takes a single `callback` argument and subscribes it to the store. When the store changes, it should invoke the provided `callback`. This will cause the component to re-render. The `subscribe` function should return a function that cleans up the subscription.\n\n`getSnapshot`: A function that returns a snapshot of the data in the store that's needed by the component. While the store has not changed, repeated calls to `getSnapshot` must return the same value. If the store changes and the returned value is different (as compared by [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), React will re-render the component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"136":{"pageContent":"**optional** `getServerSnapshot`: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If this function is not provided, rendering the component on the server will throw an error.\n\n#### Returns {/*returns*/}\n\nThe current snapshot of the store which you can use in your rendering logic.\n\n#### Caveats {/*caveats*/}\n\nThe store snapshot returned by `getSnapshot` must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.\n\nIf a different `subscribe` function is passed during a re-render, React will re-subscribe to the store using the newly passed `subscribe` function. You can prevent this by declaring `subscribe` outside the component.\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"137":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Subscribing to an external store {/*subscribing-to-an-external-store*/}\n\nMost of your React components will only read data from their [props,](/learn/passing-props-to-a-component) [state,](/reference/react/useState) and [context.](/reference/react/useContext) However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:\n\nThird-party state management libraries that hold state outside of React.\n\nBrowser APIs that expose a mutable value and events to subscribe to its changes.\n\nCall `useSyncExternalStore` at the top level of your component to read a value from an external data store.\n\n```js [[1, 5, \"todosStore.subscribe\"], [2, 5, \"todosStore.getSnapshot\"], [3, 5, \"todos\", 0]]\n\nimport { useSyncExternalStore } from 'react';\n\nimport { todosStore } from './todoStore.js';\n\nfunction TodosApp() {\n\nconst todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"138":{"pageContent":"import { todosStore } from './todoStore.js';\n\nfunction TodosApp() {\n\nconst todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n\n// ...\n\n}\n\n```\n\nIt returns the <CodeStep step={3}>snapshot</CodeStep> of the data in the store. You need to pass two functions as arguments:\n\n1. The <CodeStep step={1}>`subscribe` function</CodeStep> should subscribe to the store and return a function that unsubscribes.\n\n2. The <CodeStep step={2}>`getSnapshot` function</CodeStep> should read a snapshot of the data from the store.\n\nReact will use these functions to keep your component subscribed to the store and re-render it on changes.\n\nFor example, in the sandbox below, `todosStore` is implemented as an external store that stores data outside of React. The `TodosApp` component connects to that external store with the `useSyncExternalStore` Hook.\n\n<Sandpack>\n\n```js\n\nimport { useSyncExternalStore } from 'react';\n\nimport { todosStore } from './todoStore.js';\n\nexport default function TodosApp() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"139":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useSyncExternalStore } from 'react';\n\nimport { todosStore } from './todoStore.js';\n\nexport default function TodosApp() {\n\nconst todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n\nreturn (\n\n<>\n\n<button onClick={() => todosStore.addTodo()}>Add todo</button>\n\n<hr />\n\n<ul>\n\n{todos.map(todo => (\n\n<li key={todo.id}>{todo.text}</li>\n\n))}\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```js todoStore.js\n\n// This is an example of a third-party store\n\n// that you might need to integrate with React.\n\n// If your app is fully built with React,\n\n// we recommend using React state instead.\n\nlet nextId = 0;\n\nlet todos = [{ id: nextId++, text: 'Todo #1' }];\n\nlet listeners = [];\n\nexport const todosStore = {\n\naddTodo() {\n\ntodos = [...todos, { id: nextId++, text: 'Todo #' + nextId }]\n\nemitChange();\n\n},\n\nsubscribe(listener) {\n\nlisteners = [...listeners, listener];\n\nreturn () => {\n\nlisteners = listeners.filter(l => l !== listener);\n\n};\n\n},\n\ngetSnapshot() {\n\nreturn todos;\n\n}\n\n};\n\nfunction emitChange() {\n\nfor (let listener of listeners) {\n\nlistener();\n\n}\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"140":{"pageContent":"return () => {\n\nlisteners = listeners.filter(l => l !== listener);\n\n};\n\n},\n\ngetSnapshot() {\n\nreturn todos;\n\n}\n\n};\n\nfunction emitChange() {\n\nfor (let listener of listeners) {\n\nlistener();\n\n}\n\n}\n\n```\n\n</Sandpack>\n\n<Note>\n\nWhen possible, we recommend to use the built-in React state with [`useState`](/reference/react/useState) and [`useReducer`](/reference/react/useReducer) instead. The `useSyncExternalStore` API is mostly useful if you need to integrate with existing non-React code.\n\n</Note>\n\n--\n\n### Subscribing to a browser API {/*subscribing-to-a-browser-api*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"141":{"pageContent":"</Note>\n\n--\n\n### Subscribing to a browser API {/*subscribing-to-a-browser-api*/}\n\nAnother reason to add `useSyncExternalStore` is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called [`navigator.onLine`.](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine) This value can change over time without React's knowledge, so you need to read it with `useSyncExternalStore`.\n\n```js\n\nimport { useSyncExternalStore } from 'react';\n\nfunction ChatIndicator() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n// ...\n\n}\n\n```\n\nTo implement the `getSnapshot` function, read the current value from the browser API:\n\n```js\n\nfunction getSnapshot() {\n\nreturn navigator.onLine;\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"142":{"pageContent":"// ...\n\n}\n\n```\n\nTo implement the `getSnapshot` function, read the current value from the browser API:\n\n```js\n\nfunction getSnapshot() {\n\nreturn navigator.onLine;\n\n}\n\n```\n\nNext, you need to implement the `subscribe` function. For example, when `navigator.onLine` changes, the browser fires the [`online`](https://developer.mozilla.org/en-US/docs/Web/API/Window/online_event) and [`offline`](https://developer.mozilla.org/en-US/docs/Web/API/Window/offline_event) events on the `window` object. You need to subscribe the `callback` argument to the corresponding events, and then return a function that cleans up the subscriptions:\n\n```js\n\nfunction subscribe(callback) {\n\nwindow.addEventListener('online', callback);\n\nwindow.addEventListener('offline', callback);\n\nreturn () => {\n\nwindow.removeEventListener('online', callback);\n\nwindow.removeEventListener('offline', callback);\n\n};\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"143":{"pageContent":"window.addEventListener('offline', callback);\n\nreturn () => {\n\nwindow.removeEventListener('online', callback);\n\nwindow.removeEventListener('offline', callback);\n\n};\n\n}\n\n```\n\nNow React knows how to read the value from the external `navigator.onLine` API and how to subscribe to its changes. Try to disconnect your device from the network and notice that the component re-renders in response:\n\n<Sandpack>\n\n```js\n\nimport { useSyncExternalStore } from 'react';\n\nexport default function ChatIndicator() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\nreturn <h1>{isOnline ? 'âœ… Online' : 'âŒ Disconnected'}</h1>;\n\n}\n\nfunction getSnapshot() {\n\nreturn navigator.onLine;\n\n}\n\nfunction subscribe(callback) {\n\nwindow.addEventListener('online', callback);\n\nwindow.addEventListener('offline', callback);\n\nreturn () => {\n\nwindow.removeEventListener('online', callback);\n\nwindow.removeEventListener('offline', callback);\n\n};\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Extracting the logic to a custom Hook {/*extracting-the-logic-to-a-custom-hook*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"144":{"pageContent":"window.removeEventListener('online', callback);\n\nwindow.removeEventListener('offline', callback);\n\n};\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Extracting the logic to a custom Hook {/*extracting-the-logic-to-a-custom-hook*/}\n\nUsually you won't write `useSyncExternalStore` directly in your components. Instead, you'll typically call it from your own custom Hook. This lets you use the same external store from different components.\n\nFor example, this custom `useOnlineStatus` Hook tracks whether the network is online:\n\n```js {3,6}\n\nimport { useSyncExternalStore } from 'react';\n\nexport function useOnlineStatus() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\nreturn isOnline;\n\n}\n\nfunction getSnapshot() {\n\n// ...\n\n}\n\nfunction subscribe(callback) {\n\n// ...\n\n}\n\n```\n\nNow different components can call `useOnlineStatus` without repeating the underlying implementation:\n\n<Sandpack>\n\n```js\n\nimport { useOnlineStatus } from './useOnlineStatus.js';\n\nfunction StatusBar() {\n\nconst isOnline = useOnlineStatus();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"145":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useOnlineStatus } from './useOnlineStatus.js';\n\nfunction StatusBar() {\n\nconst isOnline = useOnlineStatus();\n\nreturn <h1>{isOnline ? 'âœ… Online' : 'âŒ Disconnected'}</h1>;\n\n}\n\nfunction SaveButton() {\n\nconst isOnline = useOnlineStatus();\n\nfunction handleSaveClick() {\n\nconsole.log('âœ… Progress saved');\n\n}\n\nreturn (\n\n<button disabled={!isOnline} onClick={handleSaveClick}>\n\n{isOnline ? 'Save progress' : 'Reconnecting...'}\n\n</button>\n\n);\n\n}\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<SaveButton />\n\n<StatusBar />\n\n</>\n\n);\n\n}\n\n```\n\n```js useOnlineStatus.js\n\nimport { useSyncExternalStore } from 'react';\n\nexport function useOnlineStatus() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\nreturn isOnline;\n\n}\n\nfunction getSnapshot() {\n\nreturn navigator.onLine;\n\n}\n\nfunction subscribe(callback) {\n\nwindow.addEventListener('online', callback);\n\nwindow.addEventListener('offline', callback);\n\nreturn () => {\n\nwindow.removeEventListener('online', callback);\n\nwindow.removeEventListener('offline', callback);\n\n};\n\n}\n\n```\n\n</Sandpack>\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"146":{"pageContent":"window.addEventListener('offline', callback);\n\nreturn () => {\n\nwindow.removeEventListener('online', callback);\n\nwindow.removeEventListener('offline', callback);\n\n};\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Adding support for server rendering {/*adding-support-for-server-rendering*/}\n\nIf your React app uses [server rendering,](/reference/react-dom/server) your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:\n\nIf you're connecting to a browser-only API, it won't work because it does not exist on the server.\n\nIf you're connecting to a third-party data store, you'll need its data to match between the server and client.\n\nTo solve these issues, pass a `getServerSnapshot` function as the third argument to `useSyncExternalStore`:\n\n```js {4,12-14}\n\nimport { useSyncExternalStore } from 'react';\n\nexport function useOnlineStatus() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\nreturn isOnline;\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"147":{"pageContent":"```js {4,12-14}\n\nimport { useSyncExternalStore } from 'react';\n\nexport function useOnlineStatus() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\nreturn isOnline;\n\n}\n\nfunction getSnapshot() {\n\nreturn navigator.onLine;\n\n}\n\nfunction getServerSnapshot() {\n\nreturn true; // Always show \"Online\" for server-generated HTML\n\n}\n\nfunction subscribe(callback) {\n\n// ...\n\n}\n\n```\n\nThe `getServerSnapshot` function is similar to `getSnapshot`, but it runs only in two situations:\n\nIt runs on the server when generating the HTML.\n\nIt runs on the client during [hydration](/reference/react-dom/client/hydrateRoot), i.e. when React takes the server HTML and makes it interactive.\n\nThis lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, you can [force the component to render only on the client.](/reference/react/Suspense#providing-a-fallback-for-server-errors-and-server-only-content)\n\n<Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"148":{"pageContent":"<Note>\n\nMake sure that `getServerSnapshot` returns the same exact data on the initial client render as it returned on the server. For example, if `getServerSnapshot` returned some prepopulated store content on the server, you need to transfer this content to the client. One common way to do this is to emit a `<script>` tag that sets a global like `window.MY_STORE_DATA` during server rendering, and then read from that global on the client in `getServerSnapshot`. Your external store should provide instructions on how to do that.\n\n</Note>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### I'm getting an error: \"The result of `getSnapshot` should be cached\" {/*im-getting-an-error-the-result-of-getsnapshot-should-be-cached*/}\n\nIf you get this error, it means your `getSnapshot` function returns a new object every time it's called, for example:\n\n```js {2-5}\n\nfunction getSnapshot() {\n\n// ðŸ”´ Do not return always different objects from getSnapshot\n\nreturn {\n\ntodos: myStore.todos\n\n};\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"149":{"pageContent":"```js {2-5}\n\nfunction getSnapshot() {\n\n// ðŸ”´ Do not return always different objects from getSnapshot\n\nreturn {\n\ntodos: myStore.todos\n\n};\n\n}\n\n```\n\nReact will re-render the component if `getSnapshot` return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.\n\nYour `getSnapshot` object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:\n\n```js {2-3}\n\nfunction getSnapshot() {\n\n// âœ… You can return immutable data\n\nreturn myStore.todos;\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"150":{"pageContent":"```js {2-3}\n\nfunction getSnapshot() {\n\n// âœ… You can return immutable data\n\nreturn myStore.todos;\n\n}\n\n```\n\nIf your store data is mutable, your `getSnapshot` function should return an immutable snapshot of it. This means it *does* need to create new objects, but it shouldn't do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on how your mutable store is implemented.\n\n--\n\n### My `subscribe` function gets called after every re-render {/*my-subscribe-function-gets-called-after-every-re-render*/}\n\nThis `subscribe` function is defined *inside* a component so it is different on every re-render:\n\n```js {4-7}\n\nfunction ChatIndicator() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n// ðŸš© Always a different function, so React will resubscribe on every re-render\n\nfunction subscribe() {\n\n// ...\n\n}\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"151":{"pageContent":"const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n// ðŸš© Always a different function, so React will resubscribe on every re-render\n\nfunction subscribe() {\n\n// ...\n\n}\n\n// ...\n\n}\n\n```\n\nReact will resubscribe to your store if you pass a different `subscribe` function between re-renders. If this causes performance issues and you'd like to avoid resubscribing to the store, move the `subscribe` function outside:\n\n```js {6-9}\n\nfunction ChatIndicator() {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n// ...\n\n}\n\n// âœ… Always the same function, so React won't need to resubscribe\n\nfunction subscribe() {\n\n// ...\n\n}\n\n```\n\nAlternatively, wrap `subscribe` into [`useCallback`](/reference/react/useCallback) to only resubscribe when some argument changes:\n\n```js {4-8}\n\nfunction ChatIndicator({ userId }) {\n\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n\n// âœ… Same function as long as userId doesn't change\n\nconst subscribe = useCallback(() => {\n\n// ...\n\n}, [userId]);\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useSyncExternalStore.md"}},"152":{"pageContent":"--\ntitle: useInsertionEffect\n---\n\n\n\n`useInsertionEffect` is aimed at CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want [`useEffect`](/reference/react/useEffect) or [`useLayoutEffect`](/reference/react/useLayoutEffect) instead.\n\n\n\n\n\n`useInsertionEffect` is a version of [`useEffect`](/reference/react/useEffect) that fires before any DOM mutations.\n\n```js\nuseInsertionEffect(setup, dependencies?)\n```\n\n\n\n\n\n---\n\n## Reference {/*reference*/}\n\n### `useInsertionEffect(setup, dependencies?)` {/*useinsertioneffect*/}\n\nCall `useInsertionEffect` to insert the styles before any DOM mutations:\n\n```js\nimport { useInsertionEffect } from 'react';\n\n// Inside your CSS-in-JS library\nfunction useCSS(rule) {\n  useInsertionEffect(() => {\n    // ... inject  tags here ...\n  });\n  return rule;\n}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"153":{"pageContent":"* `setup`: The function with your Effect's logic. Your setup function may also optionally return a *cleanup* function. Before your component is first added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function one last time.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"154":{"pageContent":"* **optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm. If you don't specify the dependencies at all, your Effect will re-run after every re-render of the component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"155":{"pageContent":"#### Returns {/*returns*/}\n\n`useInsertionEffect` returns `undefined`.\n\n#### Caveats {/*caveats*/}\n\n* Effects only run on the client. They don't run during server rendering.\n* You can't update state from inside `useInsertionEffect`.\n* By the time `useInsertionEffect` runs, refs are not attached yet, and DOM is not yet updated.\n\n---\n\n## Usage {/*usage*/}\n\n### Injecting dynamic styles from CSS-in-JS libraries {/*injecting-dynamic-styles-from-css-in-js-libraries*/}\n\nTraditionally, you would style React components using plain CSS.\n\n```js\n// In your JS file:\n<button className=\"success\" />\n\n// In your CSS file:\n.success { color: green; }\n```\n\nSome teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS you might encounter:\n\n1. Static extraction to CSS files with a compiler\n2. Inline styles, e.g. `<div style={{ opacity: 1 }}>`\n3. Runtime injection of `<style>` tags","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"156":{"pageContent":"1. Static extraction to CSS files with a compiler\n2. Inline styles, e.g. `<div style={{ opacity: 1 }}>`\n3. Runtime injection of `<style>` tags\n\nIf you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). **We don't recommend runtime `<style>` tag injection for two reasons:**\n\n1. Runtime injection forces the browser to recalculate the styles a lot more often.\n2. Runtime injection can be very slow if it happens at the wrong time in the React lifecycle.\n\nThe first problem is not solvable, but `useInsertionEffect` helps you solve the second problem.\n\nCall `useInsertionEffect` to insert the styles before any DOM mutations:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"157":{"pageContent":"The first problem is not solvable, but `useInsertionEffect` helps you solve the second problem.\n\nCall `useInsertionEffect` to insert the styles before any DOM mutations:\n\n```js {4-11}\n// Inside your CSS-in-JS library\nlet isInserted = new Set();\nfunction useCSS(rule) {\n  useInsertionEffect(() => {\n    // As explained earlier, we don't recommend runtime injection of <style> tags.\n    // But if you have to do it, then it's important to do in useInsertionEffect.\n    if (!isInserted.has(rule)) {\n      isInserted.add(rule);\n      document.head.appendChild(getStyleForRule(rule));\n    }\n  });\n  return rule;\n}\n\nfunction Button() {\n  const className = useCSS('...');\n  return <div className={className} />;\n}\n```\n\nSimilarly to `useEffect`, `useInsertionEffect` does not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:\n\n```js {1,4-6}\nlet collectedRulesSet = new Set();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"158":{"pageContent":"```js {1,4-6}\nlet collectedRulesSet = new Set();\n\nfunction useCSS(rule) {\n  if (typeof window === 'undefined') {\n    collectedRulesSet.add(rule);\n  }\n  useInsertionEffect(() => {\n    // ...\n  });\n  return rule;\n}\n```\n\n[Read more about upgrading CSS-in-JS libraries with runtime injection to `useInsertionEffect`.](https://github.com/reactwg/react-18/discussions/110)\n\n<DeepDive>\n\n#### How is this better than injecting styles during rendering or useLayoutEffect? {/*how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect*/}\n\nIf you insert styles during rendering and React is processing a [non-blocking update,](/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition) the browser will recalculate the styles every single frame while rendering a component tree, which can be **extremely slow.**","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"159":{"pageContent":"`useInsertionEffect` is better than inserting styles during [`useLayoutEffect`](/reference/react/useLayoutEffect) or [`useEffect`](/reference/react/useEffect) because it ensures that by the time other Effects run in your components, the `<style>` tags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles.\n\n</DeepDive>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useInsertionEffect.md"}},"160":{"pageContent":"--\n\ntitle: <Profiler>\n\n--\n\n<Intro>\n\n`<Profiler>` lets you measure rendering performance of a React tree programmatically.\n\n```js\n\n<Profiler id=\"App\" onRender={onRender}>\n\n<App />\n\n</Profiler>\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `<Profiler>` {/*profiler*/}\n\nWrap a component tree in a `<Profiler>` to measure its rendering performance.\n\n```js\n\n<Profiler id=\"App\" onRender={onRender}>\n\n<App />\n\n</Profiler>\n\n```\n\n#### Props {/*props*/}\n\n`id`: A string identifying the part of the UI you are measuring.\n\n`onRender`: An [`onRender` callback](#onrender-callback) that React calls it every time components within the profiled tree update. It receives information about what was rendered and how much time it took.\n\n#### Caveats {/*caveats*/}\n\nProfiling adds some additional overhead, so **it is disabled in the production build by default.** To opt into production profiling, you need to enable a [special production build with profiling enabled.](https://fb.me/react-profiling)\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Profiler.md"}},"161":{"pageContent":"--\n\n### `onRender` callback {/*onrender-callback*/}\n\nReact will call your `onRender` callback with information about what was rendered.\n\n```js\n\nfunction onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {\n\n// Aggregate or log render timings...\n\n}\n\n```\n\n#### Parameters {/*onrender-parameters*/}\n\n`id`: The string `id` prop of the `<Profiler>` tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.\n\n`phase`: `\"mount\"`, `\"update\"` or `\"nested-update\"`. This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Profiler.md"}},"162":{"pageContent":"`phase`: `\"mount\"`, `\"update\"` or `\"nested-update\"`. This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks.\n\n`actualDuration`: The number of milliseconds spent rendering the `<Profiler>` and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. [`memo`](/reference/react/memo) and [`useMemo`](/reference/react/useMemo)). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Profiler.md"}},"163":{"pageContent":"`baseDuration`: The number of milliseconds estimating how much time it would take to re-render the entire `<Profiler>` subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare `actualDuration` against it to see if memoization is working.\n\n`startTime`: A numeric timestamp for when React began rendering the current update.\n\n`endTime`: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.\n\n--\n\n## Usage {/*usage*/}\n\n### Measuring rendering performance programmatically {/*measuring-rendering-performance-programmatically*/}\n\nWrap the `<Profiler>` component around a React tree to measure its rendering performance.\n\n```js {2,4}\n\n<App>\n\n<Profiler id=\"Sidebar\" onRender={onRender}>\n\n<Sidebar />\n\n</Profiler>\n\n<PageContent />","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Profiler.md"}},"164":{"pageContent":"Wrap the `<Profiler>` component around a React tree to measure its rendering performance.\n\n```js {2,4}\n\n<App>\n\n<Profiler id=\"Sidebar\" onRender={onRender}>\n\n<Sidebar />\n\n</Profiler>\n\n<PageContent />\n\n</App>\n\n```\n\nIt requires two props: an `id` (string) and an `onRender` callback (function) which React calls any time a component within the tree \"commits\" an update.\n\n<Pitfall>\n\nProfiling adds some additional overhead, so **it is disabled in the production build by default.** To opt into production profiling, you need to enable a [special production build with profiling enabled.](https://fb.me/react-profiling)\n\n</Pitfall>\n\n<Note>\n\n`<Profiler>` lets you gather measurements programmatically. If you're looking for an interactive profiler, try the Profiler tab in [React Developer Tools](/learn/react-developer-tools). It exposes similar functionality as a browser extension.\n\n</Note>\n\n--\n\n### Measuring different parts of the application {/*measuring-different-parts-of-the-application*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Profiler.md"}},"165":{"pageContent":"</Note>\n\n--\n\n### Measuring different parts of the application {/*measuring-different-parts-of-the-application*/}\n\nYou can use multiple `<Profiler>` components to measure different parts of your application:\n\n```js {5,7}\n\n<App>\n\n<Profiler id=\"Sidebar\" onRender={onRender}>\n\n<Sidebar />\n\n</Profiler>\n\n<Profiler id=\"Content\" onRender={onRender}>\n\n<Content />\n\n</Profiler>\n\n</App>\n\n```\n\nYou can also nest `<Profiler>` components:\n\n```js {5,7,9,12}\n\n<App>\n\n<Profiler id=\"Sidebar\" onRender={onRender}>\n\n<Sidebar />\n\n</Profiler>\n\n<Profiler id=\"Content\" onRender={onRender}>\n\n<Content>\n\n<Profiler id=\"Editor\" onRender={onRender}>\n\n<Editor />\n\n</Profiler>\n\n<Preview />\n\n</Content>\n\n</Profiler>\n\n</App>\n\n```\n\nAlthough `<Profiler>` is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Profiler.md"}},"166":{"pageContent":"--\n\ntitle: Component\n\n--\n\n<Pitfall>\n\nWe recommend to define components as functions instead of classes. [See how to migrate.](#alternatives)\n\n</Pitfall>\n\n<Intro>\n\n`Component` is the base class for the React components defined as [JavaScript classes.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) Class components are still supported by React, but we don't recommend using them in new code.\n\n```js\n\nclass Greeting extends Component {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `Component` {/*component*/}\n\nTo define a React component as a class, extend the built-in `Component` class and define a [`render` method:](#render)\n\n```js\n\nimport { Component } from 'react';\n\nclass Greeting extends Component {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\nOnly the `render` method is required, other methods are optional.\n\n[See more examples below.](#usage)\n\n--\n\n### `context` {/*context*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"167":{"pageContent":"render() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\nOnly the `render` method is required, other methods are optional.\n\n[See more examples below.](#usage)\n\n--\n\n### `context` {/*context*/}\n\nThe [context](/learn/passing-data-deeply-with-context) of a class component is available as `this.context`. It is only available if you specify *which* context you want to receive using [`static contextType`](#static-contexttype) (modern) or [`static contextTypes`](#static-contexttypes) (deprecated).\n\nA class component can only read one context at a time.\n\n```js {2,5}\n\nclass Button extends Component {\n\nstatic contextType = ThemeContext;\n\nrender() {\n\nconst theme = this.context;\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className}>\n\n{this.props.children}\n\n</button>\n\n);\n\n}\n\n}\n\n```\n\n<Note>\n\nReading `this.context` in class components is equivalent to [`useContext`](/reference/react/useContext) in function components.\n\n[See how to migrate.](#migrating-a-component-with-context-from-a-class-to-a-function)\n\n</Note>\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"168":{"pageContent":"[See how to migrate.](#migrating-a-component-with-context-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `props` {/*props*/}\n\nThe props passed to a class component are available as `this.props`.\n\n```js {3}\n\nclass Greeting extends Component {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n<Greeting name=\"Taylor\" />\n\n```\n\n<Note>\n\nReading `this.props` in class components is equivalent to [declaring props](/learn/passing-props-to-a-component#step-2-read-props-inside-the-child-component) in function components.\n\n[See how to migrate.](#migrating-a-simple-component-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `refs` {/*refs*/}\n\n<Deprecated>\n\nThis API will be removed in a future major version of React. [Use `createRef` instead.](/reference/react/createRef)\n\n</Deprecated>\n\nLets you access [legacy string refs](https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) for this component.\n\n--\n\n### `state` {/*state*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"169":{"pageContent":"</Deprecated>\n\nLets you access [legacy string refs](https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) for this component.\n\n--\n\n### `state` {/*state*/}\n\nThe state of a class component is available as `this.state`. The `state` field must be an object. Do not mutate the state directly. If you wish to change the state, call `setState` with the new state.\n\n```js {2-4,7-9,18}\n\nclass Counter extends Component {\n\nstate = {\n\nage: 42,\n\n};\n\nhandleAgeChange = () => {\n\nthis.setState({\n\nage: this.state.age + 1\n\n});\n\n};\n\nrender() {\n\nreturn (\n\n<>\n\n<button onClick={this.handleAgeChange}>\n\nIncrement age\n\n</button>\n\n<p>You are {this.state.age}.</p>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n<Note>\n\nDefining `state` in class components is equivalent to calling [`useState`](/reference/react/useState) in function components.\n\n[See how to migrate.](#migrating-a-component-with-state-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `constructor(props)` {/*constructor*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"170":{"pageContent":"[See how to migrate.](#migrating-a-component-with-state-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `constructor(props)` {/*constructor*/}\n\nThe [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor) runs before your class component *mounts* (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind) your class methods to the class instance:\n\n```js {2-6}\n\nclass Counter extends Component {\n\nconstructor(props) {\n\nsuper(props);\n\nthis.state = { counter: 0 };\n\nthis.handleClick = this.handleClick.bind(this);\n\n}\n\nhandleClick() {\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"171":{"pageContent":"```js {2-6}\n\nclass Counter extends Component {\n\nconstructor(props) {\n\nsuper(props);\n\nthis.state = { counter: 0 };\n\nthis.handleClick = this.handleClick.bind(this);\n\n}\n\nhandleClick() {\n\n// ...\n\n}\n\n```\n\nIf you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the [public class field syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields) which is supported both by modern browsers and tools like [Babel:](https://babeljs.io/)\n\n```js {2,4}\n\nclass Counter extends Component {\n\nstate = { counter: 0 };\n\nhandleClick = () => {\n\n// ...\n\n}\n\n```\n\nA constructor should not contain any side effects or subscriptions.\n\n#### Parameters {/*constructor-parameters*/}\n\n`props`: The component's initial props.\n\n#### Returns {/*constructor-returns*/}\n\n`constructor` should not return anything.\n\n#### Caveats {/*constructor-caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"172":{"pageContent":"#### Parameters {/*constructor-parameters*/}\n\n`props`: The component's initial props.\n\n#### Returns {/*constructor-returns*/}\n\n`constructor` should not return anything.\n\n#### Caveats {/*constructor-caveats*/}\n\nDo not run any side effects or subscriptions in the constructor. Instead, use [`componentDidMount`](#componentdidmount) for that.\n\nInside a constructor, you need to call `super(props)` before any other statement. If you don't do that, `this.props` will be `undefined` while the constructor runs, which can be confusing and cause bugs.\n\nConstructor is the only place where you can assign [`this.state`](#state) directly. In all other methods, you need to use [`this.setState()`](#setstate) instead. Do not call `setState` in the constructor.\n\nWhen you use [server rendering,](/reference/react-dom/server) the constructor will run on the server too, followed by the [`render`](#render) method. However, lifecycle methods like `componentDidMount` or `componentWillUnmount` will not run on the server.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"173":{"pageContent":"When [Strict Mode](/reference/react/StrictMode) is on, React will call `constructor` twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the `constructor`.\n\n<Note>\n\nThere is no exact equivalent for `constructor` in function components. To declare state in a function component, call [`useState`.](/reference/react/useState) To avoid recalculating the initial state, [pass a function to `useState`.](/reference/react/useState#avoiding-recreating-the-initial-state)\n\n</Note>\n\n--\n\n### `componentDidCatch(error, info)` {/*componentdidcatch*/}\n\nIf you define `componentDidCatch`, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"174":{"pageContent":"Typically, it is used together with [`static getDerivedStateFromError`](#static-getderivedstatefromerror) which lets you update state in response to an error and display an error message to the user. A component with these methods is called an *error boundary.*\n\n[See an example.](#catching-rendering-errors-with-an-error-boundary)\n\n#### Parameters {/*componentdidcatch-parameters*/}\n\n`error`: The error that was thrown. In practice, it will usually be an instance of [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) but this is not guaranteed because JavaScript allows to [`throw`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw) any value, including strings or even `null`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"175":{"pageContent":"`info`: An object containing additional information about the error. Its `componentStack` field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.\n\n#### Returns {/*componentdidcatch-returns*/}\n\n`componentDidCatch` should not return anything.\n\n#### Caveats {/*componentdidcatch-caveats*/}\n\nIn the past, it was common to call `setState` inside `componentDidCatch` in order to update the UI and display the fallback error message. This is deprecated in favor of defining [`static getDerivedStateFromError`.](#static-getderivedstatefromerror)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"176":{"pageContent":"Production and development builds of React slightly differ in the way `componentDidCatch` handles errors. In development, the errors will bubble up to `window`, which means that any `window.onerror` or `window.addEventListener('error', callback)` will intercept the errors that have been caught by `componentDidCatch`. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by `componentDidCatch`.\n\n<Note>\n\nThere is no direct equivalent for `componentDidCatch` in function components yet. If you'd like to avoid creating class components, write a single `ErrorBoundary` component like above and use it throughout your app. Alternatively, you can use the [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) package which does that for you.\n\n</Note>\n\n--\n\n### `componentDidMount()` {/*componentdidmount*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"177":{"pageContent":"</Note>\n\n--\n\n### `componentDidMount()` {/*componentdidmount*/}\n\nIf you define the `componentDidMount` method, React will call it when your component is first added *(mounted)* to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.\n\nIf you implement `componentDidMount`, you usually need to implement other lifecycle methods to avoid bugs. For example, if `componentDidMount` reads some state or props, you also have to implement [`componentDidUpdate`](#componentdidupdate) to handle their changes, and [`componentWillUnmount`](#componentwillunmount) to clean up whatever `componentDidMount` was doing.\n\n```js {6-8}\n\nclass ChatRoom extends Component {\n\nstate = {\n\nserverUrl: 'https://localhost:1234'\n\n};\n\ncomponentDidMount() {\n\nthis.setupConnection();\n\n}\n\ncomponentDidUpdate(prevProps, prevState) {\n\nif (\n\nthis.props.roomId !== prevProps.roomId ||\n\nthis.state.serverUrl !== prevState.serverUrl\n\n) {\n\nthis.destroyConnection();\n\nthis.setupConnection();\n\n}\n\n}\n\ncomponentWillUnmount() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"178":{"pageContent":"if (\n\nthis.props.roomId !== prevProps.roomId ||\n\nthis.state.serverUrl !== prevState.serverUrl\n\n) {\n\nthis.destroyConnection();\n\nthis.setupConnection();\n\n}\n\n}\n\ncomponentWillUnmount() {\n\nthis.destroyConnection();\n\n}\n\n// ...\n\n}\n\n```\n\n[See more examples.](#adding-lifecycle-methods-to-a-class-component)\n\n#### Parameters {/*componentdidmount-parameters*/}\n\n`componentDidMount` does not take any parameters.\n\n#### Returns {/*componentdidmount-returns*/}\n\n`componentDidMount` should not return anything.\n\n#### Caveats {/*componentdidmount-caveats*/}\n\nWhen [Strict Mode](/reference/react/StrictMode) is on, in development React will call `componentDidMount`, then immediately call [`componentWillUnmount`,](#componentwillunmount) and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn't fully \"mirror\" what `componentDidMount` does.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"179":{"pageContent":"Although you may call [`setState`](#setstate) immediately in `componentDidMount`, it's best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the [`render`](#render) will be called twice in this case, the user won't see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the [`constructor`](#constructor) instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\n<Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"180":{"pageContent":"<Note>\n\nFor many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](/reference/react/useEffect) in function components. In the rare cases where it's important for the code to run before browser paint, [`useLayoutEffect`](/reference/react/useLayoutEffect) is a closer match.\n\n[See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `componentDidUpdate(prevProps, prevState, snapshot?)` {/*componentdidupdate*/}\n\nIf you define the `componentDidUpdate` method, React will call it immediately after your component has been re-rendered with updated props or state.  This method is not called for the initial render.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"181":{"pageContent":"If you define the `componentDidUpdate` method, React will call it immediately after your component has been re-rendered with updated props or state.  This method is not called for the initial render.\n\nYou can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you'd use it together with [`componentDidMount`](#componentdidmount) and [`componentWillUnmount`:](#componentwillunmount)\n\n```js {10-18}\n\nclass ChatRoom extends Component {\n\nstate = {\n\nserverUrl: 'https://localhost:1234'\n\n};\n\ncomponentDidMount() {\n\nthis.setupConnection();\n\n}\n\ncomponentDidUpdate(prevProps, prevState) {\n\nif (\n\nthis.props.roomId !== prevProps.roomId ||\n\nthis.state.serverUrl !== prevState.serverUrl\n\n) {\n\nthis.destroyConnection();\n\nthis.setupConnection();\n\n}\n\n}\n\ncomponentWillUnmount() {\n\nthis.destroyConnection();\n\n}\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"182":{"pageContent":"this.props.roomId !== prevProps.roomId ||\n\nthis.state.serverUrl !== prevState.serverUrl\n\n) {\n\nthis.destroyConnection();\n\nthis.setupConnection();\n\n}\n\n}\n\ncomponentWillUnmount() {\n\nthis.destroyConnection();\n\n}\n\n// ...\n\n}\n\n```\n\n[See more examples.](#adding-lifecycle-methods-to-a-class-component)\n\n#### Parameters {/*componentdidupdate-parameters*/}\n\n`prevProps`: Props before the update. Compare `prevProps` to [`this.props`](#props) to determine what changed.\n\n`prevState`: State before the update. Compare `prevState` to [`this.state`](#state) to determine what changed.\n\n`snapshot`: If you implemented [`getSnapshotBeforeUpdate`](#getsnapshotbeforeupdate), `snapshot` will contain the value you returned from that method. Otherwise, it will be `undefined`.\n\n#### Returns {/*componentdidupdate-returns*/}\n\n`componentDidUpdate` should not return anything.\n\n#### Caveats {/*componentdidupdate-caveats*/}\n\n`componentDidUpdate` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"183":{"pageContent":"#### Caveats {/*componentdidupdate-caveats*/}\n\n`componentDidUpdate` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n\nThe logic inside `componentDidUpdate` should usually be wrapped in conditions comparing `this.props` with `prevProps`, and `this.state` with `prevState`. Otherwise, there's a risk of creating infinite loops.\n\nAlthough you may call [`setState`](#setstate) immediately in `componentDidUpdate`, it's best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the [`render`](#render) will be called twice in this case, the user won't see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\n<Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"184":{"pageContent":"<Note>\n\nFor many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](/reference/react/useEffect) in function components. In the rare cases where it's important for the code to run before browser paint, [`useLayoutEffect`](/reference/react/useLayoutEffect) is a closer match.\n\n[See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `componentWillMount()` {/*componentwillmount*/}\n\n<Deprecated>\n\nThis API has been renamed from `componentWillMount` to [`UNSAFE_componentWillMount`.](#unsafe_componentwillmount) The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.\n\n</Deprecated>\n\n--\n\n### `componentWillReceiveProps(nextProps)` {/*componentwillreceiveprops*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"185":{"pageContent":"</Deprecated>\n\n--\n\n### `componentWillReceiveProps(nextProps)` {/*componentwillreceiveprops*/}\n\n<Deprecated>\n\nThis API has been renamed from `componentWillReceiveProps` to [`UNSAFE_componentWillReceiveProps`.](#unsafe_componentwillreceiveprops) The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.\n\n</Deprecated>\n\n--\n\n### `componentWillUpdate(nextProps, nextState)` {/*componentwillupdate*/}\n\n<Deprecated>\n\nThis API has been renamed from `componentWillUpdate` to [`UNSAFE_componentWillUpdate`.](#unsafe_componentwillupdate) The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.\n\n</Deprecated>\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"186":{"pageContent":"Run the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.\n\n</Deprecated>\n\n--\n\n### `componentWillUnmount()` {/*componentwillunmount*/}\n\nIf you define the `componentWillUnmount` method, React will call it before your component is removed *(unmounted)* from the screen. This is a common place to cancel data fetching or remove subscriptions.\n\nThe logic inside `componentWillUnmount` should \"mirror\" the logic inside [`componentDidMount`.](#componentdidmount) For example, if `componentDidMount` sets up a subscription, `componentWillUnmount` should clean up that subscription. If the cleanup logic your `componentWillUnmount` reads some props or state, you will usually also need to implement [`componentDidUpdate`](#componentdidupdate) to clean up resources (such as subscriptions) corresponding to the old props and state.\n\n```js {20-22}\n\nclass ChatRoom extends Component {\n\nstate = {\n\nserverUrl: 'https://localhost:1234'\n\n};","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"187":{"pageContent":"```js {20-22}\n\nclass ChatRoom extends Component {\n\nstate = {\n\nserverUrl: 'https://localhost:1234'\n\n};\n\ncomponentDidMount() {\n\nthis.setupConnection();\n\n}\n\ncomponentDidUpdate(prevProps, prevState) {\n\nif (\n\nthis.props.roomId !== prevProps.roomId ||\n\nthis.state.serverUrl !== prevState.serverUrl\n\n) {\n\nthis.destroyConnection();\n\nthis.setupConnection();\n\n}\n\n}\n\ncomponentWillUnmount() {\n\nthis.destroyConnection();\n\n}\n\n// ...\n\n}\n\n```\n\n[See more examples.](#adding-lifecycle-methods-to-a-class-component)\n\n#### Parameters {/*componentwillunmount-parameters*/}\n\n`componentWillUnmount` does not take any parameters.\n\n#### Returns {/*componentwillunmount-returns*/}\n\n`componentWillUnmount` should not return anything.\n\n#### Caveats {/*componentwillunmount-caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"188":{"pageContent":"`componentWillUnmount` does not take any parameters.\n\n#### Returns {/*componentwillunmount-returns*/}\n\n`componentWillUnmount` should not return anything.\n\n#### Caveats {/*componentwillunmount-caveats*/}\n\nWhen [Strict Mode](/reference/react/StrictMode) is on, in development React will call [`componentDidMount`,](#componentdidmount) then immediately call `componentWillUnmount`, and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn't fully \"mirror\" what `componentDidMount` does.\n\n<Note>\n\nFor many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](/reference/react/useEffect) in function components. In the rare cases where it's important for the code to run before browser paint, [`useLayoutEffect`](/reference/react/useLayoutEffect) is a closer match.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"189":{"pageContent":"[See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `forceUpdate(callback?)` {/*forceupdate*/}\n\nForces a component to re-render.\n\nUsually, this is not necessary. If your component's [`render`](#render) method only reads from [`this.props`](#props), [`this.state`](#state), or [`this.context`,](#context) it will re-render automatically when you call [`setState`](#setstate) inside your component or one of its parents. However, if your component's `render` method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That's what `forceUpdate` lets you do.\n\nTry to avoid all uses of `forceUpdate` and only read from `this.props` and `this.state` in `render`.\n\n#### Parameters {/*forceupdate-parameters*/}\n\n**optional** `callback` If specified, React will call the `callback` you've provided after the update is committed.\n\n#### Returns {/*forceupdate-returns*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"190":{"pageContent":"#### Parameters {/*forceupdate-parameters*/}\n\n**optional** `callback` If specified, React will call the `callback` you've provided after the update is committed.\n\n#### Returns {/*forceupdate-returns*/}\n\n`forceUpdate` does not return anything.\n\n#### Caveats {/*forceupdate-caveats*/}\n\nIf you call `forceUpdate`, React will re-render without calling [`shouldComponentUpdate`.](#shouldcomponentupdate)\n\n<Note>\n\nReading an external data source and forcing class components to re-render in response to its changes with `forceUpdate` has been superseded by [`useSyncExternalStore`](/reference/react/useSyncExternalStore) in function components.\n\n</Note>\n\n--\n\n### `getChildContext()` {/*getchildcontext*/}\n\n<Deprecated>\n\nThis API will be removed in a future major version of React. [Use `Context.Provider` instead.](/reference/react/createContext#provider)\n\n</Deprecated>\n\nLets you specify the values for the [legacy context](https://reactjs.org/docs/legacy-context.html) is provided by this component.\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"191":{"pageContent":"</Deprecated>\n\nLets you specify the values for the [legacy context](https://reactjs.org/docs/legacy-context.html) is provided by this component.\n\n--\n\n### `getSnapshotBeforeUpdate(prevProps, prevState)` {/*getsnapshotbeforeupdate*/}\n\nIf you implement `getSnapshotBeforeUpdate`, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to [`componentDidUpdate`.](#componentdidupdate)\n\nFor example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:\n\n```js {7-15,17}\n\nclass ScrollingList extends React.Component {\n\nconstructor(props) {\n\nsuper(props);\n\nthis.listRef = React.createRef();\n\n}\n\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n\n// Are we adding new items to the list?\n\n// Capture the scroll position so we can adjust scroll later.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"192":{"pageContent":"super(props);\n\nthis.listRef = React.createRef();\n\n}\n\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n\n// Are we adding new items to the list?\n\n// Capture the scroll position so we can adjust scroll later.\n\nif (prevProps.list.length < this.props.list.length) {\n\nconst list = this.listRef.current;\n\nreturn list.scrollHeight - list.scrollTop;\n\n}\n\nreturn null;\n\n}\n\ncomponentDidUpdate(prevProps, prevState, snapshot) {\n\n// If we have a snapshot value, we've just added new items.\n\n// Adjust scroll so these new items don't push the old ones out of view.\n\n// (snapshot here is the value returned from getSnapshotBeforeUpdate)\n\nif (snapshot !== null) {\n\nconst list = this.listRef.current;\n\nlist.scrollTop = list.scrollHeight - snapshot;\n\n}\n\n}\n\nrender() {\n\nreturn (\n\n<div ref={this.listRef}>{/* ...contents... */}</div>\n\n);\n\n}\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"193":{"pageContent":"if (snapshot !== null) {\n\nconst list = this.listRef.current;\n\nlist.scrollTop = list.scrollHeight - snapshot;\n\n}\n\n}\n\nrender() {\n\nreturn (\n\n<div ref={this.listRef}>{/* ...contents... */}</div>\n\n);\n\n}\n\n}\n\n```\n\nIn the above example, it is important to read the `scrollHeight` property directly in `getSnapshotBeforeUpdate`. It is not safe to read it in [`render`](#render), [`UNSAFE_componentWillReceiveProps`](#unsafe_componentwillreceiveprops), or [`UNSAFE_componentWillUpdate`](#unsafe_componentwillupdate) because there is a potential time gap between these methods getting called and React updating the DOM.\n\n#### Parameters {/*getsnapshotbeforeupdate-parameters*/}\n\n`prevProps`: Props before the update. Compare `prevProps` to [`this.props`](#props) to determine what changed.\n\n`prevState`: State before the update. Compare `prevState` to [`this.state`](#state) to determine what changed.\n\n#### Returns {/*getsnapshotbeforeupdate-returns*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"194":{"pageContent":"`prevState`: State before the update. Compare `prevState` to [`this.state`](#state) to determine what changed.\n\n#### Returns {/*getsnapshotbeforeupdate-returns*/}\n\nYou should return a snapshot value of any type that you'd like, or `null`. The value you returned will be passed as the third argument to [`componentDidUpdate`.](#componentdidupdate)\n\n#### Caveats {/*getsnapshotbeforeupdate-caveats*/}\n\n`getSnapshotBeforeUpdate` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n\n<Note>\n\nAt the moment, there is no equivalent to `getSnapshotBeforeUpdate` for function components. This use case is very uncommon, but if you have the need for it, for now you'll have to write a class component.\n\n</Note>\n\n--\n\n### `render()` {/*render*/}\n\nThe `render` method is the only required method in a class component.\n\nThe `render` method should specify what you want to appear on the screen, for example:\n\n```js {4-6}\n\nimport { Component } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"195":{"pageContent":"The `render` method is the only required method in a class component.\n\nThe `render` method should specify what you want to appear on the screen, for example:\n\n```js {4-6}\n\nimport { Component } from 'react';\n\nclass Greeting extends Component {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\nReact may call `render` at any moment, so you shouldn't assume that it runs at a particular time. Usually, the `render` method should return a piece of [JSX](/learn/writing-markup-with-jsx), but a few [other return types](#render-returns) (like strings) are supported. To calculate the returned JSX, the `render` method can read [`this.props`](#props), [`this.state`](#state), and [`this.context`](#context).","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"196":{"pageContent":"You should write the `render` method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn't contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like [`componentDidMount`.](#componentdidmount)\n\n#### Parameters {/*render-parameters*/}\n\n`prevProps`: Props before the update. Compare `prevProps` to [`this.props`](#props) to determine what changed.\n\n`prevState`: State before the update. Compare `prevState` to [`this.state`](#state) to determine what changed.\n\n#### Returns {/*render-returns*/}\n\n`render` can return any valid React node. This includes React elements such as `<div />`, strings, numbers, [portals](/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes.\n\n#### Caveats {/*render-caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"197":{"pageContent":"#### Caveats {/*render-caveats*/}\n\n`render` should be written as a pure function of props, state, and context. It should not have side effects.\n\n`render` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n\nWhen [Strict Mode](/reference/react/StrictMode) is on, React will call `render` twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the `render` method.\n\nThere is no one-to-one correspondence between the `render` call and the subsequent `componentDidMount` or `componentDidUpdate` call. Some of the `render` call results may be discarded by React when it's beneficial.\n\n--\n\n### `setState(nextState, callback?)` {/*setstate*/}\n\nCall `setState` to update the state of your React component.\n\n```js {8-10}\n\nclass Form extends Component {\n\nstate = {\n\nname: 'Taylor',\n\n};\n\nhandleNameChange = (e) => {\n\nconst newName = e.target.value;\n\nthis.setState({\n\nname: newName\n\n});\n\n}\n\nrender() {\n\nreturn (\n\n<>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"198":{"pageContent":"```js {8-10}\n\nclass Form extends Component {\n\nstate = {\n\nname: 'Taylor',\n\n};\n\nhandleNameChange = (e) => {\n\nconst newName = e.target.value;\n\nthis.setState({\n\nname: newName\n\n});\n\n}\n\nrender() {\n\nreturn (\n\n<>\n\n<input value={this.state.name} onChange={this.handleNameChange} />\n\n<p>Hello, {this.state.name}.\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n`setState` enqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you'll update the user interface in response to interactions.\n\n<Pitfall>\n\nCalling `setState` **does not** change the current state in the already executing code:\n\n```js {6}\n\nfunction handleClick() {\n\nconsole.log(this.state.name); // \"Taylor\"\n\nthis.setState({\n\nname: 'Robin'\n\n});\n\nconsole.log(this.state.name); // Still \"Taylor\"!\n\n}\n\n```\n\nIt only affects what `this.state` will return starting from the *next* render.\n\n</Pitfall>\n\nYou can also pass a function to `setState`. It lets you update state based on the previous state:\n\n```js {2-6}\n\nhandleIncreaseAge = () => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"199":{"pageContent":"</Pitfall>\n\nYou can also pass a function to `setState`. It lets you update state based on the previous state:\n\n```js {2-6}\n\nhandleIncreaseAge = () => {\n\nthis.setState(prevState => {\n\nreturn {\n\nage: prevState.age + 1\n\n};\n\n});\n\n}\n\n```\n\nYou don't have to do this, but it's handy if you want to update state multiple times during the same event.\n\n#### Parameters {/*setstate-parameters*/}\n\n`nextState`: Either an object or a function.\n\nIf you pass an object as `nextState`, it will be shallowly merged into `this.state`.\n\nIf you pass a function as `nextState`, it will be treated as an _updater function_. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into `this.state`. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"200":{"pageContent":"**optional** `callback`: If specified, React will call the `callback` you've provided after the update is committed.\n\n#### Returns {/*setstate-returns*/}\n\n`setState` does not return anything.\n\n#### Caveats {/*setstate-caveats*/}\n\nThink of `setState` as a *request* rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in [`flushSync`,](/reference/react-dom/flushSync) but this may hurt performance.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"201":{"pageContent":"`setState` does not update `this.state` immediately. This makes reading `this.state` right after calling `setState` a potential pitfall. Instead, use [`componentDidUpdate`](#componentdidupdate) or the setState `callback` argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to `nextState` as described above.\n\n<Note>\n\nCalling `setState` in class components is similar to calling a [`set` function](/reference/react/useState#setstate) in function components.\n\n[See how to migrate.](#migrating-a-component-with-state-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `shouldComponentUpdate(nextProps, nextState, nextContext)` {/*shouldcomponentupdate*/}\n\nIf you define `shouldComponentUpdate`, React will call it to determine whether a re-render can be skipped.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"202":{"pageContent":"--\n\n### `shouldComponentUpdate(nextProps, nextState, nextContext)` {/*shouldcomponentupdate*/}\n\nIf you define `shouldComponentUpdate`, React will call it to determine whether a re-render can be skipped.\n\nIf you are confident you want to write it by hand, you may compare `this.props` with `nextProps` and `this.state` with `nextState` and return `false` to tell React the update can be skipped.\n\n```js {6-18}\n\nclass Rectangle extends Component {\n\nstate = {\n\nisHovered: false\n\n};\n\nshouldComponentUpdate(nextProps, nextState) {\n\nif (\n\nnextProps.position.x === this.props.position.x &&\n\nnextProps.position.y === this.props.position.y &&\n\nnextProps.size.width === this.props.size.width &&\n\nnextProps.size.height === this.props.size.height &&\n\nnextState.isHovered === this.state.isHovered\n\n) {\n\n// Nothing has changed, so a re-render is unnecessary\n\nreturn false;\n\n}\n\nreturn true;\n\n}\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"203":{"pageContent":"nextProps.size.height === this.props.size.height &&\n\nnextState.isHovered === this.state.isHovered\n\n) {\n\n// Nothing has changed, so a re-render is unnecessary\n\nreturn false;\n\n}\n\nreturn true;\n\n}\n\n// ...\n\n}\n\n```\n\nReact calls `shouldComponentUpdate` before rendering when new props or state are being received. Defaults to `true`. This method is not called for the initial render or when [`forceUpdate`](#forceupdate) is used.\n\n#### Parameters {/*shouldcomponentupdate-parameters*/}\n\n`nextProps`: The next props that the component is about to render with. Compare `nextProps` to [`this.props`](#props) to determine what changed.\n\n`nextState`: The next props that the component is about to render with. Compare `nextState` to [`this.state`](#props) to determine what changed.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"204":{"pageContent":"`nextState`: The next props that the component is about to render with. Compare `nextState` to [`this.state`](#props) to determine what changed.\n\n`nextContext`: The next props that the component is about to render with. Compare `nextContext` to [`this.context`](#context) to determine what changed. Only available if you specify [`static contextType`](#static-contexttype) (modern) or [`static contextTypes`](#static-contexttypes) (legacy).\n\n#### Returns {/*shouldcomponentupdate-returns*/}\n\nReturn `true` if you want the component to re-render. That's the default behavior.\n\nReturn `false` to tell React that re-rendering can be skipped.\n\n#### Caveats {/*shouldcomponentupdate-caveats*/}\n\nThis method *only* exists as a performance optimization. If your component breaks without it, fix that first.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"205":{"pageContent":"#### Caveats {/*shouldcomponentupdate-caveats*/}\n\nThis method *only* exists as a performance optimization. If your component breaks without it, fix that first.\n\nConsider using [`PureComponent`](/reference/react/PureComponent) instead of writing `shouldComponentUpdate` by hand. `PureComponent` shallowly compares props and state, and reduces the chance that you'll skip a necessary update.\n\nWe do not recommend doing deep equality checks or using `JSON.stringify` in `shouldComponentUpdate`. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.\n\nReturning `false` does not prevent child components from re-rendering when *their* state changes.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"206":{"pageContent":"Returning `false` does not prevent child components from re-rendering when *their* state changes.\n\nReturning `false` does not *guarantee* that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.\n\n<Note>\n\nOptimizing class components with `shouldComponentUpdate` is similar to optimizing function components with [`memo`.](/reference/react/memo) Function components also offer more granular optimization with [`useMemo`.](/reference/react/useMemo)\n\n</Note>\n\n--\n\n### `UNSAFE_componentWillMount()` {/*unsafe_componentwillmount*/}\n\nIf you define `UNSAFE_componentWillMount`, React will call it immediately after the [`constructor`.](#constructor) It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n\nTo initialize state, declare [`state`](#state) as a class field or set `this.state` inside the [`constructor`.](#constructor)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"207":{"pageContent":"To initialize state, declare [`state`](#state) as a class field or set `this.state` inside the [`constructor`.](#constructor)\n\nIf you need to run a side effect or set up a subscription, move that logic to [`componentDidMount`](#componentdidmount) instead.\n\n[See examples of migrating away from unsafe lifecycles.](/blog/2018/03/27/update-on-async-rendering#examples)\n\n#### Parameters {/*unsafe_componentwillmount-parameters*/}\n\n`UNSAFE_componentWillMount` does not take any parameters.\n\n#### Returns {/*unsafe_componentwillmount-returns*/}\n\n`UNSAFE_componentWillMount` should not return anything.\n\n#### Caveats {/*unsafe_componentwillmount-caveats*/}\n\n`UNSAFE_componentWillMount` will not get called if the component implements [`static getDerivedStateFromProps`](getDerivedStateFromProps) or [`getSnapshotBeforeUpdate`.](#getsnapshotbeforeupdate)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"208":{"pageContent":"`UNSAFE_componentWillMount` will not get called if the component implements [`static getDerivedStateFromProps`](getDerivedStateFromProps) or [`getSnapshotBeforeUpdate`.](#getsnapshotbeforeupdate)\n\nDespite its naming, `UNSAFE_componentWillMount` does not guarantee that the component *will* get mounted if your app uses modern React features like [`Suspense`.](/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is \"unsafe\". Code that relies on mounting (like adding a subscription) should go into [`componentDidMount`.](#componentdidmount)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"209":{"pageContent":"`UNSAFE_componentWillMount` is the only lifecycle method that runs during [server rendering.](/reference/react-dom/server) For all practical purposes, it is identical to [`constructor`,](#constructor) so you should use the `constructor` for this type of logic instead.\n\n<Note>\n\nCalling [`setState`](#setstate) inside `UNSAFE_componentWillMount` in a class component to initialize state is equivalent to passing that state as the initial state to [`useState`](/reference/react/useState) in a function component.\n\n</Note>\n\n--\n\n### `UNSAFE_componentWillReceiveProps(nextProps, nextContext)` {/*unsafe_componentwillreceiveprops*/}\n\nIf you define `UNSAFE_componentWillReceiveProps`, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"210":{"pageContent":"If you need to **run a side effect** (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to [`componentDidUpdate`](#componentdidupdate) instead.\n\nIf you need to **avoid re-computing some data only when a prop changes,** use a [memoization helper](/blog/2018/06/07/you-probably-dont-need-derived-state#what-about-memoization) instead.\n\nIf you need to **\"reset\" some state when a prop changes,** consider either making a component [fully controlled](/blog/2018/06/07/you-probably-dont-need-derived-state#recommendation-fully-controlled-component) or [fully uncontrolled with a key](/blog/2018/06/07/you-probably-dont-need-derived-state#recommendation-fully-uncontrolled-component-with-a-key) instead.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"211":{"pageContent":"If you need to **\"adjust\" some state when a prop changes,** check whether you can compute all the necessary information from props alone during rendering. If you can't, use [`static getDerivedStateFromProps`](/reference/react/Component#static-getderivedstatefromprops) instead.\n\n[See examples of migrating away from unsafe lifecycles.](/blog/2018/03/27/update-on-async-rendering#updating-state-based-on-props)\n\n#### Parameters {/*unsafe_componentwillreceiveprops-parameters*/}\n\n`nextProps`: The next props that the component is about to receive from its parent component. Compare `nextProps` to [`this.props`](#props) to determine what changed.\n\n`nextContext`: The next props that the component is about to receive from the closest provider. Compare `nextContext` to [`this.context`](#context) to determine what changed. Only available if you specify [`static contextType`](#static-contexttype) (modern) or [`static contextTypes`](#static-contexttypes) (legacy).","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"212":{"pageContent":"#### Returns {/*unsafe_componentwillreceiveprops-returns*/}\n\n`UNSAFE_componentWillReceiveProps` should not return anything.\n\n#### Caveats {/*unsafe_componentwillreceiveprops-caveats*/}\n\n`UNSAFE_componentWillReceiveProps` will not get called if the component implements [`static getDerivedStateFromProps`](getDerivedStateFromProps) or [`getSnapshotBeforeUpdate`.](#getsnapshotbeforeupdate)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"213":{"pageContent":"Despite its naming, `UNSAFE_componentWillReceiveProps` does not guarantee that the component *will* receive those props if your app uses modern React features like [`Suspense`.](/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is \"unsafe\". Code that should run only for committed updates (like resetting a subscription) should go into [`componentDidUpdate`.](#componentdidupdate)\n\n`UNSAFE_componentWillReceiveProps` does not mean that the component has received *different* props than the last time. You need to compare `nextProps` and `this.props` yourself to check if something changed.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"214":{"pageContent":"React doesn't call `UNSAFE_componentWillReceiveProps` with initial props during mounting. It only calls this method if some of component's props are going to be updated. For example, calling [`setState`](#setstate) doesn't generally trigger `UNSAFE_componentWillReceiveProps` inside the same component.\n\n<Note>\n\nCalling [`setState`](#setstate) inside `UNSAFE_componentWillReceiveProps` in a class component to \"adjust\" state is equivalent to [calling the `set` function from `useState` during rendering](/reference/react/useState#storing-information-from-previous-renders) in a function component.\n\n</Note>\n\n--\n\n### `UNSAFE_componentWillUpdate(nextProps, nextState)` {/*unsafe_componentwillupdate*/}\n\nIf you define `UNSAFE_componentWillUpdate`, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"215":{"pageContent":"If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to [`componentDidUpdate`](#componentdidupdate) instead.\n\nIf you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in [`componentDidUpdate`](#componentdidupdate) later, read it inside [`getSnapshotBeforeUpdate`](#getsnapshotbeforeupdate) instead.\n\n[See examples of migrating away from unsafe lifecycles.](/blog/2018/03/27/update-on-async-rendering#examples)\n\n#### Parameters {/*unsafe_componentwillupdate-parameters*/}\n\n`nextProps`: The next props that the component is about to render with. Compare `nextProps` to [`this.props`](#props) to determine what changed.\n\n`nextState`: The next state that the component is about to render with. Compare `nextState` to [`this.state`](#state) to determine what changed.\n\n#### Returns {/*unsafe_componentwillupdate-returns*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"216":{"pageContent":"`nextState`: The next state that the component is about to render with. Compare `nextState` to [`this.state`](#state) to determine what changed.\n\n#### Returns {/*unsafe_componentwillupdate-returns*/}\n\n`UNSAFE_componentWillUpdate` should not return anything.\n\n#### Caveats {/*unsafe_componentwillupdate-caveats*/}\n\n`UNSAFE_componentWillUpdate` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n\n`UNSAFE_componentWillUpdate` will not get called if the component implements [`static getDerivedStateFromProps`](getDerivedStateFromProps) or [`getSnapshotBeforeUpdate`.](#getsnapshotbeforeupdate)\n\nIt's not supported to call [`setState`](#setstate) (or any method that leads to `setState` being called, like dispatching a Redux action) during `componentWillUpdate`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"217":{"pageContent":"It's not supported to call [`setState`](#setstate) (or any method that leads to `setState` being called, like dispatching a Redux action) during `componentWillUpdate`.\n\nDespite its naming, `UNSAFE_componentWillUpdate` does not guarantee that the component *will* update if your app uses modern React features like [`Suspense`.](/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is \"unsafe\". Code that should run only for committed updates (like resetting a subscription) should go into [`componentDidUpdate`.](#componentdidupdate)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"218":{"pageContent":"`UNSAFE_componentWillUpdate` does not mean that the component has received *different* props or state than the last time. You need to compare `nextProps` with `this.props` and `nextState` with `this.state` yourself to check if something changed.\n\nReact doesn't call `UNSAFE_componentWillUpdate` with initial props and state during mounting.\n\n<Note>\n\nThere is no direct equivalent to `UNSAFE_componentWillUpdate` in function components.\n\n</Note>\n\n--\n\n### `static childContextTypes` {/*static-childcontexttypes*/}\n\n<Deprecated>\n\nThis API will be removed in a future major version of React. [Use `static contextType` instead.](#static-contexttype)\n\n</Deprecated>\n\nLets you specify which [legacy context](https://reactjs.org/docs/legacy-context.html) is provided by this component.\n\n--\n\n### `static contextTypes` {/*static-contexttypes*/}\n\n<Deprecated>\n\nThis API will be removed in a future major version of React. [Use `static contextType` instead.](#static-contexttype)\n\n</Deprecated>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"219":{"pageContent":"--\n\n### `static contextTypes` {/*static-contexttypes*/}\n\n<Deprecated>\n\nThis API will be removed in a future major version of React. [Use `static contextType` instead.](#static-contexttype)\n\n</Deprecated>\n\nLets you specify which [legacy context](https://reactjs.org/docs/legacy-context.html) is consumed by this component.\n\n--\n\n### `static contextType` {/*static-contexttype*/}\n\nIf you want to read [`this.context`](#context-instance-field) from your class component, you must specify which context it needs to read. The context you specify as the `static contextType` must be a value previously created by [`createContext`.](/reference/react/createContext)\n\n```js {2}\n\nclass Button extends Component {\n\nstatic contextType = ThemeContext;\n\nrender() {\n\nconst theme = this.context;\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className}>\n\n{this.props.children}\n\n</button>\n\n);\n\n}\n\n}\n\n```\n\n<Note>\n\nReading `this.context` in class components is equivalent to [`useContext`](/reference/react/useContext) in function components.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"220":{"pageContent":"<button className={className}>\n\n{this.props.children}\n\n</button>\n\n);\n\n}\n\n}\n\n```\n\n<Note>\n\nReading `this.context` in class components is equivalent to [`useContext`](/reference/react/useContext) in function components.\n\n[See how to migrate.](#migrating-a-component-with-context-from-a-class-to-a-function)\n\n</Note>\n\n--\n\n### `static defaultProps` {/*static-defaultprops*/}\n\nYou can define `static defaultProps` to set the default props for the class. They will be used for `undefined` and missing props, but not for `null` props.\n\nFor example, here is how you define that the `color` prop should default to `'blue'`:\n\n```js {2-4}\n\nclass Button extends Component {\n\nstatic defaultProps = {\n\ncolor: 'blue'\n\n};\n\nrender() {\n\nreturn <button className={this.props.color}>click me</button>;\n\n}\n\n}\n\n```\n\nIf the `color` prop is not provided or is `undefined`, it will be set by default to `'blue'`:\n\n```js\n\n<>\n\n{/* this.props.color is \"blue\" */}\n\n<Button />\n\n{/* this.props.color is \"blue\" */}\n\n<Button color={undefined} />\n\n{/* this.props.color is null */}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"221":{"pageContent":"```js\n\n<>\n\n{/* this.props.color is \"blue\" */}\n\n<Button />\n\n{/* this.props.color is \"blue\" */}\n\n<Button color={undefined} />\n\n{/* this.props.color is null */}\n\n<Button color={null} />\n\n{/* this.props.color is \"red\" */}\n\n<Button color=\"red\" />\n\n</>\n\n```\n\n<Note>\n\nDefining `defaultProps` in class components is similar to using [default values](/learn/passing-props-to-a-component#specifying-a-default-value-for-a-prop) in function components.\n\n</Note>\n\n--\n\n### `static getDerivedStateFromError(error)` {/*static-getderivedstatefromerror*/}\n\nIf you define `static getDerivedStateFromError`, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.\n\nTypically, it is used together with [`componentDidCatch`](#componentDidCatch) which lets you send the error report to some analytics service. A component with these methods is called an *error boundary.*\n\n[See an example.](#catching-rendering-errors-with-an-error-boundary)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"222":{"pageContent":"[See an example.](#catching-rendering-errors-with-an-error-boundary)\n\n#### Parameters {/*static-getderivedstatefromerror-parameters*/}\n\n`error`: The error that was thrown. In practice, it will usually be an instance of [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) but this is not guaranteed because JavaScript allows to [`throw`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw) any value, including strings or even `null`.\n\n#### Returns {/*static-getderivedstatefromerror-returns*/}\n\n`static getDerivedStateFromError` should return the state telling the component to display the error message.\n\n#### Caveats {/*static-getderivedstatefromerror-caveats*/}\n\n`static getDerivedStateFromError` should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement [`componentDidCatch`.](#componentdidcatch)\n\n<Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"223":{"pageContent":"<Note>\n\nThere is no direct equivalent for `static getDerivedStateFromError` in function components yet. If you'd like to avoid creating class components, write a single `ErrorBoundary` component like above and use it throughout your app. Alternatively, use the [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) package which does that.\n\n</Note>\n\n--\n\n### `static getDerivedStateFromProps(props, state)` {/*static-getderivedstatefromprops*/}\n\nIf you define `static getDerivedStateFromProps`, React will call it right before calling [`render`,](#render) both on the initial mount and on subsequent updates. It should return an object to update the state, or `null` to update nothing.\n\nThis method exists for [rare use cases](/blog/2018/06/07/you-probably-dont-need-derived-state#when-to-use-derived-state) where the state depends on changes in props over time. For example, this `Form` component resets the `email` state when the `userID` prop changes:\n\n```js {7-18}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"224":{"pageContent":"```js {7-18}\n\nclass Form extends Component {\n\nstate = {\n\nemail: this.props.defaultEmail,\n\nprevUserID: this.props.userID\n\n};\n\nstatic getDerivedStateFromProps(props, state) {\n\n// Any time the current user changes,\n\n// Reset any parts of state that are tied to that user.\n\n// In this simple example, that's just the email.\n\nif (props.userID !== state.prevUserID) {\n\nreturn {\n\nprevUserID: props.userID,\n\nemail: props.defaultEmail\n\n};\n\n}\n\nreturn null;\n\n}\n\n// ...\n\n}\n\n```\n\nNote that this pattern requires you to keep a previous value of the prop (like `userID`) in state (like `prevUserID`).\n\n<Pitfall>\n\nDeriving state leads to verbose code and makes your components difficult to think about. [Make sure you're familiar with simpler alternatives:](/blog/2018/06/07/you-probably-dont-need-derived-state.html)\n\nIf you need to **perform a side effect** (for example, data fetching or an animation) in response to a change in props, use [`componentDidUpdate`](#componentdidupdate) method instead.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"225":{"pageContent":"If you need to **perform a side effect** (for example, data fetching or an animation) in response to a change in props, use [`componentDidUpdate`](#componentdidupdate) method instead.\n\nIf you want to **re-compute some data only when a prop changes,** [use a memoization helper instead.](/blog/2018/06/07/you-probably-dont-need-derived-state#what-about-memoization)\n\nIf you want to **\"reset\" some state when a prop changes,** consider either making a component [fully controlled](/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component) or [fully uncontrolled with a key](/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key) instead.\n\n</Pitfall>\n\n#### Parameters {/*static-getderivedstatefromprops-parameters*/}\n\n`props`: The next props that the component is about to render with.\n\n`state`: The next state that the component is about to render with.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"226":{"pageContent":"#### Parameters {/*static-getderivedstatefromprops-parameters*/}\n\n`props`: The next props that the component is about to render with.\n\n`state`: The next state that the component is about to render with.\n\n#### Returns {/*static-getderivedstatefromprops-returns*/}\n\n`static getDerivedStateFromProps` return an object to update the state, or `null` to update nothing.\n\n#### Caveats {/*static-getderivedstatefromprops-caveats*/}\n\nThis method is fired on *every* render, regardless of the cause. This is different from [`UNSAFE_componentWillReceiveProps`](#unsafe_cmoponentwillreceiveprops), which only fires when the parent causes a re-render and not as a result of a local `setState`.\n\nThis method doesn't have access to the component instance. If you'd like, you can reuse some code between `static getDerivedStateFromProps` and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\n<Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"227":{"pageContent":"<Note>\n\nImplementing `static getDerivedStateFromProps` in a class component is equivalent to [calling the `set` function from `useState` during rendering](/reference/react/useState#storing-information-from-previous-renders) in a function component.\n\n</Note>\n\n--\n\n## Usage {/*usage*/}\n\n### Defining a class component {/*defining-a-class-component*/}\n\nTo define a React component as a class, extend the built-in `Component` class and define a [`render` method:](#render)\n\n```js\n\nimport { Component } from 'react';\n\nclass Greeting extends Component {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\n```\n\nReact will call your [`render`](#render) method whenever it needs to figure out what to display on the screen. Usually, you will return some [JSX](/learn/writing-markup-with-jsx) from it. Your `render` method should be a [pure function:](https://en.wikipedia.org/wiki/Pure_function) it should only calculate the JSX.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"228":{"pageContent":"Similarly to [function components,](/learn/your-first-component#defining-a-component) a class component can [receive information by props](/learn/your-first-component#defining-a-component) from its parent component. However, the syntax for reading props is different. For example, if the parent component renders `<Greeting name=\"Taylor\" />`, then you can read the `name` prop from [`this.props`](#props), like `this.props.name`:\n\n<Sandpack>\n\n```js\n\nimport { Component } from 'react';\n\nclass Greeting extends Component {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<Greeting name=\"Sara\" />\n\n<Greeting name=\"Cahal\" />\n\n<Greeting name=\"Edite\" />\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\nNote that Hooks (functions starting with `use`, like [`useState`](/reference/react/useState)) are not supported inside class components.\n\n<Pitfall>\n\nWe recommend to define components as functions instead of classes. [See how to migrate.](#migrating-a-simple-component-from-a-class-to-a-function)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"229":{"pageContent":"<Pitfall>\n\nWe recommend to define components as functions instead of classes. [See how to migrate.](#migrating-a-simple-component-from-a-class-to-a-function)\n\n</Pitfall>\n\n--\n\n### Adding state to a class component {/*adding-state-to-a-class-component*/}\n\nTo add [state](/learn/state-a-components-memory) to a class, assign an object to a property called [`state`](#state). To update state, call [`this.setState`](#setstate).\n\n<Sandpack>\n\n```js\n\nimport { Component } from 'react';\n\nexport default class Counter extends Component {\n\nstate = {\n\nname: 'Taylor',\n\nage: 42,\n\n};\n\nhandleNameChange = (e) => {\n\nthis.setState({\n\nname: e.target.value\n\n});\n\n}\n\nhandleAgeChange = () => {\n\nthis.setState({\n\nage: this.state.age + 1\n\n});\n\n};\n\nrender() {\n\nreturn (\n\n<>\n\n<input\n\nvalue={this.state.name}\n\nonChange={this.handleNameChange}\n\n/>\n\n<button onClick={this.handleAgeChange}>\n\nIncrement age\n\n</button>\n\n<p>Hello, {this.state.name}. You are {this.state.age}.</p>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"230":{"pageContent":"Increment age\n\n</button>\n\n<p>Hello, {this.state.name}. You are {this.state.age}.</p>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\nWe recommend to define components as functions instead of classes. [See how to migrate.](#migrating-a-component-with-state-from-a-class-to-a-function)\n\n</Pitfall>\n\n--\n\n### Adding lifecycle methods to a class component {/*adding-lifecycle-methods-to-a-class-component*/}\n\nThere are a few special methods you can define on your class.\n\nIf you define the [`componentDidMount`](#componentdidmount) method, React will call it when your component is first added *(mounted)* to the screen. React will call [`componentDidUpdate`](#componentdidupdate) after your component re-renders due to changed props or state. React will call [`componentWillUnmount`](#componentwillunmount) after your component has been removed *(unmounted)* from the screen.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"231":{"pageContent":"If you implement `componentDidMount`, you usually need to implement all three lifecycles to avoid bugs. For example, if `componentDidMount` reads some state or props, you also have to implement `componentDidUpdate` to handle their changes, and `componentWillUnmount` to clean up whatever `componentDidMount` was doing.\n\nFor example, this `ChatRoom` component keeps a chat connection synchronized with props and state:\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport ChatRoom from './ChatRoom.js';\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"232":{"pageContent":"<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js ChatRoom.js active\n\nimport { Component } from 'react';\n\nimport { createConnection } from './chat.js';\n\nexport default class ChatRoom extends Component {\n\nstate = {\n\nserverUrl: 'https://localhost:1234'\n\n};\n\ncomponentDidMount() {\n\nthis.setupConnection();\n\n}\n\ncomponentDidUpdate(prevProps, prevState) {\n\nif (\n\nthis.props.roomId !== prevProps.roomId ||\n\nthis.state.serverUrl !== prevState.serverUrl\n\n) {\n\nthis.destroyConnection();\n\nthis.setupConnection();\n\n}\n\n}\n\ncomponentWillUnmount() {\n\nthis.destroyConnection();\n\n}\n\nsetupConnection() {\n\nthis.connection = createConnection(\n\nthis.state.serverUrl,\n\nthis.props.roomId\n\n);\n\nthis.connection.connect();\n\n}\n\ndestroyConnection() {\n\nthis.connection.disconnect();\n\nthis.connection = null;\n\n}\n\nrender() {\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={this.state.serverUrl}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"233":{"pageContent":"this.props.roomId\n\n);\n\nthis.connection.connect();\n\n}\n\ndestroyConnection() {\n\nthis.connection.disconnect();\n\nthis.connection = null;\n\n}\n\nrender() {\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={this.state.serverUrl}\n\nonChange={e => {\n\nthis.setState({\n\nserverUrl: e.target.value\n\n});\n\n}}\n\n/>\n\n</label>\n\n<h1>Welcome to the {this.props.roomId} room!</h1>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"234":{"pageContent":"},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nNote that in development when [Strict Mode](/reference/react/StrictMode) is on, React will call `componentDidMount`, immediately call `componentWillUnmount`, and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn't fully \"mirror\" what `componentDidMount` does.\n\n<Pitfall>\n\nWe recommend to define components as functions instead of classes. [See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n</Pitfall>\n\n--\n\n### Catching rendering errors with an error boundary {/*catching-rendering-errors-with-an-error-boundary*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"235":{"pageContent":"</Pitfall>\n\n--\n\n### Catching rendering errors with an error boundary {/*catching-rendering-errors-with-an-error-boundary*/}\n\nBy default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an *error boundary*. An error boundary is a special component that lets you display some fallback UI instead of the part that crashed--for example, an error message.\n\nTo implement an error boundary component, you need to provide [`static getDerivedStateFromError`](#static-getderivedstatefromerror) which lets you update state in response to an error and display an error message to the user. You can also optionally implement [`componentDidcatch`](#componentdidcatch) to add some extra logic, for example, to log the error to an analytics service.\n\n```js {7-10,12-19}\n\nclass ErrorBoundary extends React.Component {\n\nconstructor(props) {\n\nsuper(props);\n\nthis.state = { hasError: false };\n\n}\n\nstatic getDerivedStateFromError(error) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"236":{"pageContent":"```js {7-10,12-19}\n\nclass ErrorBoundary extends React.Component {\n\nconstructor(props) {\n\nsuper(props);\n\nthis.state = { hasError: false };\n\n}\n\nstatic getDerivedStateFromError(error) {\n\n// Update state so the next render will show the fallback UI.\n\nreturn { hasError: true };\n\n}\n\ncomponentDidCatch(error, info) {\n\n// Example \"componentStack\":\n\n//   in ComponentThatThrows (created by App)\n\n//   in ErrorBoundary (created by App)\n\n//   in div (created by App)\n\n//   in App\n\nlogErrorToMyService(error, info.componentStack);\n\n}\n\nrender() {\n\nif (this.state.hasError) {\n\n// You can render any custom fallback UI\n\nreturn this.props.fallback;\n\n}\n\nreturn this.props.children;\n\n}\n\n}\n\n```\n\nThen you can wrap a part of your component tree with it:\n\n```js {1,3}\n\n<ErrorBoundary fallback={<p>Something went wrong</p>}>\n\n<Profile />\n\n</ErrorBoundary>\n\n```\n\nIf `Profile` or its child component throws an error, `ErrorBoundary` will \"catch\" that error, display a fallback UI with the error message you've provided, and send a production error report to your error reporting service.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"237":{"pageContent":"You don't need to wrap every component into a separate error boundary. When you think about the [granularity of error boundaries,](https://aweary.dev/fault-tolerance-react/) consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an error boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn't make sense to place a boundary around every avatar.\n\n<Note>\n\nThere is currently no way to write an error boundary as a function component. However, you don't have to write the error boundary class yourself. For example, you can use [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) instead.\n\n</Note>\n\n--\n\n## Alternatives {/*alternatives*/}\n\n### Migrating a simple component from a class to a function {/*migrating-a-simple-component-from-a-class-to-a-function*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"238":{"pageContent":"</Note>\n\n--\n\n## Alternatives {/*alternatives*/}\n\n### Migrating a simple component from a class to a function {/*migrating-a-simple-component-from-a-class-to-a-function*/}\n\nTypically, you will [define components as functions](/learn/your-first-component#defining-a-component) instead.\n\nFor example, suppose you're converting this `Greeting` class component to a function:\n\n<Sandpack>\n\n```js\n\nimport { Component } from 'react';\n\nclass Greeting extends Component {\n\nrender() {\n\nreturn <h1>Hello, {this.props.name}!</h1>;\n\n}\n\n}\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<Greeting name=\"Sara\" />\n\n<Greeting name=\"Cahal\" />\n\n<Greeting name=\"Edite\" />\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\nDefine a function called `Greeting`. This is where you will move the body of your `render` function.\n\n```js\n\nfunction Greeting() {\n\n// ... move the code from the render method here ...\n\n}\n\n```\n\nInstead of `this.props.name`, define the `name` prop [using the destructuring syntax](/learn/passing-props-to-a-component) and read it directly:\n\n```js\n\nfunction Greeting({ name }) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"239":{"pageContent":"}\n\n```\n\nInstead of `this.props.name`, define the `name` prop [using the destructuring syntax](/learn/passing-props-to-a-component) and read it directly:\n\n```js\n\nfunction Greeting({ name }) {\n\nreturn <h1>Hello, {name}!</h1>;\n\n}\n\n```\n\nHere is a complete example:\n\n<Sandpack>\n\n```js\n\nfunction Greeting({ name }) {\n\nreturn <h1>Hello, {name}!</h1>;\n\n}\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<Greeting name=\"Sara\" />\n\n<Greeting name=\"Cahal\" />\n\n<Greeting name=\"Edite\" />\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Migrating a component with state from a class to a function {/*migrating-a-component-with-state-from-a-class-to-a-function*/}\n\nSuppose you're converting this `Counter` class component to a function:\n\n<Sandpack>\n\n```js\n\nimport { Component } from 'react';\n\nexport default class Counter extends Component {\n\nstate = {\n\nname: 'Taylor',\n\nage: 42,\n\n};\n\nhandleNameChange = (e) => {\n\nthis.setState({\n\nname: e.target.value\n\n});\n\n}\n\nhandleAgeChange = (e) => {\n\nthis.setState({\n\nage: this.state.age + 1\n\n});\n\n};\n\nrender() {\n\nreturn (\n\n<>\n\n<input\n\nvalue={this.state.name}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"240":{"pageContent":"age: 42,\n\n};\n\nhandleNameChange = (e) => {\n\nthis.setState({\n\nname: e.target.value\n\n});\n\n}\n\nhandleAgeChange = (e) => {\n\nthis.setState({\n\nage: this.state.age + 1\n\n});\n\n};\n\nrender() {\n\nreturn (\n\n<>\n\n<input\n\nvalue={this.state.name}\n\nonChange={this.handleNameChange}\n\n/>\n\n<button onClick={this.handleAgeChange}>\n\nIncrement age\n\n</button>\n\n<p>Hello, {this.state.name}. You are {this.state.age}.</p>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\nStart by declaring a function with the necessary [state variables:](/reference/react/useState#adding-state-to-a-component)\n\n```js {4-5}\n\nimport { useState } from 'react';\n\nfunction Counter() {\n\nconst [name, setName] = useState('Taylor');\n\nconst [age, setAge] = useState(42);\n\n// ...\n\n```\n\nNext, convert the event handlers:\n\n```js {5-7,9-11}\n\nfunction Counter() {\n\nconst [name, setName] = useState('Taylor');\n\nconst [age, setAge] = useState(42);\n\nfunction handleNameChange(e) {\n\nsetName(e.target.value);\n\n}\n\nfunction handleAgeChange() {\n\nsetAge(age + 1);\n\n}\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"241":{"pageContent":"const [name, setName] = useState('Taylor');\n\nconst [age, setAge] = useState(42);\n\nfunction handleNameChange(e) {\n\nsetName(e.target.value);\n\n}\n\nfunction handleAgeChange() {\n\nsetAge(age + 1);\n\n}\n\n// ...\n\n```\n\nFinally, replace all references starting with `this` with the variables and functions you defined in your component. For example, replace `this.state.age` with `age`, and replace `this.handleNameChange` with `handleNameChange`.\n\nHere is a fully converted component:\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n\nconst [name, setName] = useState('Taylor');\n\nconst [age, setAge] = useState(42);\n\nfunction handleNameChange(e) {\n\nsetName(e.target.value);\n\n}\n\nfunction handleAgeChange() {\n\nsetAge(age + 1);\n\n}\n\nreturn (\n\n<>\n\n<input\n\nvalue={name}\n\nonChange={handleNameChange}\n\n/>\n\n<button onClick={handleAgeChange}>\n\nIncrement age\n\n</button>\n\n<p>Hello, {name}. You are {age}.</p>\n\n</>\n\n)\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"242":{"pageContent":"onChange={handleNameChange}\n\n/>\n\n<button onClick={handleAgeChange}>\n\nIncrement age\n\n</button>\n\n<p>Hello, {name}. You are {age}.</p>\n\n</>\n\n)\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\n--\n\n### Migrating a component with lifecycle methods from a class to a function {/*migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function*/}\n\nSuppose you're converting this `ChatRoom` class component with lifecycle methods to a function:\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport ChatRoom from './ChatRoom.js';\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"243":{"pageContent":"<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js ChatRoom.js active\n\nimport { Component } from 'react';\n\nimport { createConnection } from './chat.js';\n\nexport default class ChatRoom extends Component {\n\nstate = {\n\nserverUrl: 'https://localhost:1234'\n\n};\n\ncomponentDidMount() {\n\nthis.setupConnection();\n\n}\n\ncomponentDidUpdate(prevProps, prevState) {\n\nif (\n\nthis.props.roomId !== prevProps.roomId ||\n\nthis.state.serverUrl !== prevState.serverUrl\n\n) {\n\nthis.destroyConnection();\n\nthis.setupConnection();\n\n}\n\n}\n\ncomponentWillUnmount() {\n\nthis.destroyConnection();\n\n}\n\nsetupConnection() {\n\nthis.connection = createConnection(\n\nthis.state.serverUrl,\n\nthis.props.roomId\n\n);\n\nthis.connection.connect();\n\n}\n\ndestroyConnection() {\n\nthis.connection.disconnect();\n\nthis.connection = null;\n\n}\n\nrender() {\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={this.state.serverUrl}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"244":{"pageContent":"this.props.roomId\n\n);\n\nthis.connection.connect();\n\n}\n\ndestroyConnection() {\n\nthis.connection.disconnect();\n\nthis.connection = null;\n\n}\n\nrender() {\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={this.state.serverUrl}\n\nonChange={e => {\n\nthis.setState({\n\nserverUrl: e.target.value\n\n});\n\n}}\n\n/>\n\n</label>\n\n<h1>Welcome to the {this.props.roomId} room!</h1>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"245":{"pageContent":"},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nFirst, verify that your [`componentWillUnmount`](#componentwillunmount) does the opposite of [`componentDidMount`.](#componentdidmount) In the above example, that's true: it disconnects the connection that `componentDidMount` sets up. If such logic is missing, add it first.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"246":{"pageContent":"Next, verify that your [`componentDidUpdate`](#componentdidupdate) method handles changes to any props and state you're using in `componentDidMount`. In the above example, `componentDidMount` calls `setupConnection` which reads `this.state.serverUrl` and `this.props.roomId`. This is why `componentDidUpdate` checks whether `this.state.serverUrl` and `this.props.roomId` have changed, and resets the connection if they did. If your `componentDidUpdate` logic is missing or doesn't handle changes to all relevant props and state, fix that first.\n\nIn the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system, [describe this logic as a single Effect:](/reference/react/useEffect#connecting-to-an-external-system)\n\n```js {6-12}\n\nimport { useState, useEffect } from 'react';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"247":{"pageContent":"```js {6-12}\n\nimport { useState, useEffect } from 'react';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\n// ...\n\n}\n\n```\n\nThis [`useEffect`](/api/useEffect) call is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things, [split them into multiple independent Effects.](/learn/removing-effect-dependencies#is-your-effect-doing-several-unrelated-things) Here is a complete example you can play with:\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport ChatRoom from './ChatRoom.js';\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"248":{"pageContent":"const [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js ChatRoom.js active\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nexport default function ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [roomId, serverUrl]);\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}\n\nonChange={e => setServerUrl(e.target.value)}\n\n/>\n\n</label>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"249":{"pageContent":"connection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [roomId, serverUrl]);\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}\n\nonChange={e => setServerUrl(e.target.value)}\n\n/>\n\n</label>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\n<Note>\n\nIf your component does not synchronize with any external systems, [you might not need an Effect.](/learn/you-might-not-need-an-effect)\n\n</Note>\n\n--\n\n### Migrating a component with context from a class to a function {/*migrating-a-component-with-context-from-a-class-to-a-function*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"250":{"pageContent":"</Note>\n\n--\n\n### Migrating a component with context from a class to a function {/*migrating-a-component-with-context-from-a-class-to-a-function*/}\n\nIn this example, the `Panel` and `Button` class components read [context](/learn/passing-data-deeply-with-context) from [`this.context`:](#context)\n\n<Sandpack>\n\n```js\n\nimport { createContext, Component } from 'react';\n\nconst ThemeContext = createContext(null);\n\nclass Panel extends Component {\n\nstatic contextType = ThemeContext;\n\nrender() {\n\nconst theme = this.context;\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n<h1>{this.props.title}</h1>\n\n{this.props.children}\n\n</section>\n\n);\n\n}\n\n}\n\nclass Button extends Component {\n\nstatic contextType = ThemeContext;\n\nrender() {\n\nconst theme = this.context;\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className}>\n\n{this.props.children}\n\n</button>\n\n);\n\n}\n\n}\n\nfunction Form() {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n</Panel>\n\n);\n\n}\n\nexport default function MyApp() {\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"251":{"pageContent":"{this.props.children}\n\n</button>\n\n);\n\n}\n\n}\n\nfunction Form() {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n</Panel>\n\n);\n\n}\n\nexport default function MyApp() {\n\nreturn (\n\n<ThemeContext.Provider value=\"dark\">\n\n<Form />\n\n</ThemeContext.Provider>\n\n)\n\n}\n\n```\n\n```css\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\nWhen you convert them to function components, replace `this.context` with [`useContext`](/reference/react/useContext) calls:\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"252":{"pageContent":"const ThemeContext = createContext(null);\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n<h1>{title}</h1>\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className}>\n\n{children}\n\n</button>\n\n);\n\n}\n\nfunction Form() {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n</Panel>\n\n);\n\n}\n\nexport default function MyApp() {\n\nreturn (\n\n<ThemeContext.Provider value=\"dark\">\n\n<Form />\n\n</ThemeContext.Provider>\n\n)\n\n}\n\n```\n\n```css\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"253":{"pageContent":"}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Component.md"}},"254":{"pageContent":"--\n\ntitle: lazy\n\n--\n\n<Intro>\n\n`lazy` lets you defer loading component's code until it is rendered for the first time.\n\n```js\n\nconst SomeComponent = lazy(load)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `lazy(load)` {/*lazy*/}\n\nCall `lazy` outside your components to declare a lazy-loaded React component:\n\n```js\n\nimport { lazy } from 'react';\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"255":{"pageContent":"```js\n\nimport { lazy } from 'react';\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`load`: A function that returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or some other *thenable* (a Promise-like object with a `then` method). React will not call `load` until the first time you attempt to render the returned component. After React first calls `load`, it will wait for it to resolve, and then render the resolved value as a React component. Both the returned Promise and the Promise's resolved value will be cached, so React will not call `load` more than once. If the Promise rejects, React will `throw` the rejection reason to let the closest Error Boundary above handle it.\n\n#### Returns {/*returns*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"256":{"pageContent":"#### Returns {/*returns*/}\n\n`lazy` returns a React component that you can render in your tree. While the code for the lazy component is still loading, attempting to render it will *suspend.* Use [`<Suspense>`](/reference/react/Suspense) to display a loading indicator while it's loading.\n\n--\n\n### `load` function {/*load*/}\n\n#### Parameters {/*load-parameters*/}\n\n`load` receives no parameters.\n\n#### Returns {/*load-returns*/}\n\nYou need to return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or some other *thenable* (a Promise-like object with a `then` method). It needs to eventually resolve to a valid React component type, such as a function, [`memo`](/reference/react/memo), or a [`forwardRef`](/reference/react/forwardRef) component.\n\n--\n\n## Usage {/*usage*/}\n\n### Lazy-loading components with Suspense {/*suspense-for-code-splitting*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"257":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Lazy-loading components with Suspense {/*suspense-for-code-splitting*/}\n\nUsually, you import components with the static [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) declaration:\n\n```js\n\nimport MarkdownPreview from './MarkdownPreview.js';\n\n```\n\nTo defer loading this component's code until it's rendered for the first time, replace this import with:\n\n```js\n\nimport { lazy } from 'react';\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\n```\n\nThis code relies on [dynamic `import()`,](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) which might require support from your bundler or framework.\n\nNow that your component's code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a [`<Suspense>`](/reference/react/Suspense) boundary:\n\n```js {1,4}\n\n<Suspense fallback={<Loading />}>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"258":{"pageContent":"```js {1,4}\n\n<Suspense fallback={<Loading />}>\n\n<h2>Preview</h2>\n\n<MarkdownPreview />\n\n</Suspense>\n\n```\n\nIn this example, the code for `MarkdownPreview` won't be loaded until you attempt to render it. If `MarkdownPreview` hasn't loaded yet, `Loading` will be shown in its place. Try ticking the checkbox:\n\n<Sandpack>\n\n```js App.js\n\nimport { useState, Suspense, lazy } from 'react';\n\nimport Loading from './Loading.js';\n\nconst MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));\n\nexport default function MarkdownEditor() {\n\nconst [showPreview, setShowPreview] = useState(false);\n\nconst [markdown, setMarkdown] = useState('Hello, **world**!');\n\nreturn (\n\n<>\n\n<textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />\n\n<label>\n\n<input type=\"checkbox\" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />\n\nShow preview\n\n</label>\n\n<hr />\n\n{showPreview && (\n\n<Suspense fallback={<Loading />}>\n\n<h2>Preview</h2>\n\n<MarkdownPreview markdown={markdown} />\n\n</Suspense>\n\n)}\n\n</>\n\n);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"259":{"pageContent":"Show preview\n\n</label>\n\n<hr />\n\n{showPreview && (\n\n<Suspense fallback={<Loading />}>\n\n<h2>Preview</h2>\n\n<MarkdownPreview markdown={markdown} />\n\n</Suspense>\n\n)}\n\n</>\n\n);\n\n}\n\n// Add a fixed delay so you can see the loading state\n\nfunction delayForDemo(promise) {\n\nreturn new Promise(resolve => {\n\nsetTimeout(resolve, 2000);\n\n}).then(() => promise);\n\n}\n\n```\n\n```js Loading.js\n\nexport default function Loading() {\n\nreturn <p><i>Loading...</i></p>;\n\n}\n\n```\n\n```js MarkdownPreview.js\n\nimport { Remarkable } from 'remarkable';\n\nconst md = new Remarkable();\n\nexport default function MarkdownPreview({ markdown }) {\n\nreturn (\n\n<div\n\nclassName=\"content\"\n\ndangerouslySetInnerHTML={{__html: md.render(markdown)}}\n\n/>\n\n);\n\n}\n\n```\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"immer\": \"1.7.3\",\n\n\"react\": \"latest\",\n\n\"react-dom\": \"latest\",\n\n\"react-scripts\": \"latest\",\n\n\"remarkable\": \"2.0.1\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\n}\n\ninput, textarea {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"260":{"pageContent":"},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\n}\n\ninput, textarea {\n\nmargin-bottom: 10px;\n\n}\n\nbody {\n\nmin-height: 200px;\n\n}\n\n```\n\n</Sandpack>\n\nThis demo loads with an artificial delay. The next time you untick and tick the checkbox, `Preview` will be cached, so there will be no loading state displayed. To see the loading state again, click \"Reset\" on the sandbox.\n\n[Learn more about managing loading states with Suspense.](/reference/react/Suspense)\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### My `lazy` component's state gets reset unexpectedly {/*my-lazy-components-state-gets-reset-unexpectedly*/}\n\nDo not declare `lazy` components *inside* other components:\n\n```js {4-5}\n\nimport { lazy } from 'react';\n\nfunction Editor() {\n\n// ðŸ”´ Bad: This will cause all state to be reset on re-renders\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"261":{"pageContent":"```js {4-5}\n\nimport { lazy } from 'react';\n\nfunction Editor() {\n\n// ðŸ”´ Bad: This will cause all state to be reset on re-renders\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\n// ...\n\n}\n\n```\n\nInstead, always declare them at the top level of your module:\n\n```js {3-4}\n\nimport { lazy } from 'react';\n\n// âœ… Good: Declare lazy components outside of your components\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\nfunction Editor() {\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/lazy.md"}},"262":{"pageContent":"--\n\ntitle: useId\n\n--\n\n<Intro>\n\n`useId` is a React Hook for generating unique IDs that can be passed to accessibility attributes.\n\n```js\n\nconst id = useId()\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useId()` {/*useid*/}\n\nCall `useId` at the top level of your component to generate a unique ID:\n\n```js\n\nimport { useId } from 'react';\n\nfunction PasswordField() {\n\nconst passwordHintId = useId();\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`useId` does not take any parameters.\n\n#### Returns {/*returns*/}\n\n`useId` returns a unique ID string associated with this particular `useId` call in this particular component.\n\n#### Caveats {/*caveats*/}\n\n`useId` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"263":{"pageContent":"`useId` **should not be used to generate keys** in a list. [Keys should be generated from your data.](/learn/rendering-lists#where-to-get-your-key)\n\n--\n\n## Usage {/*usage*/}\n\n<Pitfall>\n\n*Do not call `useId` to generate keys in a list.** [Keys should be generated from your data.](/learn/rendering-lists#where-to-get-your-key)\n\n</Pitfall>\n\n### Generating unique IDs for accessibility attributes {/*generating-unique-ids-for-accessibility-attributes*/}\n\nCall `useId` at the top level of your component to generate a unique ID:\n\n```js [[1, 4, \"passwordHintId\"]]\n\nimport { useId } from 'react';\n\nfunction PasswordField() {\n\nconst passwordHintId = useId();\n\n// ...\n\n```\n\nYou can then pass the <CodeStep step={1}>generated ID</CodeStep> to different attributes:\n\n```js [[1, 2, \"passwordHintId\"], [1, 3, \"passwordHintId\"]]\n\n<>\n\n<input type=\"password\" aria-describedby={passwordHintId} />\n\n<p id={passwordHintId}>\n\n</>\n\n```\n\n*Let's walk through an example to see when this is useful.**","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"264":{"pageContent":"<>\n\n<input type=\"password\" aria-describedby={passwordHintId} />\n\n<p id={passwordHintId}>\n\n</>\n\n```\n\n*Let's walk through an example to see when this is useful.**\n\n[HTML accessibility attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) like [`aria-describedby`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-describedby) let you specify that two tags are related to each other. For example, you can specify that a certain element (like an input) is described by another element (like a paragraph).\n\nIn regular HTML, you would write it like this:\n\n```html {5,8}\n\n<label>\n\nPassword:\n\n<input\n\ntype=\"password\"\n\naria-describedby=\"password-hint\"\n\n/>\n\n</label>\n\n<p id=\"password-hint\">\n\nThe password should contain at least 18 characters\n\n</p>\n\n```\n\nHowever, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page--but IDs have to be unique! Instead of hardcoding an ID, you can generate a unique ID with `useId`:\n\n```js {4,11,14}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"265":{"pageContent":"```js {4,11,14}\n\nimport { useId } from 'react';\n\nfunction PasswordField() {\n\nconst passwordHintId = useId();\n\nreturn (\n\n<>\n\n<label>\n\nPassword:\n\n<input\n\ntype=\"password\"\n\naria-describedby={passwordHintId}\n\n/>\n\n</label>\n\n<p id={passwordHintId}>\n\nThe password should contain at least 18 characters\n\n</p>\n\n</>\n\n);\n\n}\n\n```\n\nNow, even if `PasswordField` appears multiple times on the screen, the generated IDs won't clash.\n\n<Sandpack>\n\n```js\n\nimport { useId } from 'react';\n\nfunction PasswordField() {\n\nconst passwordHintId = useId();\n\nreturn (\n\n<>\n\n<label>\n\nPassword:\n\n<input\n\ntype=\"password\"\n\naria-describedby={passwordHintId}\n\n/>\n\n</label>\n\n<p id={passwordHintId}>\n\nThe password should contain at least 18 characters\n\n</p>\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<h2>Choose password</h2>\n\n<PasswordField />\n\n<h2>Confirm password</h2>\n\n<PasswordField />\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\ninput { margin: 5px; }\n\n```\n\n</Sandpack>\n\n[Watch this video](https://www.youtube.com/watch?v=0dNzNcuEuOo) to see the difference in the user experience with assistive technologies.\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"266":{"pageContent":"</>\n\n);\n\n}\n\n```\n\n```css\n\ninput { margin: 5px; }\n\n```\n\n</Sandpack>\n\n[Watch this video](https://www.youtube.com/watch?v=0dNzNcuEuOo) to see the difference in the user experience with assistive technologies.\n\n<Pitfall>\n\n*`useId` requires an identical component tree on the server and the client** when you use [server rendering](/reference/react-dom/server). If the trees you render on the server and the client don't match exactly, the generated IDs won't match.\n\n</Pitfall>\n\n<DeepDive>\n\n#### Why is useId better than an incrementing counter? {/*why-is-useid-better-than-an-incrementing-counter*/}\n\nYou might be wondering why `useId` is better than incrementing a global variable like `nextId++`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"267":{"pageContent":"You might be wondering why `useId` is better than incrementing a global variable like `nextId++`.\n\nThe primary benefit of `useId` is that React ensures that it works with [server rendering.](/reference/react-dom/server) During server rendering, your components generate HTML output. Later, on the client, [hydration](/reference/react-dom/client/hydrateRoot) attaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML.\n\nThis is very difficult to guarantee with an incrementing counter because the order in which the client components are hydrated may not match the order in which the server HTML was emitted. By calling `useId`, you ensure that hydration will work, and the output will match between the server and the client.\n\nInside React, `useId` is generated from the \"parent path\" of the calling component. This is why, if the client and the server tree are the same, the \"parent path\" will match up regardless of rendering order.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"268":{"pageContent":"</DeepDive>\n\n--\n\n### Generating IDs for several related elements {/*generating-ids-for-several-related-elements*/}\n\nIf you need to give IDs to multiple related elements, you can call `useId` to generate a shared prefix for them:\n\n<Sandpack>\n\n```js\n\nimport { useId } from 'react';\n\nexport default function Form() {\n\nconst id = useId();\n\nreturn (\n\n<form>\n\n<label htmlFor={id + '-firstName'}>First Name:</label>\n\n<input id={id + '-firstName'} type=\"text\" />\n\n<hr />\n\n<label htmlFor={id + '-lastName'}>Last Name:</label>\n\n<input id={id + '-lastName'} type=\"text\" />\n\n</form>\n\n);\n\n}\n\n```\n\n```css\n\ninput { margin: 5px; }\n\n```\n\n</Sandpack>\n\nThis lets you avoid calling `useId` for every single element that needs a unique ID.\n\n--\n\n### Specifying a shared prefix for all generated IDs {/*specifying-a-shared-prefix-for-all-generated-ids*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"269":{"pageContent":"This lets you avoid calling `useId` for every single element that needs a unique ID.\n\n--\n\n### Specifying a shared prefix for all generated IDs {/*specifying-a-shared-prefix-for-all-generated-ids*/}\n\nIf you render multiple independent React applications on a single page, you may pass `identifierPrefix` as an option to your [`createRoot`](/reference/react-dom/client/createRoot#parameters) or [`hydrateRoot`](/reference/react-dom/client/hydrateRoot) calls. This ensures that the IDs generated by the two different apps never clash because every identifier generated with `useId` will start with the distinct prefix you've specified.\n\n<Sandpack>\n\n```html index.html\n\n<!DOCTYPE html>\n\n<html>\n\n<head><title>My app</title></head>\n\n<body>\n\n<div id=\"root1\"></div>\n\n<div id=\"root2\"></div>\n\n</body>\n\n</html>\n\n```\n\n```js\n\nimport { useId } from 'react';\n\nfunction PasswordField() {\n\nconst passwordHintId = useId();\n\nconsole.log('Generated identifier:', passwordHintId)\n\nreturn (\n\n<>\n\n<label>\n\nPassword:\n\n<input\n\ntype=\"password\"","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"270":{"pageContent":"```\n\n```js\n\nimport { useId } from 'react';\n\nfunction PasswordField() {\n\nconst passwordHintId = useId();\n\nconsole.log('Generated identifier:', passwordHintId)\n\nreturn (\n\n<>\n\n<label>\n\nPassword:\n\n<input\n\ntype=\"password\"\n\naria-describedby={passwordHintId}\n\n/>\n\n</label>\n\n<p id={passwordHintId}>\n\nThe password should contain at least 18 characters\n\n</p>\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<h2>Choose password</h2>\n\n<PasswordField />\n\n</>\n\n);\n\n}\n\n```\n\n```js index.js active\n\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\nimport './styles.css';\n\nconst root1 = createRoot(document.getElementById('root1'), {\n\nidentifierPrefix: 'my-first-app-'\n\n});\n\nroot1.render(<App />);\n\nconst root2 = createRoot(document.getElementById('root2'), {\n\nidentifierPrefix: 'my-second-app-'\n\n});\n\nroot2.render(<App />);\n\n```\n\n```css\n\n#root1 {\n\nborder: 5px solid blue;\n\npadding: 10px;\n\nmargin: 5px;\n\n}\n\n#root2 {\n\nborder: 5px solid green;\n\npadding: 10px;\n\nmargin: 5px;\n\n}\n\ninput { margin: 5px; }\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useId.md"}},"271":{"pageContent":"--\n\ntitle: <StrictMode>\n\n--\n\n<Intro>\n\n`<StrictMode>` lets you find common bugs in your components early during development.\n\n```js\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `<StrictMode>` {/*strictmode*/}\n\nUse `StrictMode` to enable additional development behaviors and warnings for the entire component tree inside:\n\n```js\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\n[See more examples below.](#usage)\n\nStrict Mode enables the following development-only behaviors:\n\nYour components will [re-render an extra time](#fixing-bugs-found-by-double-rendering-in-development) to find bugs caused by impure rendering.\n\nYour components will [re-run Effects an extra time](#fixing-bugs-found-by-re-running-effects-in-development) to find bugs caused by missing Effect cleanup.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"272":{"pageContent":"Your components will [re-run Effects an extra time](#fixing-bugs-found-by-re-running-effects-in-development) to find bugs caused by missing Effect cleanup.\n\nYour components will [be checked for usage of deprecated APIs.](#fixing-deprecation-warnings-enabled-by-strict-mode)\n\n#### Props {/*props*/}\n\n`StrictMode` accepts no props.\n\n#### Caveats {/*caveats*/}\n\nThere is no way to opt out of Strict Mode inside a tree wrapped in `<StrictMode>`. This gives you confidence that all components inside `<StrictMode>` are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move `<StrictMode>` down in the tree.\n\n--\n\n## Usage {/*usage*/}\n\n### Enabling Strict Mode for entire app {/*enabling-strict-mode-for-entire-app*/}\n\nStrict Mode enables extra development-only checks for the entire component tree inside the `<StrictMode>` component. These checks help you find common bugs in your components early in the development process.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"273":{"pageContent":"To enable Strict Mode for your entire app, wrap your root component with `<StrictMode>` when you render it:\n\n```js {6,8}\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\nWe recommend to wrap your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls [`createRoot`](/reference/react/createRoot) for you, check its documentation for how to enable Strict Mode.\n\nAlthough the Strict Mode checks **only run in development,** they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.\n\n<Note>\n\nStrict Mode enables the following checks in development:\n\nYour components will [re-render an extra time](#fixing-bugs-found-by-double-rendering-in-development) to find bugs caused by impure rendering.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"274":{"pageContent":"Strict Mode enables the following checks in development:\n\nYour components will [re-render an extra time](#fixing-bugs-found-by-double-rendering-in-development) to find bugs caused by impure rendering.\n\nYour components will [re-run Effects an extra time](#fixing-bugs-found-by-re-running-effects-in-development) to find bugs caused by missing Effect cleanup.\n\nYour components will [be checked for usage of deprecated APIs.](#fixing-deprecation-warnings-enabled-by-strict-mode)\n\n*All of these checks are development-only and do not impact the production build.**\n\n</Note>\n\n--\n\n### Enabling strict mode for a part of the app {/*enabling-strict-mode-for-a-part-of-the-app*/}\n\nYou can also enable Strict Mode for any part of your application:\n\n```js {7,12}\n\nimport { StrictMode } from 'react';\n\nfunction App() {\n\nreturn (\n\n<>\n\n<Header />\n\n<StrictMode>\n\n<main>\n\n<Sidebar />\n\n<Content />\n\n</main>\n\n</StrictMode>\n\n<Footer />\n\n</>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"275":{"pageContent":"```js {7,12}\n\nimport { StrictMode } from 'react';\n\nfunction App() {\n\nreturn (\n\n<>\n\n<Header />\n\n<StrictMode>\n\n<main>\n\n<Sidebar />\n\n<Content />\n\n</main>\n\n</StrictMode>\n\n<Footer />\n\n</>\n\n);\n\n}\n\n```\n\nIn this example, Strict Mode checks will not run against the `Header` and `Footer` components. However, they will run on `Sidebar` and `Content`, as well as all of the components inside them, no matter how deep.\n\n--\n\n### Fixing bugs found by double rendering in development {/*fixing-bugs-found-by-double-rendering-in-development*/}\n\n[React assumes that every component you write is a pure function.](/learn/keeping-components-pure) This means that React components you write must always return the same JSX given the same inputs (props, state, and context).\n\nComponents breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) **twice in development.** This includes:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"276":{"pageContent":"Your component function body (only top-level logic, so this doesn't include code inside event handlers)\n\nFunctions that you pass to [`useState`](/reference/react/useState), [`set` functions](/reference/react/useState#setstate), [`useMemo`](/reference/react/useMemo), or [`useReducer`](/reference/react/useReducer)\n\nSome class component methods like [`constructor`](/reference/react/Component#constructor), [`render`](/reference/react/Component#render), [`shouldComponentUpdate`](/reference/react/Component#shouldcomponentupdate) ([see the whole list](https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects))\n\nIf a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running that impure code twice tends to be noticeable (that's what makes it impure!) This helps you spot and fix the bug early.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"277":{"pageContent":"*Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early.**\n\nThis `StoryTray` component takes an array of `stories` and adds one last \"Create Story\" item at the end:\n\n<Sandpack>\n\n```js index.js\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(<App />);\n\n```\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport StoryTray from './StoryTray.js';\n\nlet initialStories = [\n\n{id: 0, label: \"Ankit's Story\" },\n\n{id: 1, label: \"Taylor's Story\" },\n\n];\n\nexport default function App() {\n\nlet [stories, setStories] = useState(initialStories)\n\nreturn (\n\n<div\n\nstyle={{\n\nwidth: '100%',\n\nheight: '100%',\n\ntextAlign: 'center',\n\n}}\n\n>\n\n<StoryTray stories={stories} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js StoryTray.js active\n\nexport default function StoryTray({ stories }) {\n\nconst items = stories;\n\nitems.push({ id: 'create', label: 'Create Story' });\n\nreturn (\n\n<ul>\n\n{items.map(story => (\n\n<li key={story.id}>\n\n{story.label}\n\n</li>\n\n))}\n\n</ul>\n\n);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"278":{"pageContent":"const items = stories;\n\nitems.push({ id: 'create', label: 'Create Story' });\n\nreturn (\n\n<ul>\n\n{items.map(story => (\n\n<li key={story.id}>\n\n{story.label}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n```\n\n```css\n\nul {\n\nmargin: 0;\n\nlist-style-type: none;\n\nheight: 100%;\n\n}\n\nli {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nfloat: left;\n\nmargin: 5px;\n\nmargin-bottom: 20px;\n\npadding: 5px;\n\nwidth: 70px;\n\nheight: 100px;\n\n}\n\n```\n\n</Sandpack>\n\nThere is a mistake in the code above. However, it is easy to miss because the initial output appears correct.\n\nThis mistake will become more noticeable if the `StoryTray` component re-renders multiple times. For example, let's make the `StoryTray` re-render with a different background color whenever you hover the pointer over it:\n\n<Sandpack>\n\n```js index.js\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\n```\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport StoryTray from './StoryTray.js';\n\nlet initialStories = [","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"279":{"pageContent":"const root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\n```\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport StoryTray from './StoryTray.js';\n\nlet initialStories = [\n\n{id: 0, label: \"Ankit's Story\" },\n\n{id: 1, label: \"Taylor's Story\" },\n\n];\n\nexport default function App() {\n\nlet [stories, setStories] = useState(initialStories)\n\nreturn (\n\n<div\n\nstyle={{\n\nwidth: '100%',\n\nheight: '100%',\n\ntextAlign: 'center',\n\n}}\n\n>\n\n<StoryTray stories={stories} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js StoryTray.js active\n\nimport { useState } from 'react';\n\nexport default function StoryTray({ stories }) {\n\nconst [isHover, setIsHover] = useState(false);\n\nconst items = stories;\n\nitems.push({ id: 'create', label: 'Create Story' });\n\nreturn (\n\n<ul\n\nonPointerEnter={() => setIsHover(true)}\n\nonPointerLeave={() => setIsHover(false)}\n\nstyle={{\n\nbackgroundColor: isHover ? '#ddd' : '#fff'\n\n}}\n\n>\n\n{items.map(story => (\n\n<li key={story.id}>\n\n{story.label}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n```\n\n```css\n\nul {\n\nmargin: 0;\n\nlist-style-type: none;\n\nheight: 100%;\n\n}\n\nli {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"280":{"pageContent":"}}\n\n>\n\n{items.map(story => (\n\n<li key={story.id}>\n\n{story.label}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n```\n\n```css\n\nul {\n\nmargin: 0;\n\nlist-style-type: none;\n\nheight: 100%;\n\n}\n\nli {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nfloat: left;\n\nmargin: 5px;\n\nmargin-bottom: 20px;\n\npadding: 5px;\n\nwidth: 70px;\n\nheight: 100px;\n\n}\n\n```\n\n</Sandpack>\n\nNotice how every time you hover over the `StoryTray` component, \"Create Story\" gets added to the list again. The intention of the code was to add it once at the end. But `StoryTray` directly modifies the `stories` array from the props. Every time `StoryTray` renders, it adds \"Create Story\" again at the end of the same array. In other words, `StoryTray` is not a pure function--running it multiple times produces different results.\n\nTo fix this problem, you can make a copy of the array, and modify that copy instead of the original one:\n\n```js {2}\n\nexport default function StoryTray({ stories }) {\n\nconst items = stories.slice(); // Clone the array\n\n// âœ… Good: Pushing into a new array","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"281":{"pageContent":"```js {2}\n\nexport default function StoryTray({ stories }) {\n\nconst items = stories.slice(); // Clone the array\n\n// âœ… Good: Pushing into a new array\n\nitems.push({ id: 'create', label: 'Create Story' });\n\n```\n\nThis would [make the `StoryTray` function pure.](/learn/keeping-components-pure) Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but notice that you had to make the component re-render more often before it became obvious that something is wrong with its behavior.\n\n*In the original example, the bug wasn't obvious. Now let's wrap the original (buggy) code in `<StrictMode>`:**\n\n<Sandpack>\n\n```js index.js\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\n```js App.js\n\nimport { useState } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"282":{"pageContent":"import './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport StoryTray from './StoryTray.js';\n\nlet initialStories = [\n\n{id: 0, label: \"Ankit's Story\" },\n\n{id: 1, label: \"Taylor's Story\" },\n\n];\n\nexport default function App() {\n\nlet [stories, setStories] = useState(initialStories)\n\nreturn (\n\n<div\n\nstyle={{\n\nwidth: '100%',\n\nheight: '100%',\n\ntextAlign: 'center',\n\n}}\n\n>\n\n<StoryTray stories={stories} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js StoryTray.js active\n\nexport default function StoryTray({ stories }) {\n\nconst items = stories;\n\nitems.push({ id: 'create', label: 'Create Story' });\n\nreturn (\n\n<ul>\n\n{items.map(story => (\n\n<li key={story.id}>\n\n{story.label}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n```\n\n```css\n\nul {\n\nmargin: 0;\n\nlist-style-type: none;\n\nheight: 100%;\n\n}\n\nli {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nfloat: left;\n\nmargin: 5px;\n\nmargin-bottom: 20px;\n\npadding: 5px;\n\nwidth: 70px;\n\nheight: 100px;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"283":{"pageContent":"```css\n\nul {\n\nmargin: 0;\n\nlist-style-type: none;\n\nheight: 100%;\n\n}\n\nli {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nfloat: left;\n\nmargin: 5px;\n\nmargin-bottom: 20px;\n\npadding: 5px;\n\nwidth: 70px;\n\nheight: 100px;\n\n}\n\n```\n\n</Sandpack>\n\n*Strict Mode *always* calls your rendering function twice, so you can see the mistake right away** (\"Create Story\" appears twice). Strict Mode lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, you *also* fix many possible future production bugs like the hover functionality from before:\n\n<Sandpack>\n\n```js index.js\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport StoryTray from './StoryTray.js';\n\nlet initialStories = [\n\n{id: 0, label: \"Ankit's Story\" },\n\n{id: 1, label: \"Taylor's Story\" },\n\n];","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"284":{"pageContent":"<App />\n\n</StrictMode>\n\n);\n\n```\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport StoryTray from './StoryTray.js';\n\nlet initialStories = [\n\n{id: 0, label: \"Ankit's Story\" },\n\n{id: 1, label: \"Taylor's Story\" },\n\n];\n\nexport default function App() {\n\nlet [stories, setStories] = useState(initialStories)\n\nreturn (\n\n<div\n\nstyle={{\n\nwidth: '100%',\n\nheight: '100%',\n\ntextAlign: 'center',\n\n}}\n\n>\n\n<StoryTray stories={stories} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js StoryTray.js active\n\nimport { useState } from 'react';\n\nexport default function StoryTray({ stories }) {\n\nconst [isHover, setIsHover] = useState(false);\n\nconst items = stories.slice(); // Clone the array\n\nitems.push({ id: 'create', label: 'Create Story' });\n\nreturn (\n\n<ul\n\nonPointerEnter={() => setIsHover(true)}\n\nonPointerLeave={() => setIsHover(false)}\n\nstyle={{\n\nbackgroundColor: isHover ? '#ddd' : '#fff'\n\n}}\n\n>\n\n{items.map(story => (\n\n<li key={story.id}>\n\n{story.label}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n```\n\n```css\n\nul {\n\nmargin: 0;\n\nlist-style-type: none;\n\nheight: 100%;\n\n}\n\nli {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nfloat: left;\n\nmargin: 5px;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"285":{"pageContent":">\n\n{items.map(story => (\n\n<li key={story.id}>\n\n{story.label}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n```\n\n```css\n\nul {\n\nmargin: 0;\n\nlist-style-type: none;\n\nheight: 100%;\n\n}\n\nli {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nfloat: left;\n\nmargin: 5px;\n\nmargin-bottom: 20px;\n\npadding: 5px;\n\nwidth: 70px;\n\nheight: 100px;\n\n}\n\n```\n\n</Sandpack>\n\nWithout Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.\n\n[Read more about keeping components pure.](/learn/keeping-components-pure)\n\n<Note>\n\nIf you have [React DevTools](/learn/react-developer-tools) installed, any `console.log` calls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.\n\n</Note>\n\n--\n\n### Fixing bugs found by re-running Effects in development {/*fixing-bugs-found-by-re-running-effects-in-development*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"286":{"pageContent":"</Note>\n\n--\n\n### Fixing bugs found by re-running Effects in development {/*fixing-bugs-found-by-re-running-effects-in-development*/}\n\nStrict Mode can also help find bugs in [Effects.](/learn/synchronizing-with-effects)\n\nEvery Effect has some setup code and may have some cleanup code. Normally, React calls setup when the component *mounts* (is added to the screen) and calls cleanup when the component *unmounts* (is removed from the screen). Additionally, React calls cleanup and setup again if its dependencies changed since the last render.\n\nWhen Strict Mode is on, React will also run **one extra setup+cleanup cycle in development for every Effect.** This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.\n\n*Here is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.**\n\nConsider this example that connects a component to a chat:\n\n<Sandpack>\n\n```js index.js\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"287":{"pageContent":"Consider this example that connects a component to a chat:\n\n<Sandpack>\n\n```js index.js\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(<App />);\n\n```\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nconst roomId = 'general';\n\nexport default function ChatRoom() {\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\n}, []);\n\nreturn <h1>Welcome to the {roomId} room!</h1>;\n\n}\n\n```\n\n```js chat.js\n\nlet connections = 0;\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\nconnections++;\n\nconsole.log('Active connections: ' + connections);\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"288":{"pageContent":"connections++;\n\nconsole.log('Active connections: ' + connections);\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\nconnections--;\n\nconsole.log('Active connections: ' + connections);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nThere is an issue with this code, but it might not be immediately clear.\n\nTo make the issue more obvious, let's implement a feature. In the example below, `roomId` is not hardcoded. Instead, the user can select the `roomId` that they want to connect to from a dropdown. Click \"Open chat\" and then select different chat rooms one by one. Keep track of the number of active connections in the console:\n\n<Sandpack>\n\n```js index.js\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(<App />);\n\n```\n\n```js\n\nimport { useState, useEffect } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"289":{"pageContent":"import './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(<App />);\n\n```\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\n}, [roomId]);\n\nreturn <h1>Welcome to the {roomId} room!</h1>;\n\n}\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nlet connections = 0;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"290":{"pageContent":"</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nlet connections = 0;\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\nconnections++;\n\nconsole.log('Active connections: ' + connections);\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\nconnections--;\n\nconsole.log('Active connections: ' + connections);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nYou'll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is that [your Effect is missing a cleanup function:](/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed)\n\n```js {4}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"291":{"pageContent":"```js {4}\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\n```\n\nNow that your Effect \"cleans up\" after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become immediately visible until you've added more features (the select box).\n\n*In the original example, the bug wasn't obvious. Now let's wrap the original (buggy) code in `<StrictMode>`:**\n\n<Sandpack>\n\n```js index.js\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nconst roomId = 'general';\n\nexport default function ChatRoom() {\n\nuseEffect(() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"292":{"pageContent":"import { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nconst roomId = 'general';\n\nexport default function ChatRoom() {\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\n}, []);\n\nreturn <h1>Welcome to the {roomId} room!</h1>;\n\n}\n\n```\n\n```js chat.js\n\nlet connections = 0;\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\nconnections++;\n\nconsole.log('Active connections: ' + connections);\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\nconnections--;\n\nconsole.log('Active connections: ' + connections);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"293":{"pageContent":"connections--;\n\nconsole.log('Active connections: ' + connections);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\n*With Strict Mode, you immediately see that there is a problem** (the number of active connections jumps to 2). This is because Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn't destroy it. This is a hint that you're missing a cleanup function.\n\nStrict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, you *also* fix many possible future production bugs like the select box from before:\n\n<Sandpack>\n\n```js index.js\n\nimport { StrictMode } from 'react';\n\nimport { createRoot } from 'react-dom/client';\n\nimport './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"294":{"pageContent":"import './styles.css';\n\nimport App from './App';\n\nconst root = createRoot(document.getElementById(\"root\"));\n\nroot.render(\n\n<StrictMode>\n\n<App />\n\n</StrictMode>\n\n);\n\n```\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\nreturn <h1>Welcome to the {roomId} room!</h1>;\n\n}\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"295":{"pageContent":"<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nlet connections = 0;\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\nconnections++;\n\nconsole.log('Active connections: ' + connections);\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\nconnections--;\n\nconsole.log('Active connections: ' + connections);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nNotice how the active connection count in the console doesn't keep growing anymore.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"296":{"pageContent":"}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nNotice how the active connection count in the console doesn't keep growing anymore.\n\nWithout Strict Mode, it was easy to miss that your Effect needed cleanup. By running *setup â†’ cleanup â†’ setup* instead of *setup* for your Effect in development, Strict Mode made the missing cleanup logic more noticeable.\n\n[Read more about implementing Effect cleanup.](/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)\n\n--\n\n### Fixing deprecation warnings enabled by Strict Mode {/*fixing-deprecation-warnings-enabled-by-strict-mode*/}\n\nReact warns if some component anywhere inside a `<StrictMode>` tree uses one of these deprecated APIs:\n\n[`findDOMNode`](/reference/react-dom/findDOMNode). [See alternatives.](https://reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"297":{"pageContent":"[`findDOMNode`](/reference/react-dom/findDOMNode). [See alternatives.](https://reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)\n\n`UNSAFE_` class lifecycle methods like [`UNSAFE_componentWillMount`](/reference/react/Component#unsafe_componentwillmount). [See alternatives.](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#migrating-from-legacy-lifecycles)\n\nLegacy context ([`childContextTypes`](/reference/react/Component#static-childcontexttypes), [`contextTypes`](/reference/react/Component#static-contexttypes), and [`getChildContext`](/reference/react/Component#getchildcontext)). [See alternatives.](/reference/react/createContext)\n\nLegacy string refs ([`this.refs`](/reference/react/Component#refs)). [See alternatives.](https://reactjs.org/docs/strict-mode.html#warning-about-legacy-string-ref-api-usage)\n\nThese APIs are primarily used in older [class components](/reference/react/Component) so they rarely appear in modern apps.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/StrictMode.md"}},"298":{"pageContent":"--\n\ntitle: \"Legacy React APIs\"\n\n--\n\n<Intro>\n\nThese APIs are exported from the `react` package, but they are not recommended for use in the newly written code. See the linked individual API pages for the suggested alternatives.\n\n</Intro>\n\n--\n\n## Legacy APIs {/*legacy-apis*/}\n\n[`Children`](/reference/react/Children) lets you manipulate and transform the JSX received as the `children` prop. [See alternatives.](/reference/react/Children#alternatives)\n\n[`cloneElement`](/reference/react/cloneElement) lets you create a React element using another element as a starting point. [See alternatives.](/reference/react/cloneElement#alternatives)\n\n[`Component`](/reference/react/Component) lets you define a React component as a JavaScript class. [See alternatives.](/reference/react/Component#alternatives)\n\n[`createElement`](/reference/react/createElement) lets you create a React element. Typically, you'll use JSX instead.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/legacy.md"}},"299":{"pageContent":"[`createElement`](/reference/react/createElement) lets you create a React element. Typically, you'll use JSX instead.\n\n[`createRef`](/reference/react/createRef) creates a ref object which can contain arbitrary value. [See alternatives.](/reference/react/createRef#alternatives)\n\n[`isValidElement`](/reference/react/isValidElement) checks whether a value is a React element. Typically used with [`cloneElement`.](/reference/react/cloneElement)\n\n[`PureComponent`](/reference/react/PureComponent) is similar to [`Component`,](/reference/react/Component) but it skip re-renders with same props. [See alternatives.](/reference/react/PureComponent#alternatives)\n\n--\n\n## Deprecated APIs {/*deprecated-apis*/}\n\n<Deprecated>\n\nThese APIs will be removed in a future major version of React.\n\n</Deprecated>\n\n[`createFactory`](/reference/react/createFactory) lets you create a function that produces React elements of a certain type.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/legacy.md"}},"300":{"pageContent":"--\n\ntitle: Children\n\n--\n\n<Pitfall>\n\nUsing `Children` is uncommon and can lead to fragile code. [See common alternatives.](#alternatives)\n\n</Pitfall>\n\n<Intro>\n\n`Children` lets you manipulate and transform the JSX you received as the [`children` prop.](/learn/passing-props-to-a-component#passing-jsx-as-children)\n\n```js\n\nconst mappedChildren = Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n);\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `Children.count(children)` {/*children-count*/}\n\nCall `Children.count(children)` to count the number of children in the `children` data structure.\n\n```js RowList.js active\n\nimport { Children } from 'react';\n\nfunction RowList({ children }) {\n\nreturn (\n\n<>\n\n<h1>Total rows: {Children.count(children)}</h1>\n\n...\n\n</>\n\n);\n\n}\n\n```\n\n[See more examples below.](#counting-children)\n\n#### Parameters {/*children-count-parameters*/}\n\n`children`: The value of the [`children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"301":{"pageContent":"#### Parameters {/*children-count-parameters*/}\n\n`children`: The value of the [`children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n#### Returns {/*children-count-returns*/}\n\nThe number of nodes inside these `children`.\n\n#### Caveats {/*children-count-caveats*/}\n\nEmpty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](/reference/react/createElement) count as individual nodes. Arrays don't count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don't get rendered, and their children aren't traversed. [Fragments](/reference/react/Fragment) don't get traversed.\n\n--\n\n### `Children.forEach(children, fn, thisArg?)` {/*children-foreach*/}\n\nCall `Children.forEach(children, fn, thisArg?)` to run some code for each child in the `children` data structure.\n\n```js RowList.js active\n\nimport { Children } from 'react';\n\nfunction SeparatorList({ children }) {\n\nconst result = [];","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"302":{"pageContent":"```js RowList.js active\n\nimport { Children } from 'react';\n\nfunction SeparatorList({ children }) {\n\nconst result = [];\n\nChildren.forEach(children, (child, index) => {\n\nresult.push(child);\n\nresult.push(<hr key={index} />);\n\n});\n\n// ...\n\n```\n\n[See more examples below.](#running-some-code-for-each-child)\n\n#### Parameters {/*children-foreach-parameters*/}\n\n`children`: The value of the [`children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n`fn`: The function you want to run for each child, similar to the [array `forEach` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) callback. It will be called with the child as the first argument and its index as the second argument. The index starts at `0` and increments on each call.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"303":{"pageContent":"**optional** `thisArg`: The [`this` value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with which the `fn` function should be called. If omitted, it's `undefined`.\n\n#### Returns {/*children-foreach-returns*/}\n\n`Children.forEach` returns `undefined`.\n\n#### Caveats {/*children-foreach-caveats*/}\n\nEmpty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](/reference/react/createElement) count as individual nodes. Arrays don't count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don't get rendered, and their children aren't traversed. [Fragments](/reference/react/Fragment) don't get traversed.\n\n--\n\n### `Children.map(children, fn, thisArg?)` {/*children-map*/}\n\nCall `Children.map(children, fn, thisArg?)` to map or transform each child in the `children` data structure.\n\n```js RowList.js active\n\nimport { Children } from 'react';\n\nfunction RowList({ children }) {\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"304":{"pageContent":"```js RowList.js active\n\nimport { Children } from 'react';\n\nfunction RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```\n\n[See more examples below.](#transforming-children)\n\n#### Parameters {/*children-map-parameters*/}\n\n`children`: The value of the [`children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n`fn`: The mapping function, similar to the [array `map` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) callback. It will be called with the child as the first argument and its index as the second argument. The index starts at `0` and increments on each call. You need to return a React node from this function. This may be an empty node (`null`, `undefined`, or a Boolean), a string, a number, a React element, or an array of other React nodes.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"305":{"pageContent":"**optional** `thisArg`: The [`this` value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with which the `fn` function should be called. If omitted, it's `undefined`.\n\n#### Returns {/*children-map-returns*/}\n\nIf `children` is `null` or `undefined`, returns the same value.\n\nOtherwise, returns a flat array consisting of the nodes you've returned from the `fn` function. The returned array will contain all nodes you returned except for `null` and `undefined`.\n\n#### Caveats {/*children-map-caveats*/}\n\nEmpty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](/reference/react/createElement) count as individual nodes. Arrays don't count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don't get rendered, and their children aren't traversed. [Fragments](/reference/react/Fragment) don't get traversed.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"306":{"pageContent":"If you return an element or an array of elements with keys from `fn`, **the returned elements' keys will be automatically combined with the key of the corresponding original item from `children`.** When you return multiple elements from `fn` in an array, their keys only need to be unique locally amongst each other.\n\n--\n\n### `Children.only(children)` {/*children-only*/}\n\nCall `Children.only(children)` to assert that `children` represent a single React element.\n\n```js\n\nfunction Box({ children }) {\n\nconst element = Children.only(children);\n\n// ...\n\n```\n\n#### Parameters {/*children-only-parameters*/}\n\n`children`: The value of the [`children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n#### Returns {/*children-only-returns*/}\n\nIf `children` [is a valid element,](/reference/react/isValidElement) returns that element.\n\nOtherwise, throws an error.\n\n#### Caveats {/*children-only-caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"307":{"pageContent":"#### Returns {/*children-only-returns*/}\n\nIf `children` [is a valid element,](/reference/react/isValidElement) returns that element.\n\nOtherwise, throws an error.\n\n#### Caveats {/*children-only-caveats*/}\n\nThis method always **throws if you pass an array (such as the return value of `Children.map`) as `children`.** In other words, it enforces that `children` is a single React element, not that it's an array with a single element.\n\n--\n\n### `Children.toArray(children)` {/*children-toarray*/}\n\nCall `Children.toArray(children)` to create an array out of the `children` data structure.\n\n```js ReversedList.js active\n\nimport { Children } from 'react';\n\nexport default function ReversedList({ children }) {\n\nconst result = Children.toArray(children);\n\nresult.reverse();\n\n// ...\n\n```\n\n#### Parameters {/*children-toarray-parameters*/}\n\n`children`: The value of the [`children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n#### Returns {/*children-toarray-returns*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"308":{"pageContent":"`children`: The value of the [`children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n#### Returns {/*children-toarray-returns*/}\n\nReturns a flat array of elements in `children`.\n\n#### Caveats {/*children-toarray-caveats*/}\n\nEmpty nodes (`null`, `undefined`, and Booleans) will be omitted in the returned array. **The returned elements' keys will be calculated from the original elements' keys and their level of nesting and position.** This ensures that flattening the array does not introduce changes in behavior.\n\n--\n\n## Usage {/*usage*/}\n\n### Transforming children {/*transforming-children*/}\n\nTo transform the children JSX that your component [receives as the `children` prop,](/learn/passing-props-to-a-component#passing-jsx-as-children) call `Children.map`:\n\n```js {6,10}\n\nimport { Children } from 'react';\n\nfunction RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"309":{"pageContent":"```js {6,10}\n\nimport { Children } from 'react';\n\nfunction RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```\n\nIn the example above, the `RowList` wraps every child it receives into a `<div className=\"Row\">` container. For example, let's say the parent component passes three `<p>` tags as the `children` prop to `RowList`:\n\n```js\n\n<RowList>\n\n<p>This is the first item.</p>\n\n<p>This is the second item.</p>\n\n<p>This is the third item.</p>\n\n</RowList>\n\n```\n\nThen, with the `RowList` implementation above, the final rendered result will look like this:\n\n```js\n\n<div className=\"RowList\">\n\n<div className=\"Row\">\n\n<p>This is the first item.</p>\n\n</div>\n\n<div className=\"Row\">\n\n<p>This is the second item.</p>\n\n</div>\n\n<div className=\"Row\">\n\n<p>This is the third item.</p>\n\n</div>\n\n</div>\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"310":{"pageContent":"<div className=\"Row\">\n\n<p>This is the first item.</p>\n\n</div>\n\n<div className=\"Row\">\n\n<p>This is the second item.</p>\n\n</div>\n\n<div className=\"Row\">\n\n<p>This is the third item.</p>\n\n</div>\n\n</div>\n\n```\n\n`Children.map` is similar to [to transforming arrays with `map()`.](/learn/rendering-lists) The difference is that the `children` data structure is considered *opaque.* This means that even if it's sometimes an array, you should not assume it's an array or any other particular data type. This is why you should use `Children.map` if you need to transform it.\n\n<Sandpack>\n\n```js\n\nimport RowList from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList>\n\n<p>This is the first item.</p>\n\n<p>This is the second item.</p>\n\n<p>This is the third item.</p>\n\n</RowList>\n\n);\n\n}\n\n```\n\n```js RowList.js active\n\nimport { Children } from 'react';\n\nexport default function RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"311":{"pageContent":"export default function RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n<DeepDive>\n\n#### Why is the children prop not always an array? {/*why-is-the-children-prop-not-always-an-array*/}\n\nIn React, the `children` prop is considered an *opaque* data structure. This means that you shouldn't rely on how it is structured. To transform, filter, or count children, you should use the `Children` methods.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"312":{"pageContent":"In practice, the `children` data structure is often represented as an array internally. However, if there is only a single child, then React won't create an extra array since this would lead to unnecessary memory overhead. As long as you use the `Children` methods instead of directly introspecting the `children` prop, your code will not break even if React changes how the data structure is actually implemented.\n\nEven when `children` is an array, `Children.map` has useful special behavior. For example, `Children.map` combines the [keys](/learn/rendering-lists#keeping-list-items-in-order-with-key) on the returned elements with the keys on the `children` you've passed to it. This ensures the original JSX children don't \"lose\" keys even if they get wrapped like in the example above.\n\n</DeepDive>\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"313":{"pageContent":"</DeepDive>\n\n<Pitfall>\n\nThe `children` data structure **does not include rendered output** of the components you pass as JSX. In the example below, the `children` received by the `RowList` only contains two items rather than three:\n\n1. `<p>This is the first item.</p>`\n\n2. `<MoreRows />`\n\nThis is why only two row wrappers are generated in this example:\n\n<Sandpack>\n\n```js\n\nimport RowList from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList>\n\n<p>This is the first item.</p>\n\n<MoreRows />\n\n</RowList>\n\n);\n\n}\n\nfunction MoreRows() {\n\nreturn (\n\n<>\n\n<p>This is the second item.</p>\n\n<p>This is the third item.</p>\n\n</>\n\n);\n\n}\n\n```\n\n```js RowList.js\n\nimport { Children } from 'react';\n\nexport default function RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"314":{"pageContent":"{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n*There is no way to get the rendered output of an inner component** like `<MoreRows />` when manipulating `children`. This is why [it's usually better to use one of the alternative solutions.](#alternatives)\n\n</Pitfall>\n\n--\n\n### Running some code for each child {/*running-some-code-for-each-child*/}\n\nCall `Children.forEach` to iterate over each child in the `children` data structure. It does not return any value and is similar to the [array `forEach` method.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) You can use it to run custom logic like constructing your own array.\n\n<Sandpack>\n\n```js\n\nimport SeparatorList from './SeparatorList.js';\n\nexport default function App() {\n\nreturn (\n\n<SeparatorList>\n\n<p>This is the first item.</p>\n\n<p>This is the second item.</p>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"315":{"pageContent":"<Sandpack>\n\n```js\n\nimport SeparatorList from './SeparatorList.js';\n\nexport default function App() {\n\nreturn (\n\n<SeparatorList>\n\n<p>This is the first item.</p>\n\n<p>This is the second item.</p>\n\n<p>This is the third item.</p>\n\n</SeparatorList>\n\n);\n\n}\n\n```\n\n```js SeparatorList.js active\n\nimport { Children } from 'react';\n\nexport default function SeparatorList({ children }) {\n\nconst result = [];\n\nChildren.forEach(children, (child, index) => {\n\nresult.push(child);\n\nresult.push(<hr key={index} />);\n\n});\n\nresult.pop(); // Remove the last separator\n\nreturn result;\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it's usually better to use one of the alternative solutions.](#alternatives)\n\n</Pitfall>\n\n--\n\n### Counting children {/*counting-children*/}\n\nCall `Children.count(children)` to calculate the number of children.\n\n<Sandpack>\n\n```js\n\nimport RowList from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"316":{"pageContent":"Call `Children.count(children)` to calculate the number of children.\n\n<Sandpack>\n\n```js\n\nimport RowList from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList>\n\n<p>This is the first item.</p>\n\n<p>This is the second item.</p>\n\n<p>This is the third item.</p>\n\n</RowList>\n\n);\n\n}\n\n```\n\n```js RowList.js active\n\nimport { Children } from 'react';\n\nexport default function RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n<h1 className=\"RowListHeader\">\n\nTotal rows: {Children.count(children)}\n\n</h1>\n\n{Children.map(children, child =>\n\n<div className=\"Row\">\n\n{child}\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.RowListHeader {\n\npadding-top: 5px;\n\nfont-size: 25px;\n\nfont-weight: bold;\n\ntext-align: center;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"317":{"pageContent":"padding: 5px;\n\n}\n\n.RowListHeader {\n\npadding-top: 5px;\n\nfont-size: 25px;\n\nfont-weight: bold;\n\ntext-align: center;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it's usually better to use one of the alternative solutions.](#alternatives)\n\n</Pitfall>\n\n--\n\n### Converting children to an array {/*converting-children-to-an-array*/}\n\nCall `Children.toArray(children)` to turn the `children` data structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods like [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter), [`sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort), or [`reverse`.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)\n\n<Sandpack>\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"318":{"pageContent":"<Sandpack>\n\n```js\n\nimport ReversedList from './ReversedList.js';\n\nexport default function App() {\n\nreturn (\n\n<ReversedList>\n\n<p>This is the first item.</p>\n\n<p>This is the second item.</p>\n\n<p>This is the third item.</p>\n\n</ReversedList>\n\n);\n\n}\n\n```\n\n```js ReversedList.js active\n\nimport { Children } from 'react';\n\nexport default function ReversedList({ children }) {\n\nconst result = Children.toArray(children);\n\nresult.reverse();\n\nreturn result;\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it's usually better to use one of the alternative solutions.](#alternatives)\n\n</Pitfall>\n\n--\n\n## Alternatives {/*alternatives*/}\n\n<Note>\n\nThis section describes alternatives to the `Children` API (with capital `C`) that's imported like this:\n\n```js\n\nimport { Children } from 'react';\n\n```\n\nDon't confuse it with [using the `children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) (lowercase `c`), which is good and encouraged.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"319":{"pageContent":"```js\n\nimport { Children } from 'react';\n\n```\n\nDon't confuse it with [using the `children` prop](/learn/passing-props-to-a-component#passing-jsx-as-children) (lowercase `c`), which is good and encouraged.\n\n</Note>\n\n### Exposing multiple components {/*exposing-multiple-components*/}\n\nManipulating children with the `Children` methods often leads to fragile code. When you pass children to a component in JSX, you don't usually expect the component to manipulate or transform the individual children.\n\nWhen you can, try to avoid using the `Children` methods. For example, if you want every child of `RowList` to be wrapped in `<div className=\"Row\">`, export a `Row` component, and manually wrap every row into it like this:\n\n<Sandpack>\n\n```js\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList>\n\n<Row>\n\n<p>This is the first item.</p>\n\n</Row>\n\n<Row>\n\n<p>This is the second item.</p>\n\n</Row>\n\n<Row>\n\n<p>This is the third item.</p>\n\n</Row>\n\n</RowList>\n\n);\n\n}\n\n```\n\n```js RowList.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"320":{"pageContent":"return (\n\n<RowList>\n\n<Row>\n\n<p>This is the first item.</p>\n\n</Row>\n\n<Row>\n\n<p>This is the second item.</p>\n\n</Row>\n\n<Row>\n\n<p>This is the third item.</p>\n\n</Row>\n\n</RowList>\n\n);\n\n}\n\n```\n\n```js RowList.js\n\nexport function RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{children}\n\n</div>\n\n);\n\n}\n\nexport function Row({ children }) {\n\nreturn (\n\n<div className=\"Row\">\n\n{children}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\nUnlike using `Children.map`, this approach does not wrap every child automatically. **However, this approach has a significant benefit compared to the [earlier example with `Children.map`](#transforming-children) because it works even if you keep extracting more components.** For example, it still works if you extract your own `MoreRows` component:\n\n<Sandpack>\n\n```js\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList>\n\n<Row>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"321":{"pageContent":"<Sandpack>\n\n```js\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList>\n\n<Row>\n\n<p>This is the first item.</p>\n\n</Row>\n\n<MoreRows />\n\n</RowList>\n\n);\n\n}\n\nfunction MoreRows() {\n\nreturn (\n\n<>\n\n<Row>\n\n<p>This is the second item.</p>\n\n</Row>\n\n<Row>\n\n<p>This is the third item.</p>\n\n</Row>\n\n</>\n\n);\n\n}\n\n```\n\n```js RowList.js\n\nexport function RowList({ children }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{children}\n\n</div>\n\n);\n\n}\n\nexport function Row({ children }) {\n\nreturn (\n\n<div className=\"Row\">\n\n{children}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\nThis wouldn't work with `Children.map` because it would \"see\" `<MoreRows />` as a single child (and a single row).\n\n--\n\n### Accepting an array of objects as a prop {/*accepting-an-array-of-objects-as-a-prop*/}\n\nYou can also explicitly pass an array as a prop. For example, this `RowList` accepts a `rows` array as a prop:\n\n<Sandpack>\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"322":{"pageContent":"You can also explicitly pass an array as a prop. For example, this `RowList` accepts a `rows` array as a prop:\n\n<Sandpack>\n\n```js\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList rows={[\n\n{ id: 'first', content: <p>This is the first item.</p> },\n\n{ id: 'second', content: <p>This is the second item.</p> },\n\n{ id: 'third', content: <p>This is the third item.</p> }\n\n]} />\n\n);\n\n}\n\n```\n\n```js RowList.js\n\nexport function RowList({ rows }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n{rows.map(row => (\n\n<div className=\"Row\" key={row.id}>\n\n{row.content}\n\n</div>\n\n))}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\nSince `rows` is a regular JavaScript array, the `RowList` component can use built-in array methods like [`map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) on it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"323":{"pageContent":"This pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, the `TabSwitcher` component receives an array of objects as the `tabs` prop:\n\n<Sandpack>\n\n```js\n\nimport TabSwitcher from './TabSwitcher.js';\n\nexport default function App() {\n\nreturn (\n\n<TabSwitcher tabs={[\n\n{\n\nid: 'first',\n\nheader: 'First',\n\ncontent: <p>This is the first item.</p>\n\n},\n\n{\n\nid: 'second',\n\nheader: 'Second',\n\ncontent: <p>This is the second item.</p>\n\n},\n\n{\n\nid: 'third',\n\nheader: 'Third',\n\ncontent: <p>This is the third item.</p>\n\n}\n\n]} />\n\n);\n\n}\n\n```\n\n```js TabSwitcher.js\n\nimport { useState } from 'react';\n\nexport default function TabSwitcher({ tabs }) {\n\nconst [selectedId, setSelectedId] = useState(tabs[0].id);\n\nconst selectedTab = tabs.find(tab => tab.id === selectedId);\n\nreturn (\n\n<>\n\n{tabs.map(tab => (\n\n<button\n\nkey={tab.id}\n\nonClick={() => setSelectedId(tab.id)}\n\n>\n\n{tab.header}\n\n</button>\n\n))}\n\n<hr />\n\n<div key={selectedId}>\n\n<h3>{selectedTab.header}</h3>\n\n{selectedTab.content}\n\n</div>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"324":{"pageContent":"<button\n\nkey={tab.id}\n\nonClick={() => setSelectedId(tab.id)}\n\n>\n\n{tab.header}\n\n</button>\n\n))}\n\n<hr />\n\n<div key={selectedId}>\n\n<h3>{selectedTab.header}</h3>\n\n{selectedTab.content}\n\n</div>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\nUnlike passing the children as JSX, this approach lets you associate some extra data like `header` with each item. Because you are working with the `tabs` directly, and it is an array, you do not need the `Children` methods.\n\n--\n\n### Calling a render prop to customize rendering {/*calling-a-render-prop-to-customize-rendering*/}\n\nInstead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, the `App` component passes a `renderContent` function to the `TabSwitcher` component. The `TabSwitcher` component calls `renderContent` only for the selected tab:\n\n<Sandpack>\n\n```js\n\nimport TabSwitcher from './TabSwitcher.js';\n\nexport default function App() {\n\nreturn (\n\n<TabSwitcher\n\ntabIds={['first', 'second', 'third']}\n\ngetHeader={tabId => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"325":{"pageContent":"<Sandpack>\n\n```js\n\nimport TabSwitcher from './TabSwitcher.js';\n\nexport default function App() {\n\nreturn (\n\n<TabSwitcher\n\ntabIds={['first', 'second', 'third']}\n\ngetHeader={tabId => {\n\nreturn tabId[0].toUpperCase() + tabId.slice(1);\n\n}}\n\nrenderContent={tabId => {\n\nreturn <p>This is the {tabId} item.</p>;\n\n}}\n\n/>\n\n);\n\n}\n\n```\n\n```js TabSwitcher.js\n\nimport { useState } from 'react';\n\nexport default function TabSwitcher({ tabIds, getHeader, renderContent }) {\n\nconst [selectedId, setSelectedId] = useState(tabIds[0]);\n\nreturn (\n\n<>\n\n{tabIds.map((tabId) => (\n\n<button\n\nkey={tabId}\n\nonClick={() => setSelectedId(tabId)}\n\n>\n\n{getHeader(tabId)}\n\n</button>\n\n))}\n\n<hr />\n\n<div key={selectedId}>\n\n<h3>{getHeader(selectedId)}</h3>\n\n{renderContent(selectedId)}\n\n</div>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\nA prop like `renderContent` is called a *render prop* because it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"326":{"pageContent":"Render props are functions, so you can pass information to them. For example, this `RowList` component passes the `id` and the `index` of each row to the `renderRow` render prop, which uses `index` to highlight even rows:\n\n<Sandpack>\n\n```js\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n\nreturn (\n\n<RowList\n\nrowIds={['first', 'second', 'third']}\n\nrenderRow={(id, index) => {\n\nreturn (\n\n<Row isHighlighted={index % 2 === 0}>\n\n<p>This is the {id} item.</p>\n\n</Row>\n\n);\n\n}}\n\n/>\n\n);\n\n}\n\n```\n\n```js RowList.js\n\nimport { Fragment } from 'react';\n\nexport function RowList({ rowIds, renderRow }) {\n\nreturn (\n\n<div className=\"RowList\">\n\n<h1 className=\"RowListHeader\">\n\nTotal rows: {rowIds.length}\n\n</h1>\n\n{rowIds.map((rowId, index) =>\n\n<Fragment key={rowId}>\n\n{renderRow(rowId, index)}\n\n</Fragment>\n\n)}\n\n</div>\n\n);\n\n}\n\nexport function Row({ children, isHighlighted }) {\n\nreturn (\n\n<div className={[\n\n'Row',\n\nisHighlighted ? 'RowHighlighted' : ''\n\n].join(' ')}>\n\n{children}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"327":{"pageContent":"return (\n\n<div className={[\n\n'Row',\n\nisHighlighted ? 'RowHighlighted' : ''\n\n].join(' ')}>\n\n{children}\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.RowList {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.RowListHeader {\n\npadding-top: 5px;\n\nfont-size: 25px;\n\nfont-weight: bold;\n\ntext-align: center;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n.RowHighlighted {\n\nbackground: #ffa;\n\n}\n\n```\n\n</Sandpack>\n\nThis is another example of how parent and child components can cooperate without manipulating the children.\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### I pass a custom component, but the `Children` methods don't show its render result {/*i-pass-a-custom-component-but-the-children-methods-dont-show-its-render-result*/}\n\nSuppose you pass two children to `RowList` like this:\n\n```js\n\n<RowList>\n\n<p>First item</p>\n\n<MoreRows />\n\n</RowList>\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"328":{"pageContent":"Suppose you pass two children to `RowList` like this:\n\n```js\n\n<RowList>\n\n<p>First item</p>\n\n<MoreRows />\n\n</RowList>\n\n```\n\nIf you do `Children.count(children)` inside `RowList`, you will get `2`. Even if `MoreRows` renders 10 different items, or if it returns `null`, `Children.count(children)` will still be `2`. From the `RowList`'s perspective, it only \"sees\" the JSX it has received. It does not \"see\" the internals of the `MoreRows` component.\n\nThe limitation makes it hard to extract a component. This is why [alternatives](#alternatives) are preferred to using `Children`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Children.md"}},"329":{"pageContent":"--\n\ntitle: useEffect\n\n--\n\n<Intro>\n\n`useEffect` is a React Hook that lets you [synchronize a component with an external system.](/learn/synchronizing-with-effects)\n\n```js\n\nuseEffect(setup, dependencies?)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useEffect(setup, dependencies?)` {/*useeffect*/}\n\nCall `useEffect` at the top level of your component to declare an Effect:\n\n```js\n\nimport { useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"330":{"pageContent":"connection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`setup`: The function with your Effect's logic. Your setup function may also optionally return a *cleanup* function. When your component is first added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function one last time.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"331":{"pageContent":"**optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm. If you don't specify the dependencies at all, your Effect will re-run after every re-render of the component. [See the difference between passing an array of dependencies, an empty array, and no dependencies at all.](#examples-dependencies)\n\n#### Returns {/*returns*/}\n\n`useEffect` returns `undefined`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"332":{"pageContent":"#### Returns {/*returns*/}\n\n`useEffect` returns `undefined`.\n\n#### Caveats {/*caveats*/}\n\n`useEffect` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n\nIf you're **not trying to synchronize with some external system,** [you probably don't need an Effect.](/learn/you-might-not-need-an-effect)\n\nWhen Strict Mode is on, React will **run one extra development-only setup+cleanup cycle** before the first real setup. This is a stress-test that ensures that your cleanup logic \"mirrors\" your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, [you need to implement the cleanup function.](/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"333":{"pageContent":"If some of your dependencies are objects or functions defined inside the component, there is a risk that they will **cause the Effect to re-run more often than needed.** To fix this, remove unnecessary [object](#removing-unnecessary-object-dependencies) and [function](#removing-unnecessary-function-dependencies) dependencies. You can also [extract state updates](#updating-state-based-on-previous-state-from-an-effect) and [non-reactive logic](#reading-the-latest-props-and-state-from-an-effect) outside of your Effect.\n\nIf your Effect wasn't caused by an interaction (like a click), React will let the browser **paint the updated screen first before running your Effect.** If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), you need to replace `useEffect` with [`useLayoutEffect`.](/reference/react/useLayoutEffect)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"334":{"pageContent":"Even if your Effect was caused by an interaction (like a click), **the browser may repaint the screen before processing the state updates inside your Effect.** Usually, that's what you want. However, if you must block the browser from repainting the screen, you need to replace `useEffect` with [`useLayoutEffect`.](/reference/react/useLayoutEffect)\n\nEffects **only run on the client.** They don't run during server rendering.\n\n--\n\n## Usage {/*usage*/}\n\n### Connecting to an external system {/*connecting-to-an-external-system*/}\n\nSometimes, your component might need to stay connected to the network, some browser API, or a third-party library, while it is displayed on the page. Such systems aren't controlled by React, so they are called *external.*\n\nTo [connect your component to some external system,](/learn/synchronizing-with-effects) call `useEffect` at the top level of your component:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"335":{"pageContent":"To [connect your component to some external system,](/learn/synchronizing-with-effects) call `useEffect` at the top level of your component:\n\n```js [[1, 8, \"const connection = createConnection(serverUrl, roomId);\"], [1, 9, \"connection.connect();\"], [2, 11, \"connection.disconnect();\"], [3, 13, \"[serverUrl, roomId]\"]]\n\nimport { useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\n// ...\n\n}\n\n```\n\nYou need to pass two arguments to `useEffect`:\n\n1. A *setup function* with <CodeStep step={1}>setup code</CodeStep> that connects to that system.\n\nIt should return a *cleanup function* with <CodeStep step={2}>cleanup code</CodeStep> that disconnects from that system.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"336":{"pageContent":"It should return a *cleanup function* with <CodeStep step={2}>cleanup code</CodeStep> that disconnects from that system.\n\n2. A <CodeStep step={3}>list of dependencies</CodeStep> including every value from your component used inside of those functions.\n\n*React calls your setup and cleanup functions whenever it's necessary, which may happen multiple times:**\n\n1. Your <CodeStep step={1}>setup code</CodeStep> runs when your component is added to the page *(mounts)*.\n\n2. After every re-render of your component where the <CodeStep step={3}>dependencies</CodeStep> have changed:\n\nFirst, your <CodeStep step={2}>cleanup code</CodeStep> runs with the old props and state.\n\nThen, your <CodeStep step={1}>setup code</CodeStep> runs with the new props and state.\n\n3. Your <CodeStep step={2}>cleanup code</CodeStep> runs one final time after your component is removed from the page *(unmounts).*\n\n*Let's illustrate this sequence for the example above.**","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"337":{"pageContent":"3. Your <CodeStep step={2}>cleanup code</CodeStep> runs one final time after your component is removed from the page *(unmounts).*\n\n*Let's illustrate this sequence for the example above.**\n\nWhen the `ChatRoom` component above gets added to the page, it will connect to the chat room with the initial `serverUrl` and `roomId`. If either `serverUrl` or `roomId` change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will *disconnect from the previous room, and connect to the next one.* When the `ChatRoom` component is finally removed from the page, your Effect will disconnect one last time.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"338":{"pageContent":"*To [help you find bugs,](/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) in development React runs <CodeStep step={1}>setup</CodeStep> and <CodeStep step={2}>cleanup</CodeStep> one extra time before the actual <CodeStep step={1}>setup</CodeStep>.** This is a stress-test that verifies your Effect's logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn't be able to distinguish between the setup being called once (as in production) and a *setup* â†’ *cleanup* â†’ *setup* sequence (as in development). [See common solutions.](/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"339":{"pageContent":"*Try to [write every Effect as an independent process](/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process) and [only think about a single setup/cleanup cycle at a time.](/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective)** It shouldn't matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly \"mirrors\" the setup logic, your Effect will be resilient to running setup and cleanup as often as needed.\n\n<Note>\n\nAn Effect lets you [keep your component synchronized](/learn/synchronizing-with-effects) with some external system (like a chat service). Here, *external system* means any piece of code that's not controlled by React, such as:\n\nA timer managed with <CodeStep step={1}>[`setInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval)</CodeStep> and <CodeStep step={2}>[`clearInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval)</CodeStep>.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"340":{"pageContent":"An event subscription using <CodeStep step={1}>[`window.addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)</CodeStep> and <CodeStep step={2}>[`window.removeEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener)</CodeStep>.\n\nA third-party animation library with an API like <CodeStep step={1}>`animation.start()`</CodeStep> and <CodeStep step={2}>`animation.reset()`</CodeStep>.\n\n*If you're not connecting to any external system, [you probably don't need an Effect.](/learn/you-might-not-need-an-effect)**\n\n</Note>\n\n<Recipes titleText=\"Examples of connecting to an external system\" titleId=\"examples-connecting\">\n\n#### Connecting to a chat server {/*connecting-to-a-chat-server*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"341":{"pageContent":"</Note>\n\n<Recipes titleText=\"Examples of connecting to an external system\" titleId=\"examples-connecting\">\n\n#### Connecting to a chat server {/*connecting-to-a-chat-server*/}\n\nIn this example, the `ChatRoom` component uses an Effect to stay connected to an external system defined in `chat.js`. Press \"Open chat\" to make the `ChatRoom` component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as [explained here.](/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) Try changing the `roomId` and `serverUrl` using the dropdown and the input, and see how the Effect re-connects to the chat. Press \"Close chat\" to see the Effect disconnect one last time.\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"342":{"pageContent":"function ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [roomId, serverUrl]);\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}\n\nonChange={e => setServerUrl(e.target.value)}\n\n/>\n\n</label>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"343":{"pageContent":"{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Listening to a global browser event {/*listening-to-a-global-browser-event*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"344":{"pageContent":"}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Listening to a global browser event {/*listening-to-a-global-browser-event*/}\n\nIn this example, the external system is the browser DOM itself. Normally, you'd specify event listeners with JSX, but you can't listen to the global [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) object this way. An Effect lets you connect to the `window` object and listen to its events. Listening to the `pointermove` event lets you track the cursor (or finger) position and update the red dot to move with it.\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nexport default function App() {\n\nconst [position, setPosition] = useState({ x: 0, y: 0 });\n\nuseEffect(() => {\n\nfunction handleMove(e) {\n\nsetPosition({ x: e.clientX, y: e.clientY });\n\n}\n\nwindow.addEventListener('pointermove', handleMove);\n\nreturn () => {\n\nwindow.removeEventListener('pointermove', handleMove);\n\n};\n\n}, []);\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"345":{"pageContent":"setPosition({ x: e.clientX, y: e.clientY });\n\n}\n\nwindow.addEventListener('pointermove', handleMove);\n\nreturn () => {\n\nwindow.removeEventListener('pointermove', handleMove);\n\n};\n\n}, []);\n\nreturn (\n\n<div style={{\n\nposition: 'absolute',\n\nbackgroundColor: 'pink',\n\nborderRadius: '50%',\n\nopacity: 0.6,\n\ntransform: `translate(${position.x}px, ${position.y}px)`,\n\npointerEvents: 'none',\n\nleft: -20,\n\ntop: -20,\n\nwidth: 40,\n\nheight: 40,\n\n}} />\n\n);\n\n}\n\n```\n\n```css\n\nbody {\n\nmin-height: 300px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Triggering an animation {/*triggering-an-animation*/}\n\nIn this example, the external system is the animation library in `animation.js`. It provides a JavaScript class called `FadeInAnimation` that takes a DOM node as an argument and exposes `start()` and `stop()` methods to control the animation. This component [uses a ref](/learn/manipulating-the-dom-with-refs) to access the underlying DOM node. The Effect reads the DOM node from the ref and automatically starts the animation for that node when the component appears.\n\n<Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"346":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useState, useEffect, useRef } from 'react';\n\nimport { FadeInAnimation } from './animation.js';\n\nfunction Welcome() {\n\nconst ref = useRef(null);\n\nuseEffect(() => {\n\nconst animation = new FadeInAnimation(ref.current);\n\nanimation.start(1000);\n\nreturn () => {\n\nanimation.stop();\n\n};\n\n}, []);\n\nreturn (\n\n<h1\n\nref={ref}\n\nstyle={{\n\nopacity: 0,\n\ncolor: 'white',\n\npadding: 50,\n\ntextAlign: 'center',\n\nfontSize: 50,\n\nbackgroundImage: 'radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)'\n\n}}\n\n>\n\nWelcome\n\n</h1>\n\n);\n\n}\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Remove' : 'Show'}\n\n</button>\n\n<hr />\n\n{show && <Welcome />}\n\n</>\n\n);\n\n}\n\n```\n\n```js animation.js\n\nexport class FadeInAnimation {\n\nconstructor(node) {\n\nthis.node = node;\n\n}\n\nstart(duration) {\n\nthis.duration = duration;\n\nif (this.duration === 0) {\n\n// Jump to end immediately\n\nthis.onProgress(1);\n\n} else {\n\nthis.onProgress(0);\n\n// Start animating\n\nthis.startTime = performance.now();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"347":{"pageContent":"}\n\nstart(duration) {\n\nthis.duration = duration;\n\nif (this.duration === 0) {\n\n// Jump to end immediately\n\nthis.onProgress(1);\n\n} else {\n\nthis.onProgress(0);\n\n// Start animating\n\nthis.startTime = performance.now();\n\nthis.frameId = requestAnimationFrame(() => this.onFrame());\n\n}\n\n}\n\nonFrame() {\n\nconst timePassed = performance.now() - this.startTime;\n\nconst progress = Math.min(timePassed / this.duration, 1);\n\nthis.onProgress(progress);\n\nif (progress < 1) {\n\n// We still have more frames to paint\n\nthis.frameId = requestAnimationFrame(() => this.onFrame());\n\n}\n\n}\n\nonProgress(progress) {\n\nthis.node.style.opacity = progress;\n\n}\n\nstop() {\n\ncancelAnimationFrame(this.frameId);\n\nthis.startTime = null;\n\nthis.frameId = null;\n\nthis.duration = 0;\n\n}\n\n}\n\n```\n\n```css\n\nlabel, button { display: block; margin-bottom: 20px; }\n\nhtml, body { min-height: 300px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Controlling a modal dialog {/*controlling-a-modal-dialog*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"348":{"pageContent":"}\n\n}\n\n```\n\n```css\n\nlabel, button { display: block; margin-bottom: 20px; }\n\nhtml, body { min-height: 300px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Controlling a modal dialog {/*controlling-a-modal-dialog*/}\n\nIn this example, the external system is the browser DOM. The `ModalDialog` component renders a [`<dialog>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog) element. It uses an Effect to synchronize the `isOpen` prop to the [`showModal()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal) and [`close()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/close) method calls.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport ModalDialog from './ModalDialog.js';\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setShow(true)}>\n\nOpen dialog\n\n</button>\n\n<ModalDialog isOpen={show}>\n\nHello there!\n\n<br />\n\n<button onClick={() => {\n\nsetShow(false);\n\n}}>Close</button>\n\n</ModalDialog>\n\n</>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"349":{"pageContent":"return (\n\n<>\n\n<button onClick={() => setShow(true)}>\n\nOpen dialog\n\n</button>\n\n<ModalDialog isOpen={show}>\n\nHello there!\n\n<br />\n\n<button onClick={() => {\n\nsetShow(false);\n\n}}>Close</button>\n\n</ModalDialog>\n\n</>\n\n);\n\n}\n\n```\n\n```js ModalDialog.js active\n\nimport { useEffect, useRef } from 'react';\n\nexport default function ModalDialog({ isOpen, children }) {\n\nconst ref = useRef();\n\nuseEffect(() => {\n\nif (!isOpen) {\n\nreturn;\n\n}\n\nconst dialog = ref.current;\n\ndialog.showModal();\n\nreturn () => {\n\ndialog.close();\n\n};\n\n}, [isOpen]);\n\nreturn <dialog ref={ref}>{children}</dialog>;\n\n}\n\n```\n\n```css\n\nbody {\n\nmin-height: 300px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Tracking element visibility {/*tracking-element-visibility*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"350":{"pageContent":"};\n\n}, [isOpen]);\n\nreturn <dialog ref={ref}>{children}</dialog>;\n\n}\n\n```\n\n```css\n\nbody {\n\nmin-height: 300px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Tracking element visibility {/*tracking-element-visibility*/}\n\nIn this example, the external system is again the browser DOM. The `App` component displays a long list, then a `Box` component, and then another long list. Scroll the list down. Notice that when the `Box` component appears in the viewport, the background color changes to black. To implement this, the `Box` component uses an Effect to manage an [`IntersectionObserver`](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API). This browser API notifies you when the DOM element is visible in the viewport.\n\n<Sandpack>\n\n```js\n\nimport Box from './Box.js';\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<LongSection />\n\n<Box />\n\n<LongSection />\n\n<Box />\n\n<LongSection />\n\n</>\n\n);\n\n}\n\nfunction LongSection() {\n\nconst items = [];\n\nfor (let i = 0; i < 50; i++) {\n\nitems.push(<li key={i}>Item #{i} (keep scrolling)</li>);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"351":{"pageContent":"<>\n\n<LongSection />\n\n<Box />\n\n<LongSection />\n\n<Box />\n\n<LongSection />\n\n</>\n\n);\n\n}\n\nfunction LongSection() {\n\nconst items = [];\n\nfor (let i = 0; i < 50; i++) {\n\nitems.push(<li key={i}>Item #{i} (keep scrolling)</li>);\n\n}\n\nreturn <ul>{items}</ul>\n\n}\n\n```\n\n```js Box.js active\n\nimport { useRef, useEffect } from 'react';\n\nexport default function Box() {\n\nconst ref = useRef(null);\n\nuseEffect(() => {\n\nconst div = ref.current;\n\nconst observer = new IntersectionObserver(entries => {\n\nconst entry = entries[0];\n\nif (entry.isIntersecting) {\n\ndocument.body.style.backgroundColor = 'black';\n\ndocument.body.style.color = 'white';\n\n} else {\n\ndocument.body.style.backgroundColor = 'white';\n\ndocument.body.style.color = 'black';\n\n}\n\n});\n\nobserver.observe(div, {\n\nthreshold: 1.0\n\n});\n\nreturn () => {\n\nobserver.disconnect();\n\n}\n\n}, []);\n\nreturn (\n\n<div ref={ref} style={{\n\nmargin: 20,\n\nheight: 100,\n\nwidth: 100,\n\nborder: '2px solid black',\n\nbackgroundColor: 'blue'\n\n}} />\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Wrapping Effects in custom Hooks {/*wrapping-effects-in-custom-hooks*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"352":{"pageContent":"height: 100,\n\nwidth: 100,\n\nborder: '2px solid black',\n\nbackgroundColor: 'blue'\n\n}} />\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Wrapping Effects in custom Hooks {/*wrapping-effects-in-custom-hooks*/}\n\nEffects are an [\"escape hatch\":](/learn/escape-hatches) you use them when you need to \"step outside React\" and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it's usually a sign that you need to extract some [custom Hooks](/learn/reusing-logic-with-custom-hooks) for common behaviors that your components rely on.\n\nFor example, this `useChatRoom` custom Hook \"hides\" the logic of your Effect behind a more declarative API:\n\n```js {1,11}\n\nfunction useChatRoom({ serverUrl, roomId }) {\n\nuseEffect(() => {\n\nconst options = {\n\nserverUrl: serverUrl,\n\nroomId: roomId\n\n};\n\nconst connection = createConnection(options);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId, serverUrl]);\n\n}\n\n```\n\nThen you can use it from any component like this:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"353":{"pageContent":"roomId: roomId\n\n};\n\nconst connection = createConnection(options);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId, serverUrl]);\n\n}\n\n```\n\nThen you can use it from any component like this:\n\n```js {4-7}\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseChatRoom({\n\nroomId: roomId,\n\nserverUrl: serverUrl\n\n});\n\n// ...\n\n````\n\nThere are also many excellent custom Hooks for every purpose available in the React ecosystem.\n\n[Learn more about wrapping Effects in custom Hooks.](/learn/reusing-logic-with-custom-hooks)\n\n<Recipes titleText=\"Examples of wrapping Effects in custom Hooks\" titleId=\"examples-custom-hooks\">\n\n#### Custom `useChatRoom` Hook {/*custom-usechatroom-hook*/}\n\nThis example is identical to one of the [earlier examples,](#examples-connecting) but the logic is extracted to a custom Hook.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport { useChatRoom } from './useChatRoom.js';\n\nfunction ChatRoom({ roomId }) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"354":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport { useChatRoom } from './useChatRoom.js';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseChatRoom({\n\nroomId: roomId,\n\nserverUrl: serverUrl\n\n});\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}\n\nonChange={e => setServerUrl(e.target.value)}\n\n/>\n\n</label>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js useChatRoom.js\n\nimport { useEffect } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"355":{"pageContent":"<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom roomId={roomId} />}\n\n</>\n\n);\n\n}\n\n```\n\n```js useChatRoom.js\n\nimport { useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nexport function useChatRoom({ serverUrl, roomId }) {\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [roomId, serverUrl]);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Custom `useWindowListener` Hook {/*custom-usewindowlistener-hook*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"356":{"pageContent":"}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Custom `useWindowListener` Hook {/*custom-usewindowlistener-hook*/}\n\nThis example is identical to one of the [earlier examples,](#examples-connecting) but the logic is extracted to a custom Hook.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport { useWindowListener } from './useWindowListener.js';\n\nexport default function App() {\n\nconst [position, setPosition] = useState({ x: 0, y: 0 });\n\nuseWindowListener('pointermove', (e) => {\n\nsetPosition({ x: e.clientX, y: e.clientY });\n\n});\n\nreturn (\n\n<div style={{\n\nposition: 'absolute',\n\nbackgroundColor: 'pink',\n\nborderRadius: '50%',\n\nopacity: 0.6,\n\ntransform: `translate(${position.x}px, ${position.y}px)`,\n\npointerEvents: 'none',\n\nleft: -20,\n\ntop: -20,\n\nwidth: 40,\n\nheight: 40,\n\n}} />\n\n);\n\n}\n\n```\n\n```js useWindowListener.js\n\nimport { useState, useEffect } from 'react';\n\nexport function useWindowListener(eventType, listener) {\n\nuseEffect(() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"357":{"pageContent":"left: -20,\n\ntop: -20,\n\nwidth: 40,\n\nheight: 40,\n\n}} />\n\n);\n\n}\n\n```\n\n```js useWindowListener.js\n\nimport { useState, useEffect } from 'react';\n\nexport function useWindowListener(eventType, listener) {\n\nuseEffect(() => {\n\nwindow.addEventListener(eventType, listener);\n\nreturn () => {\n\nwindow.removeEventListener(eventType, listener);\n\n};\n\n}, [eventType, listener]);\n\n}\n\n```\n\n```css\n\nbody {\n\nmin-height: 300px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Custom `useIntersectionObserver` Hook {/*custom-useintersectionobserver-hook*/}\n\nThis example is identical to one of the [earlier examples,](#examples-connecting) but the logic is partially extracted to a custom Hook.\n\n<Sandpack>\n\n```js\n\nimport Box from './Box.js';\n\nexport default function App() {\n\nreturn (\n\n<>\n\n<LongSection />\n\n<Box />\n\n<LongSection />\n\n<Box />\n\n<LongSection />\n\n</>\n\n);\n\n}\n\nfunction LongSection() {\n\nconst items = [];\n\nfor (let i = 0; i < 50; i++) {\n\nitems.push(<li key={i}>Item #{i} (keep scrolling)</li>);\n\n}\n\nreturn <ul>{items}</ul>\n\n}\n\n```\n\n```js Box.js active\n\nimport { useRef, useEffect } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"358":{"pageContent":"const items = [];\n\nfor (let i = 0; i < 50; i++) {\n\nitems.push(<li key={i}>Item #{i} (keep scrolling)</li>);\n\n}\n\nreturn <ul>{items}</ul>\n\n}\n\n```\n\n```js Box.js active\n\nimport { useRef, useEffect } from 'react';\n\nimport { useIntersectionObserver } from './useIntersectionObserver.js';\n\nexport default function Box() {\n\nconst ref = useRef(null);\n\nconst isIntersecting = useIntersectionObserver(ref);\n\nuseEffect(() => {\n\nif (isIntersecting) {\n\ndocument.body.style.backgroundColor = 'black';\n\ndocument.body.style.color = 'white';\n\n} else {\n\ndocument.body.style.backgroundColor = 'white';\n\ndocument.body.style.color = 'black';\n\n}\n\n}, [isIntersecting]);\n\nreturn (\n\n<div ref={ref} style={{\n\nmargin: 20,\n\nheight: 100,\n\nwidth: 100,\n\nborder: '2px solid black',\n\nbackgroundColor: 'blue'\n\n}} />\n\n);\n\n}\n\n```\n\n```js useIntersectionObserver.js\n\nimport { useState, useEffect } from 'react';\n\nexport function useIntersectionObserver(ref) {\n\nconst [isIntersecting, setIsIntersecting] = useState(false);\n\nuseEffect(() => {\n\nconst div = ref.current;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"359":{"pageContent":"import { useState, useEffect } from 'react';\n\nexport function useIntersectionObserver(ref) {\n\nconst [isIntersecting, setIsIntersecting] = useState(false);\n\nuseEffect(() => {\n\nconst div = ref.current;\n\nconst observer = new IntersectionObserver(entries => {\n\nconst entry = entries[0];\n\nsetIsIntersecting(entry.isIntersecting);\n\n});\n\nobserver.observe(div, {\n\nthreshold: 1.0\n\n});\n\nreturn () => {\n\nobserver.disconnect();\n\n}\n\n}, [ref]);\n\nreturn isIntersecting;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Controlling a non-React widget {/*controlling-a-non-react-widget*/}\n\nSometimes, you want to keep an external system synchronized to some prop or state of your component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"360":{"pageContent":"<Solution />\n\n</Recipes>\n\n--\n\n### Controlling a non-React widget {/*controlling-a-non-react-widget*/}\n\nSometimes, you want to keep an external system synchronized to some prop or state of your component.\n\nFor example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a `MapWidget` class defined in `map-widget.js`. When you change the `zoomLevel` prop of the `Map` component, the Effect calls the `setZoom()` on the class instance to keep it synchronized:\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"leaflet\": \"1.9.1\",\n\n\"react\": \"latest\",\n\n\"react-dom\": \"latest\",\n\n\"react-scripts\": \"latest\",\n\n\"remarkable\": \"2.0.1\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { useState } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"361":{"pageContent":"},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport Map from './Map.js';\n\nexport default function App() {\n\nconst [zoomLevel, setZoomLevel] = useState(0);\n\nreturn (\n\n<>\n\nZoom level: {zoomLevel}x\n\n<button onClick={() => setZoomLevel(zoomLevel + 1)}>+</button>\n\n<button onClick={() => setZoomLevel(zoomLevel - 1)}>-</button>\n\n<hr />\n\n<Map zoomLevel={zoomLevel} />\n\n</>\n\n);\n\n}\n\n```\n\n```js Map.js active\n\nimport { useRef, useEffect } from 'react';\n\nimport { MapWidget } from './map-widget.js';\n\nexport default function Map({ zoomLevel }) {\n\nconst containerRef = useRef(null);\n\nconst mapRef = useRef(null);\n\nuseEffect(() => {\n\nif (mapRef.current === null) {\n\nmapRef.current = new MapWidget(containerRef.current);\n\n}\n\nconst map = mapRef.current;\n\nmap.setZoom(zoomLevel);\n\n}, [zoomLevel]);\n\nreturn (\n\n<div\n\nstyle={{ width: 200, height: 200 }}\n\nref={containerRef}\n\n/>\n\n);\n\n}\n\n```\n\n```js map-widget.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"362":{"pageContent":"}\n\nconst map = mapRef.current;\n\nmap.setZoom(zoomLevel);\n\n}, [zoomLevel]);\n\nreturn (\n\n<div\n\nstyle={{ width: 200, height: 200 }}\n\nref={containerRef}\n\n/>\n\n);\n\n}\n\n```\n\n```js map-widget.js\n\nimport 'leaflet/dist/leaflet.css';\n\nimport * as L from 'leaflet';\n\nexport class MapWidget {\n\nconstructor(domNode) {\n\nthis.map = L.map(domNode, {\n\nzoomControl: false,\n\ndoubleClickZoom: false,\n\nboxZoom: false,\n\nkeyboard: false,\n\nscrollWheelZoom: false,\n\nzoomAnimation: false,\n\ntouchZoom: false,\n\nzoomSnap: 0.1\n\n});\n\nL.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {\n\nmaxZoom: 19,\n\nattribution: 'Â© OpenStreetMap'\n\n}).addTo(this.map);\n\nthis.map.setView([0, 0], 0);\n\n}\n\nsetZoom(level) {\n\nthis.map.setZoom(level);\n\n}\n\n}\n\n```\n\n```css\n\nbutton { margin: 5px; }\n\n```\n\n</Sandpack>\n\nIn this example, a cleanup function is not needed because the `MapWidget` class manages only the DOM node that was passed to it. After the `Map` React component is removed from the tree, both the DOM node and the `MapWidget` class instance will be automatically garbage-collected by the browser JavaScript engine.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"363":{"pageContent":"--\n\n### Fetching data with Effects {/*fetching-data-with-effects*/}\n\nYou can use an Effect to fetch data for your component. Note that [if you use a framework,](/learn/start-a-new-react-project#building-with-a-full-featured-framework) using your framework's data fetching mechanism will be a lot more efficient than writing Effects manually.\n\nIf you want to fetch data from an Effect manually, your code might look like this:\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n\nconst [person, setPerson] = useState('Alice');\n\nconst [bio, setBio] = useState(null);\n\nuseEffect(() => {\n\nlet ignore = false;\n\nsetBio(null);\n\nfetchBio(person).then(result => {\n\nif (!ignore) {\n\nsetBio(result);\n\n}\n\n});\n\nreturn () => {\n\nignore = true;\n\n};\n\n}, [person]);\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"364":{"pageContent":"useEffect(() => {\n\nlet ignore = false;\n\nsetBio(null);\n\nfetchBio(person).then(result => {\n\nif (!ignore) {\n\nsetBio(result);\n\n}\n\n});\n\nreturn () => {\n\nignore = true;\n\n};\n\n}, [person]);\n\n// ...\n\n```\n\nNote the `ignore` variable which is initialized to `false`, and is set to `true` during cleanup. This ensures [your code doesn't suffer from \"race conditions\":](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect) network responses may arrive in a different order than you sent them.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState, useEffect } from 'react';\n\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n\nconst [person, setPerson] = useState('Alice');\n\nconst [bio, setBio] = useState(null);\n\nuseEffect(() => {\n\nlet ignore = false;\n\nsetBio(null);\n\nfetchBio(person).then(result => {\n\nif (!ignore) {\n\nsetBio(result);\n\n}\n\n});\n\nreturn () => {\n\nignore = true;\n\n}\n\n}, [person]);\n\nreturn (\n\n<>\n\n<select value={person} onChange={e => {\n\nsetPerson(e.target.value);\n\n}}>\n\n<option value=\"Alice\">Alice</option>\n\n<option value=\"Bob\">Bob</option>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"365":{"pageContent":"}\n\n});\n\nreturn () => {\n\nignore = true;\n\n}\n\n}, [person]);\n\nreturn (\n\n<>\n\n<select value={person} onChange={e => {\n\nsetPerson(e.target.value);\n\n}}>\n\n<option value=\"Alice\">Alice</option>\n\n<option value=\"Bob\">Bob</option>\n\n<option value=\"Taylor\">Taylor</option>\n\n</select>\n\n<hr />\n\n<p><i>{bio ?? 'Loading...'}</i></p>\n\n</>\n\n);\n\n}\n\n```\n\n```js api.js hidden\n\nexport async function fetchBio(person) {\n\nconst delay = person === 'Bob' ? 2000 : 200;\n\nreturn new Promise(resolve => {\n\nsetTimeout(() => {\n\nresolve('This is ' + person + 'â€™s bio.');\n\n}, delay);\n\n})\n\n}\n\n```\n\n</Sandpack>\n\nYou can also rewrite using the [`async` / `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) syntax, but you still need to provide a cleanup function:\n\n<Sandpack>\n\n```js App.js\n\nimport { useState, useEffect } from 'react';\n\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n\nconst [person, setPerson] = useState('Alice');\n\nconst [bio, setBio] = useState(null);\n\nuseEffect(() => {\n\nasync function startFetching() {\n\nsetBio(null);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"366":{"pageContent":"export default function Page() {\n\nconst [person, setPerson] = useState('Alice');\n\nconst [bio, setBio] = useState(null);\n\nuseEffect(() => {\n\nasync function startFetching() {\n\nsetBio(null);\n\nconst result = await fetchBio(person);\n\nif (!ignore) {\n\nsetBio(result);\n\n}\n\n}\n\nlet ignore = false;\n\nstartFetching();\n\nreturn () => {\n\nignore = true;\n\n}\n\n}, [person]);\n\nreturn (\n\n<>\n\n<select value={person} onChange={e => {\n\nsetPerson(e.target.value);\n\n}}>\n\n<option value=\"Alice\">Alice</option>\n\n<option value=\"Bob\">Bob</option>\n\n<option value=\"Taylor\">Taylor</option>\n\n</select>\n\n<hr />\n\n<p><i>{bio ?? 'Loading...'}</i></p>\n\n</>\n\n);\n\n}\n\n```\n\n```js api.js hidden\n\nexport async function fetchBio(person) {\n\nconst delay = person === 'Bob' ? 2000 : 200;\n\nreturn new Promise(resolve => {\n\nsetTimeout(() => {\n\nresolve('This is ' + person + 'â€™s bio.');\n\n}, delay);\n\n})\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"367":{"pageContent":"const delay = person === 'Bob' ? 2000 : 200;\n\nreturn new Promise(resolve => {\n\nsetTimeout(() => {\n\nresolve('This is ' + person + 'â€™s bio.');\n\n}, delay);\n\n})\n\n}\n\n```\n\n</Sandpack>\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. [It's easier to use a custom Hook--either your own or maintained by the community.](/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks)\n\n<DeepDive>\n\n#### What are good alternatives to data fetching in Effects? {/*what-are-good-alternatives-to-data-fetching-in-effects*/}\n\nWriting `fetch` calls inside Effects is a [popular way to fetch data](https://www.robinwieruch.de/react-hooks-fetch-data/), especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"368":{"pageContent":"**Effects don't run on the server.** This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n\n**Fetching directly in Effects makes it easy to create \"network waterfalls\".** You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n\n**Fetching directly in Effects usually means you don't preload or cache data.** For example, if the component unmounts and then mounts again, it would have to fetch the data again.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"369":{"pageContent":"**Fetching directly in Effects usually means you don't preload or cache data.** For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n\n**It's not very ergonomic.** There's quite a bit of boilerplate code involved when writing `fetch` calls in a way that doesn't suffer from bugs like [race conditions.](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)\n\nThis list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n\n**If you use a [framework](/learn/start-a-new-react-project#building-with-a-full-featured-framework), use its built-in data fetching mechanism.** Modern React frameworks have integrated data fetching mechanisms that are efficient and don't suffer from the above pitfalls.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"370":{"pageContent":"**Otherwise, consider using or building a client-side cache.** Popular open source solutions include [React Query](https://react-query.tanstack.com/), [useSWR](https://swr.vercel.app/), and [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview) You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).\n\nYou can continue fetching data directly in Effects if neither of these approaches suit you.\n\n</DeepDive>\n\n--\n\n### Specifying reactive dependencies {/*specifying-reactive-dependencies*/}\n\n*Notice that you can't \"choose\" the dependencies of your Effect.** Every <CodeStep step={2}>reactive value</CodeStep> used by your Effect's code must be declared as a dependency. Your Effect's dependency list is determined by the surrounding code:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"371":{"pageContent":"```js [[2, 1, \"roomId\"], [2, 2, \"serverUrl\"], [2, 5, \"serverUrl\"], [2, 5, \"roomId\"], [2, 8, \"serverUrl\"], [2, 8, \"roomId\"]]\n\nfunction ChatRoom({ roomId }) { // This is a reactive value\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [serverUrl, roomId]); // âœ… So you must specify them as dependencies of your Effect\n\n// ...\n\n}\n\n```\n\nIf either `serverUrl` or `roomId` change, your Effect will reconnect to the chat using the new values.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"372":{"pageContent":"}, [serverUrl, roomId]); // âœ… So you must specify them as dependencies of your Effect\n\n// ...\n\n}\n\n```\n\nIf either `serverUrl` or `roomId` change, your Effect will reconnect to the chat using the new values.\n\n*[Reactive values](/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) include props and all variables and functions declared directly inside of your component.** Since `roomId` and `serverUrl` are reactive values, you can't remove them from the dependency list. If you try to omit them and [your linter is correctly configured for React,](/learn/editor-setup#linting) the linter will flag this as a mistake that you need to fix:\n\n```js {8}\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, []); // ðŸ”´ React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"373":{"pageContent":"connection.connect();\n\nreturn () => connection.disconnect();\n\n}, []); // ðŸ”´ React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'\n\n// ...\n\n}\n\n```\n\n*To remove a dependency, you need to [\"prove\" to the linter that it *doesn't need* to be a dependency.](/learn/removing-effect-dependencies#removing-unnecessary-dependencies)** For example, you can move `serverUrl` out of your component to prove that it's not reactive and won't change on re-renders:\n\n```js {1,8}\n\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymore\n\nfunction ChatRoom({ roomId }) {\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]); // âœ… All dependencies declared\n\n// ...\n\n}\n\n```\n\nNow that `serverUrl` is not a reactive value (and can't change on a re-render), it doesn't need to be a dependency. **If your Effect's code doesn't use any reactive values, its dependency list should be empty (`[]`):**\n\n```js {1,2,9}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"374":{"pageContent":"```js {1,2,9}\n\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymore\n\nconst roomId = 'music'; // Not a reactive value anymore\n\nfunction ChatRoom() {\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, []); // âœ… All dependencies declared\n\n// ...\n\n}\n\n```\n\n[An Effect with empty dependencies](/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means) doesn't re-run when any of your component's props or state change.\n\n<Pitfall>\n\nIf you have an existing codebase, you might have some Effects that suppress the linter like this:\n\n```js {3-4}\n\nuseEffect(() => {\n\n// ...\n\n// ðŸ”´ Avoid suppressing the linter like this:\n\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n\n}, []);\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"375":{"pageContent":"```js {3-4}\n\nuseEffect(() => {\n\n// ...\n\n// ðŸ”´ Avoid suppressing the linter like this:\n\n// eslint-ignore-next-line react-hooks/exhaustive-deps\n\n}, []);\n\n```\n\n*When dependencies don't match the code, there is a high risk of introducing bugs.** By suppressing the linter, you \"lie\" to React about the values your Effect depends on. [Instead, prove they're unnecessary.](/learn/removing-effect-dependencies#removing-unnecessary-dependencies)\n\n</Pitfall>\n\n<Recipes titleText=\"Examples of passing reactive dependencies\" titleId=\"examples-dependencies\">\n\n#### Passing a dependency array {/*passing-a-dependency-array*/}\n\nIf you specify the dependencies, your Effect runs **after the initial render _and_ after re-renders with changed dependencies.**\n\n```js {3}\n\nuseEffect(() => {\n\n// ...\n\n}, [a, b]); // Runs again if a or b are different\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"376":{"pageContent":"```js {3}\n\nuseEffect(() => {\n\n// ...\n\n}, [a, b]); // Runs again if a or b are different\n\n```\n\nIn the below example, `serverUrl` and `roomId` are [reactive values,](/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since `message` isn't used in the Effect (and so it isn't a dependency), editing the message doesn't re-connect to the chat.\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nconst [message, setMessage] = useState('');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"377":{"pageContent":"const connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}\n\nonChange={e => setServerUrl(e.target.value)}\n\n/>\n\n</label>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n<label>\n\nYour message:{' '}\n\n<input value={message} onChange={e => setMessage(e.target.value)} />\n\n</label>\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nconst [roomId, setRoomId] = useState('general');\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n</label>\n\n{show && <hr />}\n\n{show && <ChatRoom />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"378":{"pageContent":"{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n</label>\n\n{show && <hr />}\n\n{show && <ChatRoom />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { margin-bottom: 10px; }\n\nbutton { margin-left: 5px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Passing an empty dependency array {/*passing-an-empty-dependency-array*/}\n\nIf your Effect truly doesn't use any reactive values, it will only run **after the initial render.**\n\n```js {3}\n\nuseEffect(() => {\n\n// ...\n\n}, []); // Does not run again (except once in development)\n\n```\n\n*Even with empty dependencies, setup and cleanup will [run one extra time in development](/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development) to help you find bugs.**","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"379":{"pageContent":"In this example, both `serverUrl` and `roomId` are hardcoded. Since they're declared outside the component, they are not reactive values, and so they aren't dependencies. The dependency list is empty, so the Effect doesn't re-run on re-renders.\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nconst roomId = 'music';\n\nfunction ChatRoom() {\n\nconst [message, setMessage] = useState('');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, []);\n\nreturn (\n\n<>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n<label>\n\nYour message:{' '}\n\n<input value={message} onChange={e => setMessage(e.target.value)} />\n\n</label>\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"380":{"pageContent":"const [show, setShow] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n{show && <hr />}\n\n{show && <ChatRoom />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Passing no dependency array at all {/*passing-no-dependency-array-at-all*/}\n\nIf you pass no dependency array at all, your Effect runs **after every single render (and re-render)** of your component.\n\n```js {3}\n\nuseEffect(() => {\n\n// ...\n\n}); // Always runs again\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"381":{"pageContent":"If you pass no dependency array at all, your Effect runs **after every single render (and re-render)** of your component.\n\n```js {3}\n\nuseEffect(() => {\n\n// ...\n\n}); // Always runs again\n\n```\n\nIn this example, the Effect re-runs when you change `serverUrl` and `roomId`, which is sensible. However, it *also* re-runs when you change the `message`, which is probably undesirable. This is why usually you'll specify the dependency array.\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\nconst [message, setMessage] = useState('');\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}); // No dependency array at all\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}\n\nonChange={e => setServerUrl(e.target.value)}\n\n/>\n\n</label>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n<label>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"382":{"pageContent":"};\n\n}); // No dependency array at all\n\nreturn (\n\n<>\n\n<label>\n\nServer URL:{' '}\n\n<input\n\nvalue={serverUrl}\n\nonChange={e => setServerUrl(e.target.value)}\n\n/>\n\n</label>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n<label>\n\nYour message:{' '}\n\n<input value={message} onChange={e => setMessage(e.target.value)} />\n\n</label>\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nconst [roomId, setRoomId] = useState('general');\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n<button onClick={() => setShow(!show)}>\n\n{show ? 'Close chat' : 'Open chat'}\n\n</button>\n\n</label>\n\n{show && <hr />}\n\n{show && <ChatRoom />}\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection(serverUrl, roomId) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"383":{"pageContent":"// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { margin-bottom: 10px; }\n\nbutton { margin-left: 5px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Updating state based on previous state from an Effect {/*updating-state-based-on-previous-state-from-an-effect*/}\n\nWhen you want to update state based on previous state from an Effect, you might run into a problem:\n\n```js {6,9}\n\nfunction Counter() {\n\nconst [count, setCount] = useState(0);\n\nuseEffect(() => {\n\nconst intervalId = setInterval(() => {\n\nsetCount(count + 1); // You want to increment the counter every second...\n\n}, 1000)\n\nreturn () => clearInterval(intervalId);\n\n}, [count]); // ðŸš© ... but specifying `count` as a dependency always resets the interval.\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"384":{"pageContent":"}, 1000)\n\nreturn () => clearInterval(intervalId);\n\n}, [count]); // ðŸš© ... but specifying `count` as a dependency always resets the interval.\n\n// ...\n\n}\n\n```\n\nSince `count` is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the `count` changes. This is not ideal.\n\nTo fix this, [pass the `c => c + 1` state updater](/reference/react/useState#updating-state-based-on-the-previous-state) to `setCount`:\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nexport default function Counter() {\n\nconst [count, setCount] = useState(0);\n\nuseEffect(() => {\n\nconst intervalId = setInterval(() => {\n\nsetCount(c => c + 1); // âœ… Pass a state updater\n\n}, 1000);\n\nreturn () => clearInterval(intervalId);\n\n}, []); // âœ… Now count is not a dependency\n\nreturn <h1>{count}</h1>;\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 20px;\n\nmargin-bottom: 20px;\n\n}\n\nbody {\n\nmin-height: 150px;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"385":{"pageContent":"}, []); // âœ… Now count is not a dependency\n\nreturn <h1>{count}</h1>;\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 20px;\n\nmargin-bottom: 20px;\n\n}\n\nbody {\n\nmin-height: 150px;\n\n}\n\n```\n\n</Sandpack>\n\nNow that you're passing `c => c + 1` instead of `count + 1`, [your Effect no longer needs to depend on `count`.](/learn/removing-effect-dependencies#are-you-reading-some-state-to-calculate-the-next-state) As a result of this fix, it won't need to cleanup and setup the interval again every time the `count` changes.\n\n--\n\n### Removing unnecessary object dependencies {/*removing-unnecessary-object-dependencies*/}\n\nIf your Effect depends on an object or a function created during rendering, it might run more often than needed. For example, this Effect re-connects after every render because the `options` object is [different for every render:](/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally)\n\n```js {6-9,12,15}\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"386":{"pageContent":"```js {6-9,12,15}\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nconst options = { // ðŸš© This object is created from scratch on every re-render\n\nserverUrl: serverUrl,\n\nroomId: roomId\n\n};\n\nuseEffect(() => {\n\nconst connection = createConnection(options); // It's used inside the Effect\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [options]); // ðŸš© As a result, these dependencies are always different on a re-render\n\n// ...\n\n```\n\nAvoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nuseEffect(() => {\n\nconst options = {\n\nserverUrl: serverUrl,\n\nroomId: roomId\n\n};\n\nconst connection = createConnection(options);\n\nconnection.connect();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"387":{"pageContent":"const [message, setMessage] = useState('');\n\nuseEffect(() => {\n\nconst options = {\n\nserverUrl: serverUrl,\n\nroomId: roomId\n\n};\n\nconst connection = createConnection(options);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\nreturn (\n\n<>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n<input value={message} onChange={e => setMessage(e.target.value)} />\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<hr />\n\n<ChatRoom roomId={roomId} />\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection({ serverUrl, roomId }) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"388":{"pageContent":"// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nNow that you create the `options` object inside the Effect, the Effect itself only depends on the `roomId` string.\n\nWith this fix, typing into the input doesn't reconnect the chat. Unlike an object which gets re-created, a string like `roomId` doesn't change unless you set it to another value. [Read more about removing dependencies.](/learn/removing-effect-dependencies)\n\n--\n\n### Removing unnecessary function dependencies {/*removing-unnecessary-function-dependencies*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"389":{"pageContent":"--\n\n### Removing unnecessary function dependencies {/*removing-unnecessary-function-dependencies*/}\n\nIf your Effect depends on an object or a function created during rendering, it might run more often than needed. For example, this Effect re-connects after every render because the `createOptions` function is [different for every render:](/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally)\n\n```js {4-9,12,16}\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nfunction createOptions() { // ðŸš© This function is created from scratch on every re-render\n\nreturn {\n\nserverUrl: serverUrl,\n\nroomId: roomId\n\n};\n\n}\n\nuseEffect(() => {\n\nconst options = createOptions(); // It's used inside the Effect\n\nconst connection = createConnection();\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [createOptions]); // ðŸš© As a result, these dependencies are always different on a re-render\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"390":{"pageContent":"const connection = createConnection();\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [createOptions]); // ðŸš© As a result, these dependencies are always different on a re-render\n\n// ...\n\n```\n\nBy itself, creating a function from scratch on every re-render is not a problem. You don't need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.\n\nAvoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:\n\n<Sandpack>\n\n```js\n\nimport { useState, useEffect } from 'react';\n\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n\nconst [message, setMessage] = useState('');\n\nuseEffect(() => {\n\nfunction createOptions() {\n\nreturn {\n\nserverUrl: serverUrl,\n\nroomId: roomId\n\n};\n\n}\n\nconst options = createOptions();\n\nconst connection = createConnection(options);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\nreturn (\n\n<>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"391":{"pageContent":"serverUrl: serverUrl,\n\nroomId: roomId\n\n};\n\n}\n\nconst options = createOptions();\n\nconst connection = createConnection(options);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\nreturn (\n\n<>\n\n<h1>Welcome to the {roomId} room!</h1>\n\n<input value={message} onChange={e => setMessage(e.target.value)} />\n\n</>\n\n);\n\n}\n\nexport default function App() {\n\nconst [roomId, setRoomId] = useState('general');\n\nreturn (\n\n<>\n\n<label>\n\nChoose the chat room:{' '}\n\n<select\n\nvalue={roomId}\n\nonChange={e => setRoomId(e.target.value)}\n\n>\n\n<option value=\"general\">general</option>\n\n<option value=\"travel\">travel</option>\n\n<option value=\"music\">music</option>\n\n</select>\n\n</label>\n\n<hr />\n\n<ChatRoom roomId={roomId} />\n\n</>\n\n);\n\n}\n\n```\n\n```js chat.js\n\nexport function createConnection({ serverUrl, roomId }) {\n\n// A real implementation would actually connect to the server\n\nreturn {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"392":{"pageContent":"return {\n\nconnect() {\n\nconsole.log('âœ… Connecting to \"' + roomId + '\" room at ' + serverUrl + '...');\n\n},\n\ndisconnect() {\n\nconsole.log('âŒ Disconnected from \"' + roomId + '\" room at ' + serverUrl);\n\n}\n\n};\n\n}\n\n```\n\n```css\n\ninput { display: block; margin-bottom: 20px; }\n\nbutton { margin-left: 10px; }\n\n```\n\n</Sandpack>\n\nNow that you define the `createOptions` function inside the Effect, the Effect itself only depends on the `roomId` string. With this fix, typing into the input doesn't reconnect the chat. Unlike a function which gets re-created, a string like `roomId` doesn't change unless you set it to another value. [Read more about removing dependencies.](/learn/removing-effect-dependencies)\n\n--\n\n### Reading the latest props and state from an Effect {/*reading-the-latest-props-and-state-from-an-effect*/}\n\n<Wip>\n\nThis section describes an **experimental API that has not yet been added to React,** so you can't use it yet.\n\n</Wip>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"393":{"pageContent":"<Wip>\n\nThis section describes an **experimental API that has not yet been added to React,** so you can't use it yet.\n\n</Wip>\n\nBy default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect \"reacts\" to every change of that value. For most dependencies, that's the behavior you want.\n\n*However, sometimes you'll want to read the *latest* props and state from an Effect without \"reacting\" to them.** For example, imagine you want to log the number of the items in the shopping cart for every page visit:\n\n```js {3}\n\nfunction Page({ url, shoppingCart }) {\n\nuseEffect(() => {\n\nlogVisit(url, shoppingCart.length);\n\n}, [url, shoppingCart]); // âœ… All dependencies declared\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"394":{"pageContent":"```js {3}\n\nfunction Page({ url, shoppingCart }) {\n\nuseEffect(() => {\n\nlogVisit(url, shoppingCart.length);\n\n}, [url, shoppingCart]); // âœ… All dependencies declared\n\n// ...\n\n}\n\n```\n\n*What if you want to log a new page visit after every `url` change, but *not* if only the `shoppingCart` changes?** You can't exclude `shoppingCart` from dependencies without breaking the [reactivity rules.](#specifying-reactive-dependencies) However, you can express that you *don't want* a piece of code to \"react\" to changes even though it is called from inside an Effect. [Declare an *Effect Event*](/learn/separating-events-from-effects#declaring-an-effect-event) with the [`useEffectEvent`](/reference/react/useEffectEvent) Hook, and move the code that reads `shoppingCart` inside of it:\n\n```js {2-4,7,8}\n\nfunction Page({ url, shoppingCart }) {\n\nconst onVisit = useEffectEvent(visitedUrl => {\n\nlogVisit(visitedUrl, shoppingCart.length)\n\n});\n\nuseEffect(() => {\n\nonVisit(url);\n\n}, [url]); // âœ… All dependencies declared\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"395":{"pageContent":"const onVisit = useEffectEvent(visitedUrl => {\n\nlogVisit(visitedUrl, shoppingCart.length)\n\n});\n\nuseEffect(() => {\n\nonVisit(url);\n\n}, [url]); // âœ… All dependencies declared\n\n// ...\n\n}\n\n```\n\n*Effect Events are not reactive and must always be omitted from dependencies of your Effect.** This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. For example, by reading `shoppingCart` inside of `onVisit`, you ensure that `shoppingCart` won't re-run your Effect. In the future, the linter will support `useEffectEvent` and check that you omit Effect Events from dependencies.\n\n[Read more about how Effect Events let you separate reactive and non-reactive code.](/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events)\n\n--\n\n### Displaying different content on the server and the client {/*displaying-different-content-on-the-server-and-the-client*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"396":{"pageContent":"--\n\n### Displaying different content on the server and the client {/*displaying-different-content-on-the-server-and-the-client*/}\n\nIf your app uses server rendering (either [directly](/reference/react-dom/server) or via a [framework](/learn/start-a-new-react-project#building-with-a-full-featured-framework)), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for [hydration](/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html) to work, your initial render output must be identical on the client and the server.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"397":{"pageContent":"In rare cases, you might need to display different content on the client. For example, if your app reads some data from [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage), it can't possibly do that on the server. Here is how you would typically implement this:\n\n```js\n\nfunction MyComponent() {\n\nconst [didMount, setDidMount] = useState(false);\n\nuseEffect(() => {\n\nsetDidMount(true);\n\n}, []);\n\nif (didMount) {\n\n// ... return client-only JSX ...\n\n}  else {\n\n// ... return initial JSX ...\n\n}\n\n}\n\n```\n\nWhile the app is loading, the user will see the initial render output. Then, when it's loaded and hydrated, your Effect will run and set `didMount` to `true`, triggering a re-render. This will switch to the client-only render output. Note that Effects don't run on the server, so this is why `didMount` was `false` during the initial server render.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"398":{"pageContent":"Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time--potentially, many seconds--so you don't want to make jarring changes to your component's appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### My Effect runs twice when the component mounts {/*my-effect-runs-twice-when-the-component-mounts*/}\n\nWhen Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"399":{"pageContent":"When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.\n\nThis is a stress-test that verifies your Effectâ€™s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldnâ€™t be able to distinguish between the setup being called once (as in production) and a setup â†’ cleanup â†’ setup sequence (as in development).\n\nRead more about [how this helps find bugs](/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) and [how to fix your logic.](/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)\n\n--\n\n### My Effect runs after every re-render {/*my-effect-runs-after-every-re-render*/}\n\nFirst, check that you haven't forgotten to specify the dependency array:\n\n```js {3}\n\nuseEffect(() => {\n\n// ...\n\n}); // ðŸš© No dependency array: re-runs after every render!","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"400":{"pageContent":"First, check that you haven't forgotten to specify the dependency array:\n\n```js {3}\n\nuseEffect(() => {\n\n// ...\n\n}); // ðŸš© No dependency array: re-runs after every render!\n\n```\n\nIf you've specified the dependency array but your Effect still re-runs in a loop, it's because one of your dependencies is different on every re-render.\n\nYou can debug this problem by manually logging your dependencies to the console:\n\n```js {5}\n\nuseEffect(() => {\n\n// ..\n\n}, [serverUrl, roomId]);\n\nconsole.log([serverUrl, roomId]);\n\n```\n\nYou can then right-click on the arrays from different re-renders in the console and select \"Store as a global variable\" for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:\n\n```js\n\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\n\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"401":{"pageContent":"```js\n\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\n\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\n\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n\n```\n\nWhen you find the dependency that is different on every re-render, you can usually fix it in one of these ways:\n\n[Updating state based on previous state from an Effect](#updating-state-based-on-previous-state-from-an-effect)\n\n[Removing unnecessary object dependencies](#removing-unnecessary-object-dependencies)\n\n[Removing unnecessary function dependencies](#removing-unnecessary-function-dependencies)\n\n[Reading the latest props and state from an Effect](#reading-the-latest-props-and-state-from-an-effect)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"402":{"pageContent":"[Removing unnecessary function dependencies](#removing-unnecessary-function-dependencies)\n\n[Reading the latest props and state from an Effect](#reading-the-latest-props-and-state-from-an-effect)\n\nAs a last resort (if these methods didn't help), wrap its creation with [`useMemo`](/reference/react/useMemo#memoizing-a-dependency-of-another-hook) or [`useCallback`](/reference/react/useCallback#preventing-an-effect-from-firing-too-often) (for functions).\n\n--\n\n### My Effect keeps re-running in an infinite cycle {/*my-effect-keeps-re-running-in-an-infinite-cycle*/}\n\nIf your Effect runs in an infinite cycle, these two things must be true:\n\nYour Effect is updating some state.\n\nThat state leads to a re-render, which causes the Effect's dependencies to change.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"403":{"pageContent":"If your Effect runs in an infinite cycle, these two things must be true:\n\nYour Effect is updating some state.\n\nThat state leads to a re-render, which causes the Effect's dependencies to change.\n\nBefore you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize some state with that external system? Or are you trying to manage your application's data flow with it?\n\nIf there is no external system, consider whether [removing the Effect altogether](/learn/you-might-not-need-an-effect) would simplify your logic.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"404":{"pageContent":"If there is no external system, consider whether [removing the Effect altogether](/learn/you-might-not-need-an-effect) would simplify your logic.\n\nIf you're genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component's visual output? If you need to keep track of some data that isn't used by rendering, a [ref](/reference/react/useRef#referencing-a-value-with-a-ref) (which doesn't trigger re-renders) might be more appropriate. Verify your Effect doesn't update the state (and trigger re-renders) more than needed.\n\nFinally, if your Effect is updating the state at the right time, but there is still a loop, it's because that state update leads to one of your Effect's dependencies changing. [Read how to debug and resolve dependency changes.](/reference/react/useEffect#my-effect-runs-after-every-re-render)\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"405":{"pageContent":"--\n\n### My cleanup logic runs even though my component didn't unmount {/*my-cleanup-logic-runs-even-though-my-component-didnt-unmount*/}\n\nThe cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React [runs setup+cleanup one extra time immediately after component mounts.](#my-effect-runs-twice-when-the-component-mounts)\n\nIf you have cleanup code without corresponding setup code, it's usually a code smell:\n\n```js {2-5}\n\nuseEffect(() => {\n\n// ðŸ”´ Avoid: Cleanup logic without corresponding setup logic\n\nreturn () => {\n\ndoSomething();\n\n};\n\n}, []);\n\n```\n\nYour cleanup logic should be \"symmetrical\" to the setup logic, and should stop or undo whatever setup did:\n\n```js {2-3,5}\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"406":{"pageContent":"```js {2-3,5}\n\nuseEffect(() => {\n\nconst connection = createConnection(serverUrl, roomId);\n\nconnection.connect();\n\nreturn () => {\n\nconnection.disconnect();\n\n};\n\n}, [serverUrl, roomId]);\n\n```\n\n[Learn how the Effect lifecycle is different from the component's lifecycle.](/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect)\n\n--\n\n### My Effect does something visual, and I see a flicker before it runs {/*my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs*/}\n\nIf your Effect must block the browser from [painting the screen,](/learn/render-and-commit#epilogue-browser-paint) replace `useEffect` with [`useLayoutEffect`](/reference/react/useLayoutEffect). Note that **this shouldn't be needed for the vast majority of Effects.** You'll only need this if it's crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it for the first time.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffect.md"}},"407":{"pageContent":"--\n\ntitle: useMemo\n\n--\n\n<Intro>\n\n`useMemo` is a React Hook that lets you cache the result of a calculation between re-renders.\n\n```js\n\nconst cachedValue = useMemo(calculateValue, dependencies)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useMemo(calculateValue, dependencies)` {/*usememo*/}\n\nCall `useMemo` at the top level of your component to cache a calculation between re-renders:\n\n```js\n\nimport { useMemo } from 'react';\n\nfunction TodoList({ todos, tab }) {\n\nconst visibleTodos = useMemo(\n\n() => filterTodos(todos, tab),\n\n[todos, tab]\n\n);\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"408":{"pageContent":"function TodoList({ todos, tab }) {\n\nconst visibleTodos = useMemo(\n\n() => filterTodos(todos, tab),\n\n[todos, tab]\n\n);\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`calculateValue`: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On subsequent renders, React will return the same value again if the `dependencies` have not changed since the last render. Otherwise, it will call `calculateValue`, return its result, and store it in case it can be reused later.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"409":{"pageContent":"`dependencies`: The list of all reactive values referenced inside of the `calculateValue` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm.\n\n#### Returns {/*returns*/}\n\nOn the initial render, `useMemo` returns the result of calling `calculateValue` with no arguments.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"410":{"pageContent":"#### Returns {/*returns*/}\n\nOn the initial render, `useMemo` returns the result of calling `calculateValue` with no arguments.\n\nDuring subsequent renders, it will either return an already stored value from the last render (if the dependencies haven't changed), or call `calculateValue` again, and return the result that `calculateValue` has returned.\n\n#### Caveats {/*caveats*/}\n\n`useMemo` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n\nIn Strict Mode, React will **call your calculation function twice** in order to [help you find accidental impurities.](#my-calculation-runs-twice-on-every-re-render) This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"411":{"pageContent":"React **will not throw away the cached value unless there is a specific reason to do that.** For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache--for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on `useMemo` solely as a performance optimization. Otherwise, a [state variable](/reference/react/useState#avoiding-recreating-the-initial-state) or a [ref](/reference/react/useRef#avoiding-recreating-the-ref-contents) may be more appropriate.\n\n<Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"412":{"pageContent":"<Note>\n\nCaching return values like this is also known as [*memoization*,](https://en.wikipedia.org/wiki/Memoization) which is why this Hook is called `useMemo`.\n\n</Note>\n\n--\n\n## Usage {/*usage*/}\n\n### Skipping expensive recalculations {/*skipping-expensive-recalculations*/}\n\nTo cache a calculation between re-renders, wrap it in a `useMemo` call at the top level of your component:\n\n```js [[3, 4, \"visibleTodos\"], [1, 4, \"() => filterTodos(todos, tab)\"], [2, 4, \"[todos, tab]\"]]\n\nimport { useMemo } from 'react';\n\nfunction TodoList({ todos, tab, theme }) {\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n// ...\n\n}\n\n```\n\nYou need to pass two things to `useMemo`:\n\n1. A <CodeStep step={1}>calculation function</CodeStep> that takes no arguments, like `() =>`, and returns what you wanted to calculate.\n\n2. A <CodeStep step={2}>list of dependencies</CodeStep> including every value within your component that's used inside your calculation.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"413":{"pageContent":"2. A <CodeStep step={2}>list of dependencies</CodeStep> including every value within your component that's used inside your calculation.\n\nOn the initial render, the <CodeStep step={3}>value</CodeStep> you'll get from `useMemo` will be the result of calling your <CodeStep step={1}>calculation</CodeStep>.\n\nOn every subsequent render, React will compare the <CodeStep step={2}>dependencies</CodeStep> with the dependencies you passed during the last render. If none of the dependencies have changed (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), `useMemo` will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.\n\nIn other words, `useMemo` caches a calculation result between re-renders until its dependencies change.\n\n*Let's walk through an example to see when this is useful.**","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"414":{"pageContent":"In other words, `useMemo` caches a calculation result between re-renders until its dependencies change.\n\n*Let's walk through an example to see when this is useful.**\n\nBy default, React will re-run the entire body of your component every time that it re-renders. For example, if this `TodoList` updates its state or receives new props from its parent, the `filterTodos` function will re-run:\n\n```js {2}\n\nfunction TodoList({ todos, tab, theme }) {\n\nconst visibleTodos = filterTodos(todos, tab);\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"415":{"pageContent":"```js {2}\n\nfunction TodoList({ todos, tab, theme }) {\n\nconst visibleTodos = filterTodos(todos, tab);\n\n// ...\n\n}\n\n```\n\nUsually, this isn't a problem because most calculations are very fast. However, if you're filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn't changed. If both `todos` and `tab` are the same as they were during the last render, wrapping the calculation in `useMemo` like earlier lets you reuse `visibleTodos` you've already calculated before. This type of caching is called *[memoization.](https://en.wikipedia.org/wiki/Memoization)*\n\n<Note>\n\n*You should only rely on `useMemo` as a performance optimization.** If your code doesn't work without it, find the underlying problem and fix it first. Then you may add `useMemo` to improve performance.\n\n</Note>\n\n<DeepDive>\n\n#### How to tell if a calculation is expensive? {/*how-to-tell-if-a-calculation-is-expensive*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"416":{"pageContent":"</Note>\n\n<DeepDive>\n\n#### How to tell if a calculation is expensive? {/*how-to-tell-if-a-calculation-is-expensive*/}\n\nIn general, unless you're creating or looping over thousands of objects, it's probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:\n\n```js {1,3}\n\nconsole.time('filter array');\n\nconst visibleTodos = filterTodos(todos, tab);\n\nconsole.timeEnd('filter array');\n\n```\n\nPerform the interaction you're measuring (for example, typing into the input). You will then see logs like `filter array: 0.15ms` in your console. If the overall logged time adds up to a significant amount (say, `1ms` or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in `useMemo` to verify whether the total logged time has decreased for that interaction or not:\n\n```js\n\nconsole.time('filter array');\n\nconst visibleTodos = useMemo(() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"417":{"pageContent":"```js\n\nconsole.time('filter array');\n\nconst visibleTodos = useMemo(() => {\n\nreturn filterTodos(todos, tab); // Skipped if todos and tab haven't changed\n\n}, [todos, tab]);\n\nconsole.timeEnd('filter array');\n\n```\n\n`useMemo` won't make the *first* render faster. It only helps you skip unnecessary work on updates.\n\nKeep in mind that your machine is probably faster than your users' so it's a good idea to test the performance with an artificial slowdown. For example, Chrome offers a [CPU Throttling](https://developer.chrome.com/blog/new-in-devtools-61/#throttling) option for this.\n\nAlso note that measuring performance in development will not give you the most accurate results. (For example, when [Strict Mode](/reference/react/StrictMode) is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.\n\n</DeepDive>\n\n<DeepDive>\n\n#### Should you add useMemo everywhere? {/*should-you-add-usememo-everywhere*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"418":{"pageContent":"</DeepDive>\n\n<DeepDive>\n\n#### Should you add useMemo everywhere? {/*should-you-add-usememo-everywhere*/}\n\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\n\nOptimizing with `useMemo`  is only valuable in a few cases:\n\nThe calculation you're putting in `useMemo` is noticeably slow, and its dependencies rarely change.\n\nYou pass it as a prop to a component wrapped in [`memo`.](/reference/react/memo) You want to skip re-rendering if the value hasn't changed. Memoization lets your component re-render only when dependencies aren't the same.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"419":{"pageContent":"The value you're passing is later used as a dependency of some Hook. For example, maybe another `useMemo` calculation value depends on it. Or maybe you are depending on this value from [`useEffect.`](/reference/react/useEffect)\n\nThere is no benefit to wrapping a calculation in `useMemo` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that's \"always new\" is enough to break memoization for an entire component.\n\n*In practice, you can make a lot of memoization unnecessary by following a few principles:**\n\n1. When a component visually wraps other components, let it [accept JSX as children.](/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don't need to re-render.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"420":{"pageContent":"1. Prefer local state and don't [lift state up](/learn/sharing-state-between-components) any further than necessary. For example, don't keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n\n1. Keep your [rendering logic pure.](/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it's a bug in your component! Fix the bug instead of adding memoization.\n\n1. Avoid [unnecessary Effects that update state.](/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n\n1. Try to [remove unnecessary dependencies from your Effects.](/learn/removing-effect-dependencies) For example, instead of memoization, it's often simpler to move some object or a function inside an Effect or outside the component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"421":{"pageContent":"If a specific interaction still feels laggy, [use the React Developer Tools profiler](/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it's good to follow them in any case. In the long term, we're researching [doing granular memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.\n\n</DeepDive>\n\n<Recipes titleText=\"The difference between useMemo and calculating a value directly\" titleId=\"examples-recalculation\">\n\n#### Skipping recalculation with `useMemo` {/*skipping-recalculation-with-usememo*/}\n\nIn this example, the `filterTodos` implementation is **artificially slowed down** so that you can see what happens when some JavaScript function you're calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"422":{"pageContent":"Switching the tabs feels slow because it forces the slowed down `filterTodos` to re-execute. That's expected because the `tab` has changed, and so the entire calculation *needs* to re-run. (If you're curious why it runs twice, it's explained [here.](#my-calculation-runs-twice-on-every-re-render))\n\nNext, try toggling the theme. **Thanks to `useMemo`, it's fast despite the artificial slowdown!** The slow `filterTodos` call was skipped because both `todos` and `tab` (which you pass as dependencies to `useMemo`) haven't changed since the last render.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport { createTodos } from './utils.js';\n\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n\nconst [tab, setTab] = useState('all');\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setTab('all')}>\n\nAll\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"423":{"pageContent":"return (\n\n<>\n\n<button onClick={() => setTab('all')}>\n\nAll\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted\n\n</button>\n\n<br />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<TodoList\n\ntodos={todos}\n\ntab={tab}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js TodoList.js active\n\nimport { useMemo } from 'react';\n\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n\nconst visibleTodos = useMemo(\n\n() => filterTodos(todos, tab),\n\n[todos, tab]\n\n);\n\nreturn (\n\n<div className={theme}>\n\n<p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>\n\n<ul>\n\n{visibleTodos.map(todo => (\n\n<li key={todo.id}>\n\n{todo.completed ?\n\n<s>{todo.text}</s> :\n\ntodo.text\n\n}\n\n</li>\n\n))}\n\n</ul>\n\n</div>\n\n);\n\n}\n\n```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"424":{"pageContent":"}\n\n</li>\n\n))}\n\n</ul>\n\n</div>\n\n);\n\n}\n\n```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}\n\nreturn todos;\n\n}\n\nexport function filterTodos(todos, tab) {\n\nconsole.log('[ARTIFICIALLY SLOW] Filtering ' + todos.length + ' todos for \"' + tab + '\" tab.');\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 500) {\n\n// Do nothing for 500 ms to emulate extremely slow code\n\n}\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {\n\nreturn todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 10px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Always recalculating a value {/*always-recalculating-a-value*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"425":{"pageContent":"}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Always recalculating a value {/*always-recalculating-a-value*/}\n\nIn this example, the `filterTodos` implementation is also **artificially slowed down** so that you can see what happens when some JavaScript function you're calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.\n\nUnlike in the previous example, toggling the theme is also slow now! This is because **there is no `useMemo` call in this version,** so the artificially slowed down `filterTodos` gets called on every re-render. It is called even if only `theme` has changed.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport { createTodos } from './utils.js';\n\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n\nconst [tab, setTab] = useState('all');\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"426":{"pageContent":"import TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n\nconst [tab, setTab] = useState('all');\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setTab('all')}>\n\nAll\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted\n\n</button>\n\n<br />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<TodoList\n\ntodos={todos}\n\ntab={tab}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js TodoList.js active\n\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n\nconst visibleTodos = filterTodos(todos, tab);\n\nreturn (\n\n<div className={theme}>\n\n<ul>\n\n<p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>\n\n{visibleTodos.map(todo => (\n\n<li key={todo.id}>\n\n{todo.completed ?\n\n<s>{todo.text}</s> :\n\ntodo.text\n\n}\n\n</li>\n\n))}\n\n</ul>\n\n</div>\n\n);\n\n}\n\n```\n\n```js utils.js\n\nexport function createTodos() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"427":{"pageContent":"{visibleTodos.map(todo => (\n\n<li key={todo.id}>\n\n{todo.completed ?\n\n<s>{todo.text}</s> :\n\ntodo.text\n\n}\n\n</li>\n\n))}\n\n</ul>\n\n</div>\n\n);\n\n}\n\n```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}\n\nreturn todos;\n\n}\n\nexport function filterTodos(todos, tab) {\n\nconsole.log('[ARTIFICIALLY SLOW] Filtering ' + todos.length + ' todos for \"' + tab + '\" tab.');\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 500) {\n\n// Do nothing for 500 ms to emulate extremely slow code\n\n}\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {\n\nreturn todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 10px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"428":{"pageContent":"return todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 10px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\nHowever, here is the same code **with the artificial slowdown removed.** Does the lack of `useMemo` feel noticeable or not?\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport { createTodos } from './utils.js';\n\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n\nconst [tab, setTab] = useState('all');\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setTab('all')}>\n\nAll\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted\n\n</button>\n\n<br />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<TodoList\n\ntodos={todos}\n\ntab={tab}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js TodoList.js active","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"429":{"pageContent":"type=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<TodoList\n\ntodos={todos}\n\ntab={tab}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js TodoList.js active\n\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n\nconst visibleTodos = filterTodos(todos, tab);\n\nreturn (\n\n<div className={theme}>\n\n<ul>\n\n{visibleTodos.map(todo => (\n\n<li key={todo.id}>\n\n{todo.completed ?\n\n<s>{todo.text}</s> :\n\ntodo.text\n\n}\n\n</li>\n\n))}\n\n</ul>\n\n</div>\n\n);\n\n}\n\n```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}\n\nreturn todos;\n\n}\n\nexport function filterTodos(todos, tab) {\n\nconsole.log('Filtering ' + todos.length + ' todos for \"' + tab + '\" tab.');\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {\n\nreturn todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"430":{"pageContent":"if (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {\n\nreturn todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 10px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\nQuite often, code without memoization works fine. If your interactions are fast enough, you might not need memoization.\n\nYou can try increasing the number of todo items in `utils.js` and see how the behavior changes. This particular calculation wasn't very expensive to begin with, but if the number of todos grows significantly, most of the overhead will be in re-rendering rather than in the filtering. Keep reading below to see how you can optimize re-rendering with `useMemo`.\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Skipping re-rendering of components {/*skipping-re-rendering-of-components*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"431":{"pageContent":"<Solution />\n\n</Recipes>\n\n--\n\n### Skipping re-rendering of components {/*skipping-re-rendering-of-components*/}\n\nIn some cases, `useMemo` can also help you optimize performance of re-rendering child components. To illustrate this, let's say this `TodoList` component passes the `visibleTodos` as a prop to the child `List` component:\n\n```js {5}\n\nexport default function TodoList({ todos, tab, theme }) {\n\n// ...\n\nreturn (\n\n<div className={theme}>\n\n<List items={visibleTodos} />\n\n</div>\n\n);\n\n}\n\n```\n\nYou've noticed that toggling the `theme` prop freezes the app for a moment, but if you remove `<List />` from your JSX, it feels fast. This tells you that it's worth trying to optimize the `List` component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"432":{"pageContent":"*By default, when a component re-renders, React re-renders all of its children recursively.** This is why, when `TodoList` re-renders with a different `theme`, the `List` component *also* re-renders. This is fine for components that don't require much calculation to re-render. But if you've verified that a re-render is slow, you can tell `List` to skip re-rendering when its props are the same as on last render by wrapping it in [`memo`:](/reference/react/memo)\n\n```js {3,5}\n\nimport { memo } from 'react';\n\nconst List = memo(function List({ items }) {\n\n// ...\n\n});\n\n```\n\n*With this change, `List` will skip re-rendering if all of its props are the *same* as on the last render.** This is where caching the calculation becomes important! Imagine that you calculated `visibleTodos` without `useMemo`:\n\n```js {2-3,6-7}\n\nexport default function TodoList({ todos, tab, theme }) {\n\n// Every time the theme changes, this will be a different array...\n\nconst visibleTodos = filterTodos(todos, tab);\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"433":{"pageContent":"```js {2-3,6-7}\n\nexport default function TodoList({ todos, tab, theme }) {\n\n// Every time the theme changes, this will be a different array...\n\nconst visibleTodos = filterTodos(todos, tab);\n\nreturn (\n\n<div className={theme}>\n\n{/* ... so List's props will never be the same, and it will re-render every time */}\n\n<List items={visibleTodos} />\n\n</div>\n\n);\n\n}\n\n```\n\n*In the above example, the `filterTodos` function always creates a *different* array,** similar to how the `{}` object literal always creates a new object. Normally, this wouldn't be a problem, but it means that `List` props will never be the same, and your [`memo`](/reference/react/memo) optimization won't work. This is where `useMemo` comes in handy:\n\n```js {2-3,5,9-10}\n\nexport default function TodoList({ todos, tab, theme }) {\n\n// Tell React to cache your calculation between re-renders...\n\nconst visibleTodos = useMemo(\n\n() => filterTodos(todos, tab),\n\n[todos, tab] // ...so as long as these dependencies don't change...\n\n);\n\nreturn (\n\n<div className={theme}>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"434":{"pageContent":"const visibleTodos = useMemo(\n\n() => filterTodos(todos, tab),\n\n[todos, tab] // ...so as long as these dependencies don't change...\n\n);\n\nreturn (\n\n<div className={theme}>\n\n{/* ...List will receive the same props and can skip re-rendering */}\n\n<List items={visibleTodos} />\n\n</div>\n\n);\n\n}\n\n```\n\n*By wrapping the `visibleTodos` calculation in `useMemo`, you ensure that it has the *same* value between the re-renders** (until dependencies change). You don't *have to* wrap a calculation in `useMemo` unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in [`memo`,](/reference/react/memo) and this lets it skip re-rendering. There are a few other reasons to add `useMemo` which are described further on this page.\n\n<DeepDive>\n\n#### Memoizing individual JSX nodes {/*memoizing-individual-jsx-nodes*/}\n\nInstead of wrapping `List` in [`memo`](/reference/react/memo), you could wrap the `<List />` JSX node itself in `useMemo`:\n\n```js {3,6}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"435":{"pageContent":"Instead of wrapping `List` in [`memo`](/reference/react/memo), you could wrap the `<List />` JSX node itself in `useMemo`:\n\n```js {3,6}\n\nexport default function TodoList({ todos, tab, theme }) {\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\nconst children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);\n\nreturn (\n\n<div className={theme}>\n\n{children}\n\n</div>\n\n);\n\n}\n\n```\n\nThe behavior would be the same. If the `visibleTodos` haven't changed, `List` won't be re-rendered.\n\nA JSX node like `<List items={visibleTodos} />` is an object like `{ type: List, props: { items: visibleTodos } }`. Creating this object is very cheap, but React doesn't know whether its contents is the same as last time or not. This is why by default, React will re-render the `List` component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"436":{"pageContent":"However, if React sees the same exact JSX as during the previous render, it won't try to re-render your component. This is because JSX nodes are [immutable.](https://en.wikipedia.org/wiki/Immutable_object) A JSX node object could not have changed over time, so React knows it's safe to skip a re-render. However, for this to work, the node has to *actually be the same object*, not merely look the same in code. This is what `useMemo` does in this example.\n\nManually wrapping JSX nodes into `useMemo` is not convenient. For example, you can't do this conditionally. This is usually why you would wrap components with [`memo`](/reference/react/memo) instead of wrapping JSX nodes.\n\n</DeepDive>\n\n<Recipes titleText=\"The difference between skipping re-renders and always re-rendering\" titleId=\"examples-rerendering\">\n\n#### Skipping re-rendering with `useMemo` and `memo` {/*skipping-re-rendering-with-usememo-and-memo*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"437":{"pageContent":"#### Skipping re-rendering with `useMemo` and `memo` {/*skipping-re-rendering-with-usememo-and-memo*/}\n\nIn this example, the `List` component is **artificially slowed down** so that you can see what happens when a React component you're rendering is genuinely slow. Try switching the tabs and toggling the theme.\n\nSwitching the tabs feels slow because it forces the slowed down `List` to re-render. That's expected because the `tab` has changed, and so you need to reflect the user's new choice on the screen.\n\nNext, try toggling the theme. **Thanks to `useMemo` together with [`memo`](/reference/react/memo), itâ€™s fast despite the artificial slowdown!** The `List` skipped re-rendering because the `visibleItems` array has not changed since the last render. The `visibleItems` array has not changed because both `todos` and `tab` (which you pass as dependencies to `useMemo`) haven't changed since the last render.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"438":{"pageContent":"<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport { createTodos } from './utils.js';\n\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n\nconst [tab, setTab] = useState('all');\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setTab('all')}>\n\nAll\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted\n\n</button>\n\n<br />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<TodoList\n\ntodos={todos}\n\ntab={tab}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js TodoList.js active\n\nimport { useMemo } from 'react';\n\nimport List from './List.js';\n\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n\nconst visibleTodos = useMemo(\n\n() => filterTodos(todos, tab),\n\n[todos, tab]\n\n);\n\nreturn (\n\n<div className={theme}>\n\n<p><b>Note: <code>List</code> is artificially slowed down!</b></p>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"439":{"pageContent":"const visibleTodos = useMemo(\n\n() => filterTodos(todos, tab),\n\n[todos, tab]\n\n);\n\nreturn (\n\n<div className={theme}>\n\n<p><b>Note: <code>List</code> is artificially slowed down!</b></p>\n\n<List items={visibleTodos} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js List.js\n\nimport { memo } from 'react';\n\nconst List = memo(function List({ items }) {\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering <List /> with ' + items.length + ' items');\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 500) {\n\n// Do nothing for 500 ms to emulate extremely slow code\n\n}\n\nreturn (\n\n<ul>\n\n{items.map(item => (\n\n<li key={item.id}>\n\n{item.completed ?\n\n<s>{item.text}</s> :\n\nitem.text\n\n}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n});\n\nexport default List;\n\n```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}\n\nreturn todos;\n\n}\n\nexport function filterTodos(todos, tab) {\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"440":{"pageContent":"});\n\n}\n\nreturn todos;\n\n}\n\nexport function filterTodos(todos, tab) {\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {\n\nreturn todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 10px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Always re-rendering a component {/*always-re-rendering-a-component*/}\n\nIn this example, the `List` implementation is also **artificially slowed down** so that you can see what happens when some React component you're rendering is genuinely slow. Try switching the tabs and toggling the theme.\n\nUnlike in the previous example, toggling the theme is also slow now! This is because **there is no `useMemo` call in this version,** so the `visibleTodos` is always a different array, and the slowed down `List` component can't skip re-rendering.\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"441":{"pageContent":"<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport { createTodos } from './utils.js';\n\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n\nconst [tab, setTab] = useState('all');\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setTab('all')}>\n\nAll\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted\n\n</button>\n\n<br />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<TodoList\n\ntodos={todos}\n\ntab={tab}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js TodoList.js active\n\nimport List from './List.js';\n\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n\nconst visibleTodos = filterTodos(todos, tab);\n\nreturn (\n\n<div className={theme}>\n\n<p><b>Note: <code>List</code> is artificially slowed down!</b></p>\n\n<List items={visibleTodos} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js List.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"442":{"pageContent":"const visibleTodos = filterTodos(todos, tab);\n\nreturn (\n\n<div className={theme}>\n\n<p><b>Note: <code>List</code> is artificially slowed down!</b></p>\n\n<List items={visibleTodos} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js List.js\n\nimport { memo } from 'react';\n\nconst List = memo(function List({ items }) {\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering <List /> with ' + items.length + ' items');\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 500) {\n\n// Do nothing for 500 ms to emulate extremely slow code\n\n}\n\nreturn (\n\n<ul>\n\n{items.map(item => (\n\n<li key={item.id}>\n\n{item.completed ?\n\n<s>{item.text}</s> :\n\nitem.text\n\n}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n});\n\nexport default List;\n\n```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}\n\nreturn todos;\n\n}\n\nexport function filterTodos(todos, tab) {\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"443":{"pageContent":"}\n\nexport function filterTodos(todos, tab) {\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {\n\nreturn todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 10px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\nHowever, here is the same code **with the artificial slowdown removed.** Does the lack of `useMemo` feel noticeable or not?\n\n<Sandpack>\n\n```js App.js\n\nimport { useState } from 'react';\n\nimport { createTodos } from './utils.js';\n\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n\nconst [tab, setTab] = useState('all');\n\nconst [isDark, setIsDark] = useState(false);\n\nreturn (\n\n<>\n\n<button onClick={() => setTab('all')}>\n\nAll\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted\n\n</button>\n\n<br />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"444":{"pageContent":"All\n\n</button>\n\n<button onClick={() => setTab('active')}>\n\nActive\n\n</button>\n\n<button onClick={() => setTab('completed')}>\n\nCompleted\n\n</button>\n\n<br />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={isDark}\n\nonChange={e => setIsDark(e.target.checked)}\n\n/>\n\nDark mode\n\n</label>\n\n<hr />\n\n<TodoList\n\ntodos={todos}\n\ntab={tab}\n\ntheme={isDark ? 'dark' : 'light'}\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js TodoList.js active\n\nimport List from './List.js';\n\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n\nconst visibleTodos = filterTodos(todos, tab);\n\nreturn (\n\n<div className={theme}>\n\n<List items={visibleTodos} />\n\n</div>\n\n);\n\n}\n\n```\n\n```js List.js\n\nimport { memo } from 'react';\n\nfunction List({ items }) {\n\nreturn (\n\n<ul>\n\n{items.map(item => (\n\n<li key={item.id}>\n\n{item.completed ?\n\n<s>{item.text}</s> :\n\nitem.text\n\n}\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\nexport default memo(List);\n\n```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}\n\nreturn todos;\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"445":{"pageContent":"```\n\n```js utils.js\n\nexport function createTodos() {\n\nconst todos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ntodos.push({\n\nid: i,\n\ntext: \"Todo \" + (i + 1),\n\ncompleted: Math.random() > 0.5\n\n});\n\n}\n\nreturn todos;\n\n}\n\nexport function filterTodos(todos, tab) {\n\nreturn todos.filter(todo => {\n\nif (tab === 'all') {\n\nreturn true;\n\n} else if (tab === 'active') {\n\nreturn !todo.completed;\n\n} else if (tab === 'completed') {\n\nreturn todo.completed;\n\n}\n\n});\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-top: 10px;\n\n}\n\n.dark {\n\nbackground-color: black;\n\ncolor: white;\n\n}\n\n.light {\n\nbackground-color: white;\n\ncolor: black;\n\n}\n\n```\n\n</Sandpack>\n\nQuite often, code without memoization works fine. If your interactions are fast enough, you don't need memoization.\n\nKeep in mind that you need to run React in production mode, disable [React Developer Tools](/learn/react-developer-tools), and use devices similar to the ones your app's users have in order to get a realistic sense of what's actually slowing down your app.\n\n<Solution />\n\n</Recipes>\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"446":{"pageContent":"<Solution />\n\n</Recipes>\n\n--\n\n### Memoizing a dependency of another Hook {/*memoizing-a-dependency-of-another-hook*/}\n\nSuppose you have a calculation that depends on an object created directly in the component body:\n\n```js {2}\n\nfunction Dropdown({ allItems, text }) {\n\nconst searchOptions = { matchMode: 'whole-word', text };\n\nconst visibleItems = useMemo(() => {\n\nreturn searchItems(allItems, searchOptions);\n\n}, [allItems, searchOptions]); // ðŸš© Caution: Dependency on an object created in the component body\n\n// ...\n\n```\n\nDepending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. **The lines of code creating the `searchOptions` object will also run on every re-render.** Since `searchOptions` is a dependency of your `useMemo` call, and it's different every time, React will know the dependencies are different from the last time, and recalculate `searchItems` every time.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"447":{"pageContent":"To fix this, you could memoize the `searchOptions` object *itself* before passing it as a dependency:\n\n```js {2-4}\n\nfunction Dropdown({ allItems, text }) {\n\nconst searchOptions = useMemo(() => {\n\nreturn { matchMode: 'whole-word', text };\n\n}, [text]); // âœ… Only changes when text changes\n\nconst visibleItems = useMemo(() => {\n\nreturn searchItems(allItems, searchOptions);\n\n}, [allItems, searchOptions]); // âœ… Only changes when allItems or searchOptions changes\n\n// ...\n\n```\n\nIn the example above, if the `text` did not change, the `searchOptions` object also won't change. However, an even better fix is to move the `searchOptions` object declaration *inside* of the `useMemo` calculation function:\n\n```js {3}\n\nfunction Dropdown({ allItems, text }) {\n\nconst visibleItems = useMemo(() => {\n\nconst searchOptions = { matchMode: 'whole-word', text };\n\nreturn searchItems(allItems, searchOptions);\n\n}, [allItems, text]); // âœ… Only changes when allItems or text changes\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"448":{"pageContent":"const searchOptions = { matchMode: 'whole-word', text };\n\nreturn searchItems(allItems, searchOptions);\n\n}, [allItems, text]); // âœ… Only changes when allItems or text changes\n\n// ...\n\n```\n\n*Now your calculation depends on `text` directly (which is a string and can't \"accidentally\" be new like an object).**\n\nYou can use a similar approach to prevent [`useEffect`](/reference/react/useEffect) from firing again unnecessarily. Before you try to optimize dependencies with `useMemo`, see if you can make them unnecessary. [Read about removing Effect dependencies.](/learn/removing-effect-dependencies)\n\n--\n\n### Memoizing a function {/*memoizing-a-function*/}\n\nSuppose the `Form` component is wrapped in [`memo`.](/reference/react/memo) You want to pass a function to it as a prop:\n\n```js {2-7}\n\nexport default function ProductPage({ productId, referrer }) {\n\nfunction handleSubmit(orderDetails) {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails\n\n});\n\n}\n\nreturn <Form onSubmit={handleSubmit} />;\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"449":{"pageContent":"function handleSubmit(orderDetails) {\n\npost('/product/' + productId + '/buy', {\n\nreferrer,\n\norderDetails\n\n});\n\n}\n\nreturn <Form onSubmit={handleSubmit} />;\n\n}\n\n```\n\nSimilar to how `{}` always creates a different object, function declarations like `function() {}` and expressions like `() => {}` produce a *different* function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the `Form` component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is *always* different would defeat the point of memoization.\n\nTo memoize a function with `useMemo`, your calculation function would have to return another function:\n\n```js {2-3,8-9}\n\nexport default function Page({ productId, referrer }) {\n\nconst handleSubmit = useMemo(() => {\n\nreturn (orderDetails) => {\n\npost('/product/' + product.id + '/buy', {\n\nreferrer,\n\norderDetails\n\n});\n\n};\n\n}, [productId, referrer]);\n\nreturn <Form onSubmit={handleSubmit} />;\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"450":{"pageContent":"const handleSubmit = useMemo(() => {\n\nreturn (orderDetails) => {\n\npost('/product/' + product.id + '/buy', {\n\nreferrer,\n\norderDetails\n\n});\n\n};\n\n}, [productId, referrer]);\n\nreturn <Form onSubmit={handleSubmit} />;\n\n}\n\n```\n\nThis looks clunky! **Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into [`useCallback`](/reference/react/useCallback) instead of `useMemo`** to avoid having to write an extra nested function:\n\n```js {2,7}\n\nexport default function Page({ productId, referrer }) {\n\nconst handleSubmit = useCallback((orderDetails) => {\n\npost('/product/' + product.id + '/buy', {\n\nreferrer,\n\norderDetails\n\n});\n\n}, [productId, referrer]);\n\nreturn <Form onSubmit={handleSubmit} />;\n\n}\n\n```\n\nThe two examples above are completely equivalent. The only benefit to `useCallback` is that it lets you avoid writing an extra nested function inside. It doesn't do anything else. [Read more about `useCallback`.](/reference/react/useCallback)\n\n--\n\n## Troubleshooting {/*troubleshooting*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"451":{"pageContent":"--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### My calculation runs twice on every re-render {/*my-calculation-runs-twice-on-every-re-render*/}\n\nIn [Strict Mode](/reference/react/StrictMode), React will call some of your functions twice instead of once:\n\n```js {2,5,6}\n\nfunction TodoList({ todos, tab }) {\n\n// This component function will run twice for every render.\n\nconst visibleTodos = useMemo(() => {\n\n// This calculation will run twice if any of the dependencies change.\n\nreturn filterTodos(todos, tab);\n\n}, [todos, tab]);\n\n// ...\n\n```\n\nThis is expected and shouldn't break your code.\n\nThis **development-only** behavior helps you [keep components pure.](/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn't affect your logic. However, if they are accidentally impure, this helps you notice the mistakes and fix it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"452":{"pageContent":"For example, this impure calculation function mutates an array you received as a prop:\n\n```js {2-3}\n\nconst visibleTodos = useMemo(() => {\n\n// ðŸš© Mistake: mutating a prop\n\ntodos.push({ id: 'last', text: 'Go for a walk!' });\n\nconst filtered = filterTodos(todos, tab);\n\nreturn filtered;\n\n}, [todos, tab]);\n\n```\n\nBecause React calls your calculation twice, you'll see the todo was added twice, so you'll know that there is a mistake. Your calculation can't change the objects that it received, but it can change any *new* objects you created during the calculation. For example, if `filterTodos` always returns a *different* array, you can mutate *that* array:\n\n```js {3,4}\n\nconst visibleTodos = useMemo(() => {\n\nconst filtered = filterTodos(todos, tab);\n\n// âœ… Correct: mutating an object you created during the calculation\n\nfiltered.push({ id: 'last', text: 'Go for a walk!' });\n\nreturn filtered;\n\n}, [todos, tab]);\n\n```\n\nRead [keeping components pure](/learn/keeping-components-pure) to learn more about purity.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"453":{"pageContent":"filtered.push({ id: 'last', text: 'Go for a walk!' });\n\nreturn filtered;\n\n}, [todos, tab]);\n\n```\n\nRead [keeping components pure](/learn/keeping-components-pure) to learn more about purity.\n\nAlso, check out the guides on [updating objects](/learn/updating-objects-in-state) and [updating arrays](/learn/updating-arrays-in-state) without mutation.\n\n--\n\n### My `useMemo` call is supposed to return an object, but returns undefined {/*my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined*/}\n\nThis code doesn't work:\n\n```js {1-2,5}\n\n// ðŸ”´ You can't return an object from an arrow function with () => {\n\nconst searchOptions = useMemo(() => {\n\nmatchMode: 'whole-word',\n\ntext: text\n\n}, [text]);\n\n```\n\nIn JavaScript, `() => {` starts the arrow function body, so the `{` brace is not a part of your object. This is why it doesn't return an object, and leads to confusing mistakes. You could fix it by adding parentheses like `({` and `})`:\n\n```js {1-2,5}\n\n// This works, but is easy for someone to break again","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"454":{"pageContent":"```js {1-2,5}\n\n// This works, but is easy for someone to break again\n\nconst searchOptions = useMemo(() => ({\n\nmatchMode: 'whole-word',\n\ntext: text\n\n}), [text]);\n\n```\n\nHowever, this is still confusing and too easy for someone to break by removing the parentheses.\n\nTo avoid this mistake, write a `return` statement explicitly:\n\n```js {1-3,6-7}\n\n// âœ… This works and is explicit\n\nconst searchOptions = useMemo(() => {\n\nreturn {\n\nmatchMode: 'whole-word',\n\ntext: text\n\n};\n\n}, [text]);\n\n```\n\n--\n\n### Every time my component renders, the calculation in `useMemo` re-runs {/*every-time-my-component-renders-the-calculation-in-usememo-re-runs*/}\n\nMake sure you've specified the dependency array as a second argument!\n\nIf you forget the dependency array, `useMemo` will re-run the calculation every time:\n\n```js {2-3}\n\nfunction TodoList({ todos, tab }) {\n\n// ðŸ”´ Recalculates every time: no dependency array\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab));\n\n// ...\n\n```\n\nThis is the corrected version passing the dependency array as a second argument:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"455":{"pageContent":"// ðŸ”´ Recalculates every time: no dependency array\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab));\n\n// ...\n\n```\n\nThis is the corrected version passing the dependency array as a second argument:\n\n```js {2-3}\n\nfunction TodoList({ todos, tab }) {\n\n// âœ… Does not recalculate unnecessarily\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n// ...\n\n```\n\nIf this doesn't help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\n\n```js\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\nconsole.log([todos, tab]);\n\n```\n\nYou can then right-click on the arrays from different re-renders in the console and select \"Store as a global variable\" for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"456":{"pageContent":"```js\n\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\n\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\n\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n\n```\n\nWhen you find which dependency is breaking memoization, either find a way to remove it, or [memoize it as well.](#memoizing-a-dependency-of-another-hook)\n\n--\n\n### I need to call `useMemo` for each list item in a loop, but it's not allowed {/*i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed*/}\n\nSuppose the `Chart` component is wrapped in [`memo`](/reference/react/memo). You want to skip re-rendering every `Chart` in the list when the `ReportList` component re-renders. However, you can't call `useMemo` in a loop:\n\n```js {5-11}\n\nfunction ReportList({ items }) {\n\nreturn (\n\n<article>\n\n{items.map(item => {\n\n// ðŸ”´ You can't call useMemo in a loop like this:\n\nconst data = useMemo(() => calculateReport(item), [item]);\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"457":{"pageContent":"```js {5-11}\n\nfunction ReportList({ items }) {\n\nreturn (\n\n<article>\n\n{items.map(item => {\n\n// ðŸ”´ You can't call useMemo in a loop like this:\n\nconst data = useMemo(() => calculateReport(item), [item]);\n\nreturn (\n\n<figure key={item.id}>\n\n<Chart data={data} />\n\n</figure>\n\n);\n\n})}\n\n</article>\n\n);\n\n}\n\n```\n\nInstead, extract a component for each item and memoize data for individual items:\n\n```js {5,12-18}\n\nfunction ReportList({ items }) {\n\nreturn (\n\n<article>\n\n{items.map(item =>\n\n<Report key={item.id} item={item} />\n\n)}\n\n</article>\n\n);\n\n}\n\nfunction Report({ item }) {\n\n// âœ… Call useMemo at the top level:\n\nconst data = useMemo(() => calculateReport(item), [item]);\n\nreturn (\n\n<figure>\n\n<Chart data={data} />\n\n</figure>\n\n);\n\n}\n\n```\n\nAlternatively, you could remove `useMemo` and instead wrap `Report` itself in [`memo`.](/reference/react/memo) If the `item` prop does not change, `Report` will skip re-rendering, so `Chart` will skip re-rendering too:\n\n```js {5,6,12}\n\nfunction ReportList({ items }) {\n\n// ...\n\n}\n\nconst Report = memo(function Report({ item }) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"458":{"pageContent":"```js {5,6,12}\n\nfunction ReportList({ items }) {\n\n// ...\n\n}\n\nconst Report = memo(function Report({ item }) {\n\nconst data = calculateReport(item);\n\nreturn (\n\n<figure>\n\n<Chart data={data} />\n\n</figure>\n\n);\n\n});\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useMemo.md"}},"459":{"pageContent":"--\n\ntitle: isValidElement\n\n--\n\n<Intro>\n\n`isValidElement` checks whether a value is a React element.\n\n```js\n\nconst isElement = isValidElement(value)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `isValidElement(value)` {/*isvalidelement*/}\n\nCall `isValidElement(value)` to check whether `value` is a React element.\n\n```js\n\nimport { isValidElement, createElement } from 'react';\n\n// âœ… React elements\n\nconsole.log(isValidElement(<p />)); // true\n\nconsole.log(isValidElement(createElement('p'))); // true\n\n// âŒ Not React elements\n\nconsole.log(isValidElement(25)); // false\n\nconsole.log(isValidElement('Hello')); // false\n\nconsole.log(isValidElement({ age: 42 })); // false\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`value`: The `value` you want to check. It can be any a value of any type.\n\n#### Returns {/*returns*/}\n\n`isValidElement` returns `true` if the `value` is a React element. Otherwise, it returns `false`.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/isValidElement.md"}},"460":{"pageContent":"#### Returns {/*returns*/}\n\n`isValidElement` returns `true` if the `value` is a React element. Otherwise, it returns `false`.\n\n#### Caveats {/*caveats*/}\n\n**Only [JSX tags](/learn/writing-markup-with-jsx) and objects returned by [`createElement`](/reference/react/createElement) are considered to be React elements.** For example, even though a number like `42` is a valid React *node* (and can be returned from a component), it is not a valid React element. Arrays and portals created with [`createPortal`](/reference/react-dom/createPortal) are also *not* considered to be React elements.\n\n--\n\n## Usage {/*usage*/}\n\n### Checking if something is a React element {/*checking-if-something-is-a-react-element*/}\n\nCall `isValidElement` to check if some value is a *React element.*\n\nReact elements are:\n\nValues produced by writing a [JSX tag](/learn/writing-markup-with-jsx)\n\nValues produced by calling [`createElement`](/reference/react/createElement)\n\nFor React elements, `isValidElement` returns `true`:\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/isValidElement.md"}},"461":{"pageContent":"Values produced by calling [`createElement`](/reference/react/createElement)\n\nFor React elements, `isValidElement` returns `true`:\n\n```js\n\nimport { isValidElement, createElement } from 'react';\n\n// âœ… JSX tags are React elements\n\nconsole.log(isValidElement(<p />)); // true\n\nconsole.log(isValidElement(<MyComponent />)); // true\n\n// âœ… Values returned by createElement are React elements\n\nconsole.log(isValidElement(createElement('p'))); // true\n\nconsole.log(isValidElement(createElement(MyComponent))); // true\n\n```\n\nAny other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements.\n\nFor them, `isValidElement` returns `false`:\n\n```js\n\n// âŒ These are *not* React elements\n\nconsole.log(isValidElement(null)); // false\n\nconsole.log(isValidElement(25)); // false\n\nconsole.log(isValidElement('Hello')); // false\n\nconsole.log(isValidElement({ age: 42 })); // false\n\nconsole.log(isValidElement([<div />, <div />])); // false\n\nconsole.log(isValidElement(MyComponent)); // false\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/isValidElement.md"}},"462":{"pageContent":"console.log(isValidElement({ age: 42 })); // false\n\nconsole.log(isValidElement([<div />, <div />])); // false\n\nconsole.log(isValidElement(MyComponent)); // false\n\n```\n\nIt is very uncommon to need `isValidElement`. It's mostly useful if you're calling another API that *only* accepts elements (like [`cloneElement`](/reference/react/cloneElement) does) and you want to avoid an error when your argument is not a React element.\n\nUnless you have some very specific reason to add an `isValidElement` check, you probably don't need it.\n\n<DeepDive>\n\n#### React elements vs React nodes {/*react-elements-vs-react-nodes*/}\n\nWhen you write a component, you can return any kind of *React node* from it:\n\n```js\n\nfunction MyComponent() {\n\n// ... you can return any React node ...\n\n}\n\n```\n\nA React node can be:\n\nA React element created like `<div />` or `createElement('div')`\n\nA portal created with [`createPortal`](/reference/react-dom/createPortal)\n\nA string\n\nA number\n\n`true`, `false`, `null`, or `undefined` (which are not displayed)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/isValidElement.md"}},"463":{"pageContent":"A portal created with [`createPortal`](/reference/react-dom/createPortal)\n\nA string\n\nA number\n\n`true`, `false`, `null`, or `undefined` (which are not displayed)\n\nAn array of other React nodes\n\n*Note `isValidElement` checks whether the argument is a *React element,* not whether it's a React node.** For example, `42` is not a valid React element. However, it is a perfectly valid React node:\n\n```js\n\nfunction MyComponent() {\n\nreturn 42; // It's ok to return a number from component\n\n}\n\n```\n\nThis is why you shouldn't use `isValidElement` as a way to check whether something can be rendered.\n\n</DeepDive>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/isValidElement.md"}},"464":{"pageContent":"--\n\ntitle: createRef\n\n--\n\n<Pitfall>\n\n`createRef` is mostly used for [class components.](/reference/react/Component) Function components typically rely on [`useRef`](/reference/react/useRef) instead.\n\n</Pitfall>\n\n<Intro>\n\n`createRef` creates a [ref](/learn/referencing-values-with-refs) object which can contain arbitrary value.\n\n```js\n\nclass MyInput extends Component {\n\ninputRef = createRef();\n\n// ...\n\n}\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `createRef()` {/*createref*/}\n\nCall `createRef` to declare a [ref](/learn/referencing-values-with-refs) inside a [class component.](/reference/react/Component)\n\n```js\n\nimport { createRef, Component } from 'react';\n\nclass MyComponent extends Component {\n\nintervalRef = createRef();\n\ninputRef = createRef();\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`createRef` takes no parameters.\n\n#### Returns {/*returns*/}\n\n`createRef` returns an object with a single property:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createRef.md"}},"465":{"pageContent":"// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`createRef` takes no parameters.\n\n#### Returns {/*returns*/}\n\n`createRef` returns an object with a single property:\n\n`current`: Initially, it's set to the `null`. You can later set it to something else. If you pass the ref object to React as a `ref` attribute to a JSX node, React will set its `current` property.\n\n#### Caveats {/*caveats*/}\n\n`createRef` always returns a *different* object. It's equivalent to writing `{ current: null }` yourself.\n\nIn a function component, you probably want [`useRef`](/reference/react/useRef) instead which always returns the same object.\n\n`const ref = useRef()` is equivalent to `const [ref, _] = useState(() => createRef(null))`.\n\n--\n\n## Usage {/*usage*/}\n\n### Declaring a ref in a class component {/*declaring-a-ref-in-a-class-component*/}\n\nTo declare a ref inside a [class component,](/reference/react/Component) call `createRef` and assign its result to a class field:\n\n```js {4}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createRef.md"}},"466":{"pageContent":"To declare a ref inside a [class component,](/reference/react/Component) call `createRef` and assign its result to a class field:\n\n```js {4}\n\nimport { Component, createRef } from 'react';\n\nclass Form extends Component {\n\ninputRef = createRef();\n\n// ...\n\n}\n\n```\n\nIf you now pass `ref={this.inputRef}` to an `<input>` in your JSX, React will populate `this.inputRef.current` with the input DOM node. For example, here is how you make a button that focuses the input:\n\n<Sandpack>\n\n```js\n\nimport { Component, createRef } from 'react';\n\nexport default class Form extends Component {\n\ninputRef = createRef();\n\nhandleClick = () => {\n\nthis.inputRef.current.focus();\n\n}\n\nrender() {\n\nreturn (\n\n<>\n\n<input ref={this.inputRef} />\n\n<button onClick={this.handleClick}>\n\nFocus the input\n\n</button>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\n`createRef` is mostly used for [class components.](/reference/react/Component) Function components typically rely on [`useRef`](/reference/react/useRef) instead.\n\n</Pitfall>\n\n--\n\n## Alternatives {/*alternatives*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createRef.md"}},"467":{"pageContent":"</Pitfall>\n\n--\n\n## Alternatives {/*alternatives*/}\n\n### Migrating from a class with `createRef` to a function with `useRef` {/*migrating-from-a-class-with-createref-to-a-function-with-useref*/}\n\nWe recommend to use function components instead of [class components](/reference/react/Component) in the new code. If you have some existing class components using `createRef`, here is how you can convert them. This is the original code:\n\n<Sandpack>\n\n```js\n\nimport { Component, createRef } from 'react';\n\nexport default class Form extends Component {\n\ninputRef = createRef();\n\nhandleClick = () => {\n\nthis.inputRef.current.focus();\n\n}\n\nrender() {\n\nreturn (\n\n<>\n\n<input ref={this.inputRef} />\n\n<button onClick={this.handleClick}>\n\nFocus the input\n\n</button>\n\n</>\n\n);\n\n}\n\n}\n\n```\n\n</Sandpack>\n\nWhen you [convert this component from a class to a function,](/reference/react/Component#alternatives) replace calls to `createRef` with calls to [`useRef`:](/reference/react/useRef)\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nexport default function Form() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createRef.md"}},"468":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nexport default function Form() {\n\nconst inputRef = useRef(null);\n\nfunction handleClick() {\n\ninputRef.current.focus();\n\n}\n\nreturn (\n\n<>\n\n<input ref={inputRef} />\n\n<button onClick={handleClick}>\n\nFocus the input\n\n</button>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createRef.md"}},"469":{"pageContent":"--\n\ntitle: \"Built-in React Hooks\"\n\n--\n\n<Intro>\n\nHooks* let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all the built-in Hooks in React.\n\n</Intro>\n\n--\n\n## State Hooks {/*state-hooks*/}\n\nState* lets a component [\"remember\" information like user input.](/learn/state-a-components-memory) For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.\n\nTo add state to a component, use one of these Hooks:\n\n[`useState`](/reference/react/useState) declares a state variable that you can update directly.\n\n[`useReducer`](/reference/react/useReducer) declares a state variable with the update logic inside a [reducer function.](/learn/extracting-state-logic-into-a-reducer)\n\n```js\n\nfunction ImageGallery() {\n\nconst [index, setIndex] = useState(0);\n\n// ...\n\n```\n\n--\n\n## Context Hooks {/*context-hooks*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/index.md"}},"470":{"pageContent":"```js\n\nfunction ImageGallery() {\n\nconst [index, setIndex] = useState(0);\n\n// ...\n\n```\n\n--\n\n## Context Hooks {/*context-hooks*/}\n\nContext* lets a component [receive information from distant parents without passing it as props.](/learn/passing-props-to-a-component) For example, your app's top-level component can pass the current UI theme to all components below, no matter how deep.\n\n[`useContext`](/reference/react/useContext) reads and subscribes to a context.\n\n```js\n\nfunction Button() {\n\nconst theme = useContext(ThemeContext);\n\n// ...\n\n```\n\n--\n\n## Ref Hooks {/*ref-hooks*/}\n\nRefs* let a component [hold some information that isn't used for rendering,](/learn/referencing-values-with-refs) like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an \"escape hatch\" from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/index.md"}},"471":{"pageContent":"[`useRef`](/reference/react/useRef) declares a ref. You can hold any value in it, but most often it's used to hold a DOM node.\n\n[`useImperativeHandle`](/reference/react/useImperativeHandle) lets you customize the ref exposed by your component. This is rarely used.\n\n```js\n\nfunction Form() {\n\nconst inputRef = useRef(null);\n\n// ...\n\n```\n\n--\n\n## Effect Hooks {/*effect-hooks*/}\n\nEffects* let a component [connect to and synchronize with external systems.](/learn/synchronizing-with-effects) This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and in general any non-React code.\n\n[`useEffect`](/reference/react/useEffect) connects a component to an external system.\n\n```js\n\nfunction ChatRoom({ roomId }) {\n\nuseEffect(() => {\n\nconst connection = createConnection(roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/index.md"}},"472":{"pageContent":"```js\n\nfunction ChatRoom({ roomId }) {\n\nuseEffect(() => {\n\nconst connection = createConnection(roomId);\n\nconnection.connect();\n\nreturn () => connection.disconnect();\n\n}, [roomId]);\n\n// ...\n\n```\n\nEffects are an \"escape hatch\" from the React paradigm. Don't use Effects to orchestrate the data flow of your application. If you're not interacting with an external system, [you might not need an Effect.](/learn/you-might-not-need-an-effect)\n\nThere are two rarely used variations of `useEffect` with differences in timing:\n\n[`useLayoutEffect`](/reference/react/useLayoutEffect) fires before the browser repaints the screen. You can measure layout here.\n\n[`useInsertionEffect`](/reference/react/useInsertionEffect) fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\n\n--\n\n## Performance Hooks {/*performance-hooks*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/index.md"}},"473":{"pageContent":"[`useInsertionEffect`](/reference/react/useInsertionEffect) fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\n\n--\n\n## Performance Hooks {/*performance-hooks*/}\n\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\n\nTo skip calculations and unnecessary re-rendering, use one of these Hooks:\n\n[`useMemo`](/reference/react/useMemo) lets you cache the result of an expensive calculation.\n\n[`useCallback`](/reference/react/useCallback) lets you cache a function definition before passing it down to an optimized component.\n\n```js\n\nfunction TodoList({ todos, tab, theme }) {\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/index.md"}},"474":{"pageContent":"```js\n\nfunction TodoList({ todos, tab, theme }) {\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n// ...\n\n}\n\n```\n\nSometimes, you can't skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don't need to block the user interface (like updating a chart).\n\nTo prioritize rendering, use one of these Hooks:\n\n[`useTransition`](/reference/react/useTransition) lets you mark a state transition as non-blocking and allow other updates to interrupt it.\n\n[`useDeferredValue`](/reference/react/useDeferredValue) lets you defer updating a non-critical part of the UI and let other parts update first.\n\n--\n\n## Other Hooks {/*other-hooks*/}\n\nThese Hooks are mostly useful to library authors and aren't commonly used in the application code.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/index.md"}},"475":{"pageContent":"--\n\n## Other Hooks {/*other-hooks*/}\n\nThese Hooks are mostly useful to library authors and aren't commonly used in the application code.\n\n[`useDebugValue`](/reference/react/useDebugValue) lets you customize the label React DevTools displays for your custom Hook.\n\n[`useId`](/reference/react/useId) lets a component associate a unique ID with itself. Typically used with accessibility APIs.\n\n[`useSyncExternalStore`](/reference/react/useSyncExternalStore) lets a component subscribe to an external store.\n\n--\n\n## Your own Hooks {/*your-own-hooks*/}\n\nYou can also [define your own custom Hooks](/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component) as JavaScript functions.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/index.md"}},"476":{"pageContent":"--\n\ntitle: <Suspense>\n\n--\n\n<Intro>\n\n`<Suspense>` lets you display a fallback until its children have finished loading.\n\n```js\n\n<Suspense fallback={<Loading />}>\n\n<SomeComponent />\n\n</Suspense>\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `<Suspense>` {/*suspense*/}\n\n#### Props {/*props*/}\n\n`children`: The actual UI you intend to render. If `children` suspends while rendering, the Suspense boundary will switch to rendering `fallback`.\n\n`fallback`: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to `fallback` when `children` suspends, and back to `children` when the data is ready. If `fallback` suspends while rendering, it will activate the closest parent Suspense boundary.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"477":{"pageContent":"#### Caveats {/*caveats*/}\n\nReact does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.\n\nIf Suspense was displaying content for the tree, but then it suspended again, the `fallback` will be shown again unless the update causing it was caused by [`startTransition`](/reference/react/startTransition) or [`useDeferredValue`](/reference/react/useDeferredValue).\n\nIf React needs to hide the already visible content because it suspended again, it will clean up [layout Effects](/reference/react/useLayoutEffect) in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This lets you make sure that Effects measuring the DOM layout don't try to do this while the content is hidden.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"478":{"pageContent":"React includes under-the-hood optimizations like *Streaming Server Rendering* and *Selective Hydration* that are integrated with Suspense. Read [an architectural overview](https://github.com/reactwg/react-18/discussions/37) and watch [a technical talk](https://www.youtube.com/watch?v=pj5N-Khihgc) to learn more.\n\n--\n\n## Usage {/*usage*/}\n\n### Displaying a fallback while content is loading {/*displaying-a-fallback-while-content-is-loading*/}\n\nYou can wrap any part of your application with a Suspense boundary:\n\n```js [[1, 1, \"<Loading />\"], [2, 2, \"<Albums />\"]]\n\n<Suspense fallback={<Loading />}>\n\n<Albums />\n\n</Suspense>\n\n```\n\nReact will display your <CodeStep step={1}>loading fallback</CodeStep> until all the code and data needed by <CodeStep step={2}>the children</CodeStep> has been loaded.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"479":{"pageContent":"<Albums />\n\n</Suspense>\n\n```\n\nReact will display your <CodeStep step={1}>loading fallback</CodeStep> until all the code and data needed by <CodeStep step={2}>the children</CodeStep> has been loaded.\n\nIn the example below, the `Albums` component *suspends* while fetching the list of albums. Until it's ready to render, React switches the closest Suspense boundary above to show the fallback--your `Loading` component. Then, when the data loads, React hides the `Loading` fallback and renders the `Albums` component with data.\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js hidden\n\nimport { useState } from 'react';\n\nimport ArtistPage from './ArtistPage.js';\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nif (show) {\n\nreturn (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"480":{"pageContent":"import ArtistPage from './ArtistPage.js';\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nif (show) {\n\nreturn (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n} else {\n\nreturn (\n\n<button onClick={() => setShow(true)}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n}\n\n```\n\n```js ArtistPage.js active\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>\n\n<h1>{artist.name}</h1>\n\n<Suspense fallback={<Loading />}>\n\n<Albums artistId={artist.id} />\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction Loading() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"481":{"pageContent":"// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"482":{"pageContent":"// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getAlbums() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 3000);\n\n});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"483":{"pageContent":"}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n</Sandpack>\n\n<Note>\n\n*Only Suspense-enabled data sources will activate the Suspense component.** They include:\n\nData fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/advanced-features/react-18)\n\nLazy-loading component code with [`lazy`](/reference/react/lazy)\n\nSuspense **does not** detect when data is fetched inside an Effect or event handler.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"484":{"pageContent":"Lazy-loading component code with [`lazy`](/reference/react/lazy)\n\nSuspense **does not** detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the `Albums` component above depends on your framework. If you use a Suspense-enabled framework, you'll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\n</Note>\n\n--\n\n### Revealing content together at once {/*revealing-content-together-at-once*/}\n\nBy default, the whole tree inside Suspense is treated as a single unit. For example, even if *only one* of these components suspends waiting for some data, *all* of them together will be replaced by the loading indicator:\n\n```js {2-5}\n\n<Suspense fallback={<Loading />}>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"485":{"pageContent":"```js {2-5}\n\n<Suspense fallback={<Loading />}>\n\n<Biography />\n\n<Panel>\n\n<Albums />\n\n</Panel>\n\n</Suspense>\n\n```\n\nThen, after all of them are ready to be displayed, they will all appear together at once.\n\nIn the example below, both `Biography` and `Albums` fetch some data. However, because they are grouped under a single Suspense boundary, these components always \"pop in\" together at the same time.\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js hidden\n\nimport { useState } from 'react';\n\nimport ArtistPage from './ArtistPage.js';\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nif (show) {\n\nreturn (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n} else {\n\nreturn (\n\n<button onClick={() => setShow(true)}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"486":{"pageContent":"if (show) {\n\nreturn (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n} else {\n\nreturn (\n\n<button onClick={() => setShow(true)}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n}\n\n```\n\n```js ArtistPage.js active\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';\n\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>\n\n<h1>{artist.name}</h1>\n\n<Suspense fallback={<Loading />}>\n\n<Biography artistId={artist.id} />\n\n<Panel>\n\n<Albums artistId={artist.id} />\n\n</Panel>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction Loading() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Panel.js\n\nexport default function Panel({ children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n{children}\n\n</section>\n\n);\n\n}\n\n```\n\n```js Biography.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"487":{"pageContent":"// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Biography({ artistId }) {\n\nconst bio = use(fetchData(`/${artistId}/bio`));\n\nreturn (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"488":{"pageContent":"promise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"489":{"pageContent":"return promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();\n\n} else if (url === '/the-beatles/bio') {\n\nreturn await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 1500);\n\n});","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"490":{"pageContent":"return await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 1500);\n\n});\n\nreturn `The Beatles were an English rock band,\n\nformed in Liverpool in 1960, that comprised\n\nJohn Lennon, Paul McCartney, George Harrison\n\nand Ringo Starr.`;\n\n}\n\nasync function getAlbums() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 3000);\n\n});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"491":{"pageContent":"year: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n```css\n\n.bio { font-style: italic; }\n\n.panel {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n```\n\n</Sandpack>\n\nComponents that load data don't have to be direct children of the Suspense boundary. For example, you can move `Biography` and `Albums` into a new `Details` component. This doesn't change the behavior. Because `Biography` and `Albums` share the same closest parent Suspense boundary, their reveal is coordinated together.\n\n```js {2,8-11}\n\n<Suspense fallback={<Loading />}>\n\n<Details artistId={artist.id} />\n\n</Suspense>\n\nfunction Details({ artistId }) {\n\nreturn (\n\n<>\n\n<Biography artistId={artistId} />\n\n<Panel>\n\n<Albums artistId={artistId} />\n\n</Panel>\n\n</>\n\n);\n\n}\n\n```\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"492":{"pageContent":"<Details artistId={artist.id} />\n\n</Suspense>\n\nfunction Details({ artistId }) {\n\nreturn (\n\n<>\n\n<Biography artistId={artistId} />\n\n<Panel>\n\n<Albums artistId={artistId} />\n\n</Panel>\n\n</>\n\n);\n\n}\n\n```\n\n--\n\n### Revealing nested content as it loads {/*revealing-nested-content-as-it-loads*/}\n\nWhen a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary's fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own loading fallback:\n\n```js {3,7}\n\n<Suspense fallback={<BigSpinner />}>\n\n<Biography />\n\n<Suspense fallback={<AlbumsGlimmer />}>\n\n<Panel>\n\n<Albums />\n\n</Panel>\n\n</Suspense>\n\n</Suspense>\n\n```\n\nWith this change, displaying the `Biography` doesn't need to \"wait\" for the `Albums` to load.\n\nThe sequence will be:\n\n1. If `Biography` hasn't loaded yet, `BigSpinner` is shown in place of the entire content area.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"493":{"pageContent":"The sequence will be:\n\n1. If `Biography` hasn't loaded yet, `BigSpinner` is shown in place of the entire content area.\n\n1. Once `Biography` finishes loading, `BigSpinner` is replaced by the content.\n\n1. If `Albums` hasn't loaded yet, `AlbumsGlimmer` is shown in place of `Albums` and its parent `Panel`.\n\n1. Finally, once `Albums` finishes loading, it replaces `AlbumsGlimmer`.\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js hidden\n\nimport { useState } from 'react';\n\nimport ArtistPage from './ArtistPage.js';\n\nexport default function App() {\n\nconst [show, setShow] = useState(false);\n\nif (show) {\n\nreturn (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n} else {\n\nreturn (\n\n<button onClick={() => setShow(true)}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n}\n\n```\n\n```js ArtistPage.js active","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"494":{"pageContent":"return (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n} else {\n\nreturn (\n\n<button onClick={() => setShow(true)}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n}\n\n```\n\n```js ArtistPage.js active\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';\n\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>\n\n<h1>{artist.name}</h1>\n\n<Suspense fallback={<BigSpinner />}>\n\n<Biography artistId={artist.id} />\n\n<Suspense fallback={<AlbumsGlimmer />}>\n\n<Panel>\n\n<Albums artistId={artist.id} />\n\n</Panel>\n\n</Suspense>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction BigSpinner() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\nfunction AlbumsGlimmer() {\n\nreturn (\n\n<div className=\"glimmer-panel\">\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}\n\n```\n\n```js Panel.js\n\nexport default function Panel({ children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n{children}\n\n</section>\n\n);\n\n}\n\n```\n\n```js Biography.js hidden","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"495":{"pageContent":"<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}\n\n```\n\n```js Panel.js\n\nexport default function Panel({ children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n{children}\n\n</section>\n\n);\n\n}\n\n```\n\n```js Biography.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Biography({ artistId }) {\n\nconst bio = use(fetchData(`/${artistId}/bio`));\n\nreturn (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"496":{"pageContent":"return promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"497":{"pageContent":"{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"498":{"pageContent":"export function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();\n\n} else if (url === '/the-beatles/bio') {\n\nreturn await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nreturn `The Beatles were an English rock band,\n\nformed in Liverpool in 1960, that comprised\n\nJohn Lennon, Paul McCartney, George Harrison\n\nand Ringo Starr.`;\n\n}\n\nasync function getAlbums() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 3000);\n\n});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"499":{"pageContent":"}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n```css\n\n.bio { font-style: italic; }\n\n.panel {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-panel {\n\nborder: 1px dashed #aaa;\n\nbackground: linear-gradient(90deg, rgba(221,221,221,1) 0%, rgba(255,255,255,1) 100%);\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"500":{"pageContent":"border-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>\n\nSuspense boundaries let you coordinate which parts of your UI should always \"pop in\" together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app's behavior.\n\nDon't put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed--it's likely that they've already included them in their design wireframes.\n\n--\n\n### Showing stale content while fresh content is loading {/*showing-stale-content-while-fresh-content-is-loading*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"501":{"pageContent":"--\n\n### Showing stale content while fresh content is loading {/*showing-stale-content-while-fresh-content-is-loading*/}\n\nIn this example, the `SearchResults` component suspends while fetching the search results. Try typing `\"a\"`, waiting for the results, and then editing it to `\"ab\"`. The results for `\"a\"` will get replaced by the loading fallback.\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState } from 'react';\n\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<SearchResults query={query} />\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"502":{"pageContent":"return (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<SearchResults query={query} />\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```\n\n```js SearchResults.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function SearchResults({ query }) {\n\nif (query === '') {\n\nreturn null;\n\n}\n\nconst albums = use(fetchData(`/search?q=${query}`));\n\nif (albums.length === 0) {\n\nreturn <p>No matches for <i>\"{query}\"</i></p>;\n\n}\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"503":{"pageContent":"</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/search?q=')) {\n\nreturn await getSearchResults(url.slice('/search?q='.length));\n\n} else {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"504":{"pageContent":"cache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/search?q=')) {\n\nreturn await getSearchResults(url.slice('/search?q='.length));\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getSearchResults(query) {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nconst allAlbums = [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"505":{"pageContent":"year: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\nconst lowerQuery = query.trim().toLowerCase();\n\nreturn allAlbums.filter(album => {\n\nconst lowerTitle = album.title.toLowerCase();\n\nreturn (\n\nlowerTitle.startsWith(lowerQuery) ||\n\nlowerTitle.indexOf(' ' + lowerQuery) !== -1\n\n)\n\n});\n\n}\n\n```\n\n```css\n\ninput { margin: 10px; }\n\n```\n\n</Sandpack>\n\nA common alternative UI pattern is to *defer* updating the list of results and to keep showing the previous results until the new results are ready. The [`useDeferredValue`](/reference/react/useDeferredValue) Hook lets you pass a deferred version of the query down:\n\n```js {3,11}\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"506":{"pageContent":"const [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<SearchResults query={deferredQuery} />\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```\n\nThe `query` will update immediately, so the input will display the new value. However, the `deferredQuery` will keep its previous value until the data has loaded, so `SearchResults` will show the stale results for a bit.\n\nTo make it more obvious to the user, you can add a visual indication when the stale result list is displayed:\n\n```js {2}\n\n<div style={{\n\nopacity: query !== deferredQuery ? 0.5 : 1\n\n}}>\n\n<SearchResults query={deferredQuery} />\n\n</div>\n\n```\n\nEnter `\"a\"` in the example below, wait for the results to load, and then edit the input to `\"ab\"`. Notice how instead of the Suspense fallback, you now see the slightly dimmed stale result list until the new results have loaded:\n\n<Sandpack>\n\n```json package.json hidden\n\n{","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"507":{"pageContent":"<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState, useDeferredValue } from 'react';\n\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n\nconst [query, setQuery] = useState('');\n\nconst deferredQuery = useDeferredValue(query);\n\nconst isStale = query !== deferredQuery;\n\nreturn (\n\n<>\n\n<label>\n\nSearch albums:\n\n<input value={query} onChange={e => setQuery(e.target.value)} />\n\n</label>\n\n<Suspense fallback={<h2>Loading...</h2>}>\n\n<div style={{ opacity: isStale ? 0.5 : 1 }}>\n\n<SearchResults query={deferredQuery} />\n\n</div>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\n```\n\n```js SearchResults.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"508":{"pageContent":"</>\n\n);\n\n}\n\n```\n\n```js SearchResults.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function SearchResults({ query }) {\n\nif (query === '') {\n\nreturn null;\n\n}\n\nconst albums = use(fetchData(`/search?q=${query}`));\n\nif (albums.length === 0) {\n\nreturn <p>No matches for <i>\"{query}\"</i></p>;\n\n}\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"509":{"pageContent":"return promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/search?q=')) {\n\nreturn await getSearchResults(url.slice('/search?q='.length));\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getSearchResults(query) {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nconst allAlbums = [{\n\nid: 13,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"510":{"pageContent":"}\n\n}\n\nasync function getSearchResults(query) {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nconst allAlbums = [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\nconst lowerQuery = query.trim().toLowerCase();\n\nreturn allAlbums.filter(album => {\n\nconst lowerTitle = album.title.toLowerCase();\n\nreturn (\n\nlowerTitle.startsWith(lowerQuery) ||\n\nlowerTitle.indexOf(' ' + lowerQuery) !== -1\n\n)\n\n});\n\n}\n\n```\n\n```css","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"511":{"pageContent":"return allAlbums.filter(album => {\n\nconst lowerTitle = album.title.toLowerCase();\n\nreturn (\n\nlowerTitle.startsWith(lowerQuery) ||\n\nlowerTitle.indexOf(' ' + lowerQuery) !== -1\n\n)\n\n});\n\n}\n\n```\n\n```css\n\ninput { margin: 10px; }\n\n```\n\n</Sandpack>\n\n<Note>\n\nBoth deferred values and [transitions](#preventing-already-revealed-content-from-hiding) let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent, meaning that it's allowed to \"lag behind\" the rest of the UI.\n\n</Note>\n\n--\n\n### Preventing already revealed content from hiding {/*preventing-already-revealed-content-from-hiding*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"512":{"pageContent":"</Note>\n\n--\n\n### Preventing already revealed content from hiding {/*preventing-already-revealed-content-from-hiding*/}\n\nWhen a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Press the button in the example below:\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState } from 'react';\n\nimport IndexPage from './IndexPage.js';\n\nimport ArtistPage from './ArtistPage.js';\n\nimport Layout from './Layout.js';\n\nexport default function App() {\n\nreturn (\n\n<Suspense fallback={<BigSpinner />}>\n\n<Router />\n\n</Suspense>\n\n);\n\n}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nfunction navigate(url) {\n\nsetPage(url);\n\n}\n\nlet content;\n\nif (page === '/') {\n\ncontent = (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"513":{"pageContent":"<Suspense fallback={<BigSpinner />}>\n\n<Router />\n\n</Suspense>\n\n);\n\n}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nfunction navigate(url) {\n\nsetPage(url);\n\n}\n\nlet content;\n\nif (page === '/') {\n\ncontent = (\n\n<IndexPage navigate={navigate} />\n\n);\n\n} else if (page === '/the-beatles') {\n\ncontent = (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n}\n\nreturn (\n\n<Layout>\n\n{content}\n\n</Layout>\n\n);\n\n}\n\nfunction BigSpinner() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Layout.js\n\nexport default function Layout({ children }) {\n\nreturn (\n\n<div className=\"layout\">\n\n<section className=\"header\">\n\nMusic Browser\n\n</section>\n\n<main>\n\n{children}\n\n</main>\n\n</div>\n\n);\n\n}\n\n```\n\n```js IndexPage.js\n\nexport default function IndexPage({ navigate }) {\n\nreturn (\n\n<button onClick={() => navigate('/the-beatles')}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n```\n\n```js ArtistPage.js\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';\n\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"514":{"pageContent":"import { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';\n\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>\n\n<h1>{artist.name}</h1>\n\n<Biography artistId={artist.id} />\n\n<Suspense fallback={<AlbumsGlimmer />}>\n\n<Panel>\n\n<Albums artistId={artist.id} />\n\n</Panel>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction AlbumsGlimmer() {\n\nreturn (\n\n<div className=\"glimmer-panel\">\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"515":{"pageContent":"export default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Biography.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"516":{"pageContent":"// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Biography({ artistId }) {\n\nconst bio = use(fetchData(`/${artistId}/bio`));\n\nreturn (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Panel.js hidden\n\nexport default function Panel({ children }) {\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"517":{"pageContent":"promise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Panel.js hidden\n\nexport default function Panel({ children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n{children}\n\n</section>\n\n);\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();\n\n} else if (url === '/the-beatles/bio') {\n\nreturn await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nreturn `The Beatles were an English rock band,\n\nformed in Liverpool in 1960, that comprised","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"518":{"pageContent":"// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nreturn `The Beatles were an English rock band,\n\nformed in Liverpool in 1960, that comprised\n\nJohn Lennon, Paul McCartney, George Harrison\n\nand Ringo Starr.`;\n\n}\n\nasync function getAlbums() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 3000);\n\n});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n```css","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"519":{"pageContent":"}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n```css\n\nmain {\n\nmin-height: 200px;\n\npadding: 10px;\n\n}\n\n.layout {\n\nborder: 1px solid black;\n\n}\n\n.header {\n\nbackground: #222;\n\npadding: 10px;\n\ntext-align: center;\n\ncolor: white;\n\n}\n\n.bio { font-style: italic; }\n\n.panel {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-panel {\n\nborder: 1px dashed #aaa;\n\nbackground: linear-gradient(90deg, rgba(221,221,221,1) 0%, rgba(255,255,255,1) 100%);\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"520":{"pageContent":"border-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>\n\nWhen you pressed the button, the `Router` component rendered `ArtistPage` instead of `IndexPage`. A component inside the `ArtistPage` suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by `BigSpinner`.\n\nTo prevent this from happening, you can mark the navigation state update as a *transition* with [`startTransition`:](/reference/react/startTransition)\n\n```js {5,7}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nfunction navigate(url) {\n\nstartTransition(() => {\n\nsetPage(url);\n\n});\n\n}\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"521":{"pageContent":"```js {5,7}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nfunction navigate(url) {\n\nstartTransition(() => {\n\nsetPage(url);\n\n});\n\n}\n\n// ...\n\n```\n\nThis tells React that the state transition is not urgent, and it's better to keep showing the previous page instead of hiding any already revealed content. Notice how clicking the button now \"waits\" for the `Biography` to load:\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, startTransition, useState } from 'react';\n\nimport IndexPage from './IndexPage.js';\n\nimport ArtistPage from './ArtistPage.js';\n\nimport Layout from './Layout.js';\n\nexport default function App() {\n\nreturn (\n\n<Suspense fallback={<BigSpinner />}>\n\n<Router />\n\n</Suspense>\n\n);\n\n}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nfunction navigate(url) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"522":{"pageContent":"export default function App() {\n\nreturn (\n\n<Suspense fallback={<BigSpinner />}>\n\n<Router />\n\n</Suspense>\n\n);\n\n}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nfunction navigate(url) {\n\nstartTransition(() => {\n\nsetPage(url);\n\n});\n\n}\n\nlet content;\n\nif (page === '/') {\n\ncontent = (\n\n<IndexPage navigate={navigate} />\n\n);\n\n} else if (page === '/the-beatles') {\n\ncontent = (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n}\n\nreturn (\n\n<Layout>\n\n{content}\n\n</Layout>\n\n);\n\n}\n\nfunction BigSpinner() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Layout.js\n\nexport default function Layout({ children }) {\n\nreturn (\n\n<div className=\"layout\">\n\n<section className=\"header\">\n\nMusic Browser\n\n</section>\n\n<main>\n\n{children}\n\n</main>\n\n</div>\n\n);\n\n}\n\n```\n\n```js IndexPage.js\n\nexport default function IndexPage({ navigate }) {\n\nreturn (\n\n<button onClick={() => navigate('/the-beatles')}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n```\n\n```js ArtistPage.js\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"523":{"pageContent":"Open The Beatles artist page\n\n</button>\n\n);\n\n}\n\n```\n\n```js ArtistPage.js\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';\n\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>\n\n<h1>{artist.name}</h1>\n\n<Biography artistId={artist.id} />\n\n<Suspense fallback={<AlbumsGlimmer />}>\n\n<Panel>\n\n<Albums artistId={artist.id} />\n\n</Panel>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction AlbumsGlimmer() {\n\nreturn (\n\n<div className=\"glimmer-panel\">\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"524":{"pageContent":"// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Biography.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"525":{"pageContent":");\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Biography.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Biography({ artistId }) {\n\nconst bio = use(fetchData(`/${artistId}/bio`));\n\nreturn (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"526":{"pageContent":"} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Panel.js hidden\n\nexport default function Panel({ children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n{children}\n\n</section>\n\n);\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();\n\n} else if (url === '/the-beatles/bio') {\n\nreturn await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"527":{"pageContent":"return await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nreturn `The Beatles were an English rock band,\n\nformed in Liverpool in 1960, that comprised\n\nJohn Lennon, Paul McCartney, George Harrison\n\nand Ringo Starr.`;\n\n}\n\nasync function getAlbums() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 3000);\n\n});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"528":{"pageContent":"year: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n```css\n\nmain {\n\nmin-height: 200px;\n\npadding: 10px;\n\n}\n\n.layout {\n\nborder: 1px solid black;\n\n}\n\n.header {\n\nbackground: #222;\n\npadding: 10px;\n\ntext-align: center;\n\ncolor: white;\n\n}\n\n.bio { font-style: italic; }\n\n.panel {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-panel {\n\nborder: 1px dashed #aaa;\n\nbackground: linear-gradient(90deg, rgba(221,221,221,1) 0%, rgba(255,255,255,1) 100%);\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"529":{"pageContent":"border-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>\n\nA transition doesn't wait for *all* content to load. It only waits long enough to avoid hiding already revealed content. For example, the website `Layout` was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested `Suspense` boundary around `Albums` is new, so the transition doesn't wait for it.\n\n<Note>\n\nSuspense-enabled routers are expected to wrap the navigation updates into transitions by default.\n\n</Note>\n\n--\n\n### Indicating that a transition is happening {/*indicating-that-a-transition-is-happening*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"530":{"pageContent":"Suspense-enabled routers are expected to wrap the navigation updates into transitions by default.\n\n</Note>\n\n--\n\n### Indicating that a transition is happening {/*indicating-that-a-transition-is-happening*/}\n\nIn the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace [`startTransition`](/reference/react/startTransition) with [`useTransition`](/reference/react/useTransition) which gives you a boolean `isPending` value. In the example below, it's used to change the website header styling while a transition is happening:\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState, useTransition } from 'react';\n\nimport IndexPage from './IndexPage.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"531":{"pageContent":"\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState, useTransition } from 'react';\n\nimport IndexPage from './IndexPage.js';\n\nimport ArtistPage from './ArtistPage.js';\n\nimport Layout from './Layout.js';\n\nexport default function App() {\n\nreturn (\n\n<Suspense fallback={<BigSpinner />}>\n\n<Router />\n\n</Suspense>\n\n);\n\n}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nconst [isPending, startTransition] = useTransition();\n\nfunction navigate(url) {\n\nstartTransition(() => {\n\nsetPage(url);\n\n});\n\n}\n\nlet content;\n\nif (page === '/') {\n\ncontent = (\n\n<IndexPage navigate={navigate} />\n\n);\n\n} else if (page === '/the-beatles') {\n\ncontent = (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n}\n\nreturn (\n\n<Layout isPending={isPending}>\n\n{content}\n\n</Layout>\n\n);\n\n}\n\nfunction BigSpinner() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Layout.js\n\nexport default function Layout({ children, isPending }) {\n\nreturn (\n\n<div className=\"layout\">\n\n<section className=\"header\" style={{","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"532":{"pageContent":");\n\n}\n\nfunction BigSpinner() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Layout.js\n\nexport default function Layout({ children, isPending }) {\n\nreturn (\n\n<div className=\"layout\">\n\n<section className=\"header\" style={{\n\nopacity: isPending ? 0.7 : 1\n\n}}>\n\nMusic Browser\n\n</section>\n\n<main>\n\n{children}\n\n</main>\n\n</div>\n\n);\n\n}\n\n```\n\n```js IndexPage.js\n\nexport default function IndexPage({ navigate }) {\n\nreturn (\n\n<button onClick={() => navigate('/the-beatles')}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n```\n\n```js ArtistPage.js\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';\n\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>\n\n<h1>{artist.name}</h1>\n\n<Biography artistId={artist.id} />\n\n<Suspense fallback={<AlbumsGlimmer />}>\n\n<Panel>\n\n<Albums artistId={artist.id} />\n\n</Panel>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction AlbumsGlimmer() {\n\nreturn (\n\n<div className=\"glimmer-panel\">\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"533":{"pageContent":"</Panel>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction AlbumsGlimmer() {\n\nreturn (\n\n<div className=\"glimmer-panel\">\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"534":{"pageContent":"function use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Biography.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Biography({ artistId }) {\n\nconst bio = use(fetchData(`/${artistId}/bio`));\n\nreturn (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"535":{"pageContent":"return (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Panel.js hidden\n\nexport default function Panel({ children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n{children}\n\n</section>\n\n);\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"536":{"pageContent":"// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();\n\n} else if (url === '/the-beatles/bio') {\n\nreturn await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nreturn `The Beatles were an English rock band,\n\nformed in Liverpool in 1960, that comprised\n\nJohn Lennon, Paul McCartney, George Harrison\n\nand Ringo Starr.`;\n\n}\n\nasync function getAlbums() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 3000);\n\n});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"537":{"pageContent":"});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n```css\n\nmain {\n\nmin-height: 200px;\n\npadding: 10px;\n\n}\n\n.layout {\n\nborder: 1px solid black;\n\n}\n\n.header {\n\nbackground: #222;\n\npadding: 10px;\n\ntext-align: center;\n\ncolor: white;\n\n}\n\n.bio { font-style: italic; }\n\n.panel {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-panel {\n\nborder: 1px dashed #aaa;\n\nbackground: linear-gradient(90deg, rgba(221,221,221,1) 0%, rgba(255,255,255,1) 100%);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"538":{"pageContent":"border: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-panel {\n\nborder: 1px dashed #aaa;\n\nbackground: linear-gradient(90deg, rgba(221,221,221,1) 0%, rgba(255,255,255,1) 100%);\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Resetting Suspense boundaries on navigation {/*resetting-suspense-boundaries-on-navigation*/}\n\nDuring a transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is *different* content. You can express this with a `key`:\n\n```js\n\n<ProfilePage key={queryParams.id} />\n\n```\n\nImagine you're navigating within a user's profile page, and something suspends. If that update is wrapped in a transition, it will not trigger the fallback for already visible content. That's the expected behavior.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"539":{"pageContent":"However, now imagine you're navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user's timeline is *different content* from another user's timeline. By specifying a `key`, you ensure that React treats different users' profiles as different components, and resets the Suspense boundaries during navigation. A Suspense-integrated routing framework should do this automatically.\n\n--\n\n### Providing a fallback for server errors and server-only content {/*providing-a-fallback-for-server-errors-and-server-only-content*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"540":{"pageContent":"--\n\n### Providing a fallback for server errors and server-only content {/*providing-a-fallback-for-server-errors-and-server-only-content*/}\n\nIf you use one of the [streaming server rendering APIs](/reference/react-dom/server) (or a framework that relies on them), React will also use your `<Suspense>` boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest `<Suspense>` component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner instead of an error.\n\nOn the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest [error boundary.](/reference/react/Component#static-getderivedstatefromerror) However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"541":{"pageContent":"You can use this to opt out some components from rendering on the server. To do this, throw an error from them in the server environment and then wrap them in a `<Suspense>` boundary to replace their HTML with fallbacks:\n\n```js\n\n<Suspense fallback={<Loading />}>\n\n<Chat />\n\n</Suspense>\n\nfunction Chat() {\n\nif (typeof window === 'undefined') {\n\nthrow Error('Chat should only render on the client.');\n\n}\n\n// ...\n\n}\n\n```\n\nThe server HTML will include the loading indicator. It will be replaced by the `Chat` component on the client.\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### How do I prevent the UI from being replaced by a fallback during an update? {/*preventing-unwanted-fallbacks*/}\n\nReplacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"542":{"pageContent":"To prevent this from happening, [mark the update as non-urgent using `startTransition`](#preventing-already-revealed-content-from-hiding). During a transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:\n\n```js {2-3,5}\n\nfunction handleNextPageClick() {\n\n// If this update suspends, don't hide the already displayed content\n\nstartTransition(() => {\n\nsetCurrentPage(currentPage + 1);\n\n});\n\n}\n\n```\n\nThis will avoid hiding existing content. However, any newly rendered `Suspense` boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.\n\n*React will only prevent unwanted fallbacks during non-urgent updates**. It will not delay a render if it's the result of an urgent update. You must opt in with an API like [`startTransition`](/reference/react/startTransition) or [`useDeferredValue`](/reference/react/useDeferredValue).","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"543":{"pageContent":"If your router is integrated with Suspense, it should wrap its updates into [`startTransition`](/reference/react/startTransition) automatically.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Suspense.md"}},"544":{"pageContent":"--\n\ntitle: startTransition\n\n--\n\n<Intro>\n\n`startTransition` lets you update the state without blocking the UI.\n\n```js\n\nstartTransition(scope)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `startTransition(scope)` {/*starttransitionscope*/}\n\nThe `startTransition` function lets you mark a state update as a transition.\n\n```js {7,9}\n\nimport { startTransition } from 'react';\n\nfunction TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/startTransition.md"}},"545":{"pageContent":"const [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`scope`: A function that updates some state by calling one or more [`set` functions.](/reference/react/useState#setstate) React immediately calls `scope` with no parameters and marks all state updates scheduled synchronously during the `scope` function call as transitions. They will be [non-blocking](/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition) and [will not display unwanted loading indicators.](/reference/react/useTransition#preventing-unwanted-loading-indicators)\n\n#### Returns {/*returns*/}\n\n`startTransition` does not return anything.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/startTransition.md"}},"546":{"pageContent":"#### Returns {/*returns*/}\n\n`startTransition` does not return anything.\n\n#### Caveats {/*caveats*/}\n\n`startTransition` does not provide a way to track whether a transition is pending. To show a pending indicator while the transition is ongoing, you need [`useTransition`](/reference/react/useTransition) instead.\n\nYou can wrap an update into a transition only if you have access to the `set` function of that state. If you want to start a transition in response to some prop or a custom Hook return value, try [`useDeferredValue`](/reference/react/usedeferredvalue) instead.\n\nThe function you pass to `startTransition` must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as transitions. If you try to perform more state updates later (for example, in a timeout), they won't be marked as transitions.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/startTransition.md"}},"547":{"pageContent":"A state update marked as a transition will be interrupted by other state updates. For example, if you update a chart component inside a transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.\n\nTransition updates can't be used to control text inputs.\n\nIf there are multiple ongoing transitions, React currently batches them together. This is a limitation that will likely be removed in a future release.\n\n--\n\n## Usage {/*usage*/}\n\n### Marking a state update as a non-blocking transition {/*marking-a-state-update-as-a-non-blocking-transition*/}\n\nYou can mark a state update as a *transition* by wrapping it in a `startTransition` call:\n\n```js {7,9}\n\nimport { startTransition } from 'react';\n\nfunction TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/startTransition.md"}},"548":{"pageContent":"```js {7,9}\n\nimport { startTransition } from 'react';\n\nfunction TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\n// ...\n\n}\n\n```\n\nTransitions let you keep the user interface updates responsive even on slow devices.\n\nWith a transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.\n\n<Note>\n\n`startTransition` is very similar to [`useTransition`](/reference/react/useTransition), except that it does not provide the `isPending` flag to track whether a transition is ongoing. You can call `startTransition` when `useTransition` is not available. For example, `startTransition` works outside components, such as from a data library.\n\n[Learn about transitions and see examples on the `useTransition` page.](/reference/react/useTransition)\n\n</Note>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/startTransition.md"}},"549":{"pageContent":"--\n\ntitle: createContext\n\n--\n\n<Intro>\n\n`createContext` lets you create a [context](/learn/passing-data-deeply-with-context) that components can provide or read.\n\n```js\n\nconst SomeContext = createContext(defaultValue)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `createContext(defaultValue)` {/*createcontext*/}\n\nCall `createContext` outside of any components to create a context.\n\n```js\n\nimport { createContext } from 'react';\n\nconst ThemeContext = createContext('light');\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`defaultValue`: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don't have any meaningful default value, specify `null`. The default value is meant as a \"last resort\" fallback. It is static and never changes over time.\n\n#### Returns {/*returns*/}\n\n`createContext` returns a context object.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"550":{"pageContent":"#### Returns {/*returns*/}\n\n`createContext` returns a context object.\n\n*The context object itself does not hold any information.** It represents _which_ context other components can read or provide. Typically, you will use [`SomeContext.Provider`](#provider) in components above to specify the context value, and call [`useContext(SomeContext)`](/reference/react/useContext) in components below to read it. The context object has a few properties:\n\n`SomeContext.Provider` lets you provide the context value to components.\n\n`SomeContext.Consumer` is an alternative and rarely used way to read the context value.\n\n--\n\n### `SomeContext.Provider` {/*provider*/}\n\nWrap your components into a context provider to specify the value of this context for all components inside:\n\n```js\n\nfunction App() {\n\nconst [theme, setTheme] = useState('light');\n\n// ...\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<Page />\n\n</ThemeContext.Provider>\n\n);\n\n}\n\n```\n\n#### Props {/*provider-props*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"551":{"pageContent":"```js\n\nfunction App() {\n\nconst [theme, setTheme] = useState('light');\n\n// ...\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<Page />\n\n</ThemeContext.Provider>\n\n);\n\n}\n\n```\n\n#### Props {/*provider-props*/}\n\n`value`: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component calling [`useContext(SomeContext)`](/reference/react/useContext) inside of the provider receives the `value` of the innermost corresponding context provider above it.\n\n--\n\n### `SomeContext.Consumer` {/*consumer*/}\n\nBefore `useContext` existed, there was an older way to read context:\n\n```js\n\nfunction Button() {\n\n// ðŸŸ¡ Legacy way (not recommended)\n\nreturn (\n\n<ThemeContext.Consumer>\n\n{theme => (\n\n<button className={theme} />\n\n)}\n\n</ThemeContext.Consumer>\n\n);\n\n}\n\n```\n\nAlthough this older way still works, but **newly written code should read context with [`useContext()`](/reference/react/useContext) instead:**\n\n```js\n\nfunction Button() {\n\n// âœ… Recommended way","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"552":{"pageContent":");\n\n}\n\n```\n\nAlthough this older way still works, but **newly written code should read context with [`useContext()`](/reference/react/useContext) instead:**\n\n```js\n\nfunction Button() {\n\n// âœ… Recommended way\n\nconst theme = useContext(ThemeContext);\n\nreturn <button className={theme} />;\n\n}\n\n```\n\n#### Props {/*consumer-props*/}\n\n`children`: A function. React will call the function you pass with the current context value determined by the same algorithm as [`useContext()`](/reference/react/useContext) does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context passed from the parent components have changed.\n\n--\n\n## Usage {/*usage*/}\n\n### Creating context {/*creating-context*/}\n\nContext lets components [pass information deep down](/learn/passing-data-deeply-with-context) without explicitly passing props.\n\nCall `createContext` outside any components to create one or more contexts.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"553":{"pageContent":"Call `createContext` outside any components to create one or more contexts.\n\n```js [[1, 3, \"ThemeContext\"], [1, 4, \"AuthContext\"], [3, 3, \"'light'\"], [3, 4, \"null\"]]\n\nimport { createContext } from 'react';\n\nconst ThemeContext = createContext('light');\n\nconst AuthContext = createContext(null);\n\n```\n\n`createContext` returns a <CodeStep step={1}>context object</CodeStep>. Components can read context by passing it to [`useContext()`](/reference/react/useContext):\n\n```js [[1, 2, \"ThemeContext\"], [1, 7, \"AuthContext\"]]\n\nfunction Button() {\n\nconst theme = useContext(ThemeContext);\n\n// ...\n\n}\n\nfunction Profile() {\n\nconst currentUser = useContext(AuthContext);\n\n// ...\n\n}\n\n```\n\nBy default, the values they receive will be the <CodeStep step={3}>default values</CodeStep> you have specified when creating the contexts. However, by itself this isn't useful because the default values never change.\n\nContext is useful because you can **provide other, dynamic values from your components:**\n\n```js {8-9,11-12}\n\nfunction App() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"554":{"pageContent":"Context is useful because you can **provide other, dynamic values from your components:**\n\n```js {8-9,11-12}\n\nfunction App() {\n\nconst [theme, setTheme] = useState('dark');\n\nconst [currentUser, setCurrentUser] = useState({ name: 'Taylor' });\n\n// ...\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<AuthContext.Provider value={currentUser}>\n\n<Page />\n\n</AuthContext.Provider>\n\n</ThemeContext.Provider>\n\n);\n\n}\n\n```\n\nNow the `Page` component and any components inside it, no matter how deep, will \"see\" the passed context values. If the passed context values change, React will re-render the components reading the context as well.\n\n[Read more about reading and providing context and see examples.](/reference/react/useContext)\n\n--\n\n### Importing and exporting context from a file {/*importing-and-exporting-context-from-a-file*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"555":{"pageContent":"[Read more about reading and providing context and see examples.](/reference/react/useContext)\n\n--\n\n### Importing and exporting context from a file {/*importing-and-exporting-context-from-a-file*/}\n\nOften, components in different files will need access to the same context. This is why it's common to declare contexts in a separate file. Then you can use the [`export` statement](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export) to make context available for other files:\n\n```js {4-5}\n\n// Contexts.js\n\nimport { createContext } from 'react';\n\nexport const ThemeContext = createContext('light');\n\nexport const AuthContext = createContext(null);\n\n````\n\nComponents declared in other files can then use the [`import`](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/import) statement to read or provide this context:\n\n```js {2}\n\n// Button.js\n\nimport { ThemeContext } from './Contexts.js';\n\nfunction Button() {\n\nconst theme = useContext(ThemeContext);\n\n// ...\n\n}\n\n```\n\n```js {2}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"556":{"pageContent":"```js {2}\n\n// Button.js\n\nimport { ThemeContext } from './Contexts.js';\n\nfunction Button() {\n\nconst theme = useContext(ThemeContext);\n\n// ...\n\n}\n\n```\n\n```js {2}\n\n// App.js\n\nimport { ThemeContext, AuthContext } from './Contexts.js';\n\nfunction App() {\n\n// ...\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<AuthContext.Provider value={currentUser}>\n\n<Page />\n\n</AuthContext.Provider>\n\n</ThemeContext.Provider>\n\n);\n\n}\n\n```\n\nThis works similar to [importing and exporting components.](/learn/importing-and-exporting-components)\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### I can't find a way to change the context value {/*i-cant-find-a-way-to-change-the-context-value*/}\n\nCode like this specifies the *default* context value:\n\n```js\n\nconst ThemeContext = createContext('light');\n\n```\n\nThis value never changes. React only uses this value as a fallback if it can't find a matching provider above.\n\nTo make context change over time, [add state and wrap components in a context provider.](/reference/react/useContext#updating-data-passed-via-context)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createContext.md"}},"557":{"pageContent":"--\n\ntitle: useRef\n\n--\n\n<Intro>\n\n`useRef` is a React Hook that lets you reference a value that's not needed for rendering.\n\n```js\n\nconst ref = useRef(initialValue)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useRef(initialValue)` {/*useref*/}\n\nCall `useRef` at the top level of your component to declare a [ref.](/learn/referencing-values-with-refs)\n\n```js\n\nimport { useRef } from 'react';\n\nfunction MyComponent() {\n\nconst intervalRef = useRef(0);\n\nconst inputRef = useRef(null);\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`initialValue`: The value you want the ref object's `current` property to be initially. It can be a value of any type. This argument is ignored after the initial render.\n\n#### Returns {/*returns*/}\n\n`useRef` returns an object with a single property:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"558":{"pageContent":"#### Returns {/*returns*/}\n\n`useRef` returns an object with a single property:\n\n`current`: Initially, it's set to the `initialValue` you have passed. You can later set it to something else. If you pass the ref object to React as a `ref` attribute to a JSX node, React will set its `current` property.\n\nOn the next renders, `useRef` will return the same object.\n\n#### Caveats {/*caveats*/}\n\nYou can mutate the `ref.current` property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn't mutate that object.\n\nWhen you change the `ref.current` property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.\n\nDo not write _or read_ `ref.current` during rendering, except for [initialization.](#avoiding-recreating-the-ref-contents) This makes your component's behavior unpredictable.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"559":{"pageContent":"Do not write _or read_ `ref.current` during rendering, except for [initialization.](#avoiding-recreating-the-ref-contents) This makes your component's behavior unpredictable.\n\nIn Strict Mode, React will **call your component function twice** in order to [help you find accidental impurities.](#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. This means that each ref object will be created twice, and one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the logic of your component.\n\n--\n\n## Usage {/*usage*/}\n\n### Referencing a value with a ref {/*referencing-a-value-with-a-ref*/}\n\nCall `useRef` at the top level of your component to declare one or more [refs.](/learn/referencing-values-with-refs)\n\n```js [[1, 4, \"intervalRef\"], [3, 4, \"0\"]]\n\nimport { useRef } from 'react';\n\nfunction Stopwatch() {\n\nconst intervalRef = useRef(0);\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"560":{"pageContent":"```js [[1, 4, \"intervalRef\"], [3, 4, \"0\"]]\n\nimport { useRef } from 'react';\n\nfunction Stopwatch() {\n\nconst intervalRef = useRef(0);\n\n// ...\n\n```\n\n`useRef` returns a <CodeStep step={1}>ref object</CodeStep> with a single <CodeStep step={2}>`current` property</CodeStep> initially set to the <CodeStep step={3}>initial value</CodeStep> you provided.\n\nOn the next renders, `useRef` will return the same object. You can change its `current` property to store information and read it later. This might remind you of [state](/reference/react/useState), but there is an important difference.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"561":{"pageContent":"*Changing a ref does not trigger a re-render.** This means refs are perfect for storing information that doesn't affect the visual output of your component. For example, if you need to store an [interval ID](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its <CodeStep step={2}>`current` property</CodeStep>:\n\n```js [[2, 5, \"intervalRef.current\"]]\n\nfunction handleStartClick() {\n\nconst intervalId = setInterval(() => {\n\n// ...\n\n}, 1000);\n\nintervalRef.current = intervalId;\n\n}\n\n```\n\nLater, you can read that interval ID from the ref so that you can call [clear that interval](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval):\n\n```js [[2, 2, \"intervalRef.current\"]]\n\nfunction handleStopClick() {\n\nconst intervalId = intervalRef.current;\n\nclearInterval(intervalId);\n\n}\n\n```\n\nBy using a ref, you ensure that:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"562":{"pageContent":"```js [[2, 2, \"intervalRef.current\"]]\n\nfunction handleStopClick() {\n\nconst intervalId = intervalRef.current;\n\nclearInterval(intervalId);\n\n}\n\n```\n\nBy using a ref, you ensure that:\n\nYou can **store information** between re-renders (unlike regular variables, which reset on every render).\n\nChanging it **does not trigger a re-render** (unlike state variables, which trigger a re-render).\n\nThe **information is local** to each copy of your component (unlike the variables outside, which are shared).\n\nChanging a ref does not trigger a re-render, so refs are not appropriate for storing information that you want to display on the screen. Use state for that instead. Read more about [choosing between `useRef` and `useState`.](/learn/referencing-values-with-refs#differences-between-refs-and-state)\n\n<Recipes titleText=\"Examples of referencing a value with useRef\" titleId=\"examples-value\">\n\n#### Click counter {/*click-counter*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"563":{"pageContent":"<Recipes titleText=\"Examples of referencing a value with useRef\" titleId=\"examples-value\">\n\n#### Click counter {/*click-counter*/}\n\nThis component uses a ref to keep track of how many times the button was clicked. Note that it's okay to use a ref instead of state here because the click count is only read and written in an event handler.\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nexport default function Counter() {\n\nlet ref = useRef(0);\n\nfunction handleClick() {\n\nref.current = ref.current + 1;\n\nalert('You clicked ' + ref.current + ' times!');\n\n}\n\nreturn (\n\n<button onClick={handleClick}>\n\nClick me!\n\n</button>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\nIf you show `{ref.current}` in the JSX, the number won't update on click. This is because setting `ref.current` does not trigger a re-render. Information that's used for rendering should be state instead.\n\n<Solution />\n\n#### A stopwatch {/*a-stopwatch*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"564":{"pageContent":"<Solution />\n\n#### A stopwatch {/*a-stopwatch*/}\n\nThis example uses a combination of state and refs. Both `startTime` and `now` are state variables because they are used for rendering. But we also need to hold an [interval ID](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) so that we can stop the interval on button press. Since the interval ID is not used for rendering, it's appropriate to keep it in a ref, and manually update it.\n\n<Sandpack>\n\n```js\n\nimport { useState, useRef } from 'react';\n\nexport default function Stopwatch() {\n\nconst [startTime, setStartTime] = useState(null);\n\nconst [now, setNow] = useState(null);\n\nconst intervalRef = useRef(null);\n\nfunction handleStart() {\n\nsetStartTime(Date.now());\n\nsetNow(Date.now());\n\nclearInterval(intervalRef.current);\n\nintervalRef.current = setInterval(() => {\n\nsetNow(Date.now());\n\n}, 10);\n\n}\n\nfunction handleStop() {\n\nclearInterval(intervalRef.current);\n\n}\n\nlet secondsPassed = 0;\n\nif (startTime != null && now != null) {\n\nsecondsPassed = (now - startTime) / 1000;\n\n}\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"565":{"pageContent":"setNow(Date.now());\n\n}, 10);\n\n}\n\nfunction handleStop() {\n\nclearInterval(intervalRef.current);\n\n}\n\nlet secondsPassed = 0;\n\nif (startTime != null && now != null) {\n\nsecondsPassed = (now - startTime) / 1000;\n\n}\n\nreturn (\n\n<>\n\n<h1>Time passed: {secondsPassed.toFixed(3)}</h1>\n\n<button onClick={handleStart}>\n\nStart\n\n</button>\n\n<button onClick={handleStop}>\n\nStop\n\n</button>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n<Pitfall>\n\n*Do not write _or read_ `ref.current` during rendering.**\n\nReact expects that the body of your component [behaves like a pure function](/learn/keeping-components-pure):\n\nIf the inputs ([props](/learn/passing-props-to-a-component), [state](/learn/state-a-components-memory), and [context](/learn/passing-data-deeply-with-context)) are the same, it should return exactly the same JSX.\n\nCalling it in a different order or with different arguments should not affect the results of other calls.\n\nReading or writing a ref **during rendering** breaks these expectations.\n\n```js {3-4,6-7}\n\nfunction MyComponent() {\n\n// ...","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"566":{"pageContent":"Reading or writing a ref **during rendering** breaks these expectations.\n\n```js {3-4,6-7}\n\nfunction MyComponent() {\n\n// ...\n\n// ðŸš© Don't write a ref during rendering\n\nmyRef.current = 123;\n\n// ...\n\n// ðŸš© Don't read a ref during rendering\n\nreturn <h1>{myOtherRef.current}</h1>;\n\n}\n\n```\n\nYou can read or write refs **from event handlers or effects instead**.\n\n```js {4-5,9-10}\n\nfunction MyComponent() {\n\n// ...\n\nuseEffect(() => {\n\n// âœ… You can read or write refs in effects\n\nmyRef.current = 123;\n\n});\n\n// ...\n\nfunction handleClick() {\n\n// âœ… You can read or write refs in event handlers\n\ndoSomething(myOtherRef.current);\n\n}\n\n// ...\n\n}\n\n```\n\nIf you *have to* read [or write](/reference/react/useState#storing-information-from-previous-renders) something during rendering, [use state](/reference/react/useState) instead.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"567":{"pageContent":"}\n\n// ...\n\n}\n\n```\n\nIf you *have to* read [or write](/reference/react/useState#storing-information-from-previous-renders) something during rendering, [use state](/reference/react/useState) instead.\n\nWhen you break these rules, your component might still work, but most of the newer features we're adding to React will rely on these expectations. Read more about [keeping your components pure.](/learn/keeping-components-pure#where-you-can-cause-side-effects)\n\n</Pitfall>\n\n--\n\n### Manipulating the DOM with a ref {/*manipulating-the-dom-with-a-ref*/}\n\nIt's particularly common to use a ref to manipulate the [DOM.](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API) React has built-in support for this.\n\nFirst, declare a <CodeStep step={1}>ref object</CodeStep> with an <CodeStep step={3}>initial value</CodeStep> of `null`:\n\n```js [[1, 4, \"inputRef\"], [3, 4, \"null\"]]\n\nimport { useRef } from 'react';\n\nfunction MyComponent() {\n\nconst inputRef = useRef(null);\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"568":{"pageContent":"```js [[1, 4, \"inputRef\"], [3, 4, \"null\"]]\n\nimport { useRef } from 'react';\n\nfunction MyComponent() {\n\nconst inputRef = useRef(null);\n\n// ...\n\n```\n\nThen pass your ref object as the `ref` attribute to the JSX of the DOM node you want to manipulate:\n\n```js [[1, 2, \"inputRef\"]]\n\n// ...\n\nreturn <input ref={inputRef} />;\n\n```\n\nAfter React creates the DOM node and puts it on the screen, React will set the <CodeStep step={2}>`current` property</CodeStep> of your ref object to that DOM node. Now you can access the `<input>`'s DOM node and call methods like [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus):\n\n```js [[2, 2, \"inputRef.current\"]]\n\nfunction handleClick() {\n\ninputRef.current.focus();\n\n}\n\n```\n\nReact will set the `current` property back to `null` when the node is removed from the screen.\n\nRead more about [manipulating the DOM with refs.](/learn/manipulating-the-dom-with-refs)\n\n<Recipes titleText=\"Examples of manipulating the DOM with useRef\" titleId=\"examples-dom\">","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"569":{"pageContent":"Read more about [manipulating the DOM with refs.](/learn/manipulating-the-dom-with-refs)\n\n<Recipes titleText=\"Examples of manipulating the DOM with useRef\" titleId=\"examples-dom\">\n\n#### Focusing a text input {/*focusing-a-text-input*/}\n\nIn this example, clicking the button will focus the input:\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nexport default function Form() {\n\nconst inputRef = useRef(null);\n\nfunction handleClick() {\n\ninputRef.current.focus();\n\n}\n\nreturn (\n\n<>\n\n<input ref={inputRef} />\n\n<button onClick={handleClick}>\n\nFocus the input\n\n</button>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Scrolling an image into view {/*scrolling-an-image-into-view*/}\n\nIn this example, clicking the button will scroll an image into view. It uses a ref to the list DOM node, and then calls DOM [`querySelectorAll`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll) API to find the image we want to scroll to.\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nexport default function CatFriends() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"570":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nexport default function CatFriends() {\n\nconst listRef = useRef(null);\n\nfunction scrollToIndex(index) {\n\nconst listNode = listRef.current;\n\n// This line assumes a particular DOM structure:\n\nconst imgNode = listNode.querySelectorAll('li > img')[index];\n\nimgNode.scrollIntoView({\n\nbehavior: 'smooth',\n\nblock: 'nearest',\n\ninline: 'center'\n\n});\n\n}\n\nreturn (\n\n<>\n\n<nav>\n\n<button onClick={() => scrollToIndex(0)}>\n\nTom\n\n</button>\n\n<button onClick={() => scrollToIndex(1)}>\n\nMaru\n\n</button>\n\n<button onClick={() => scrollToIndex(2)}>\n\nJellylorum\n\n</button>\n\n</nav>\n\n<div>\n\n<ul ref={listRef}>\n\n<li>\n\n<img\n\nsrc=\"https://placekitten.com/g/200/200\"\n\nalt=\"Tom\"\n\n/>\n\n</li>\n\n<li>\n\n<img\n\nsrc=\"https://placekitten.com/g/300/200\"\n\nalt=\"Maru\"\n\n/>\n\n</li>\n\n<li>\n\n<img\n\nsrc=\"https://placekitten.com/g/250/200\"\n\nalt=\"Jellylorum\"\n\n/>\n\n</li>\n\n</ul>\n\n</div>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\ndiv {\n\nwidth: 100%;\n\noverflow: hidden;\n\n}\n\nnav {\n\ntext-align: center;\n\n}\n\nbutton {\n\nmargin: .25rem;\n\n}\n\nul,\n\nli {\n\nlist-style: none;\n\nwhite-space: nowrap;\n\n}\n\nli {\n\ndisplay: inline;\n\npadding: 0.5rem;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"571":{"pageContent":"```css\n\ndiv {\n\nwidth: 100%;\n\noverflow: hidden;\n\n}\n\nnav {\n\ntext-align: center;\n\n}\n\nbutton {\n\nmargin: .25rem;\n\n}\n\nul,\n\nli {\n\nlist-style: none;\n\nwhite-space: nowrap;\n\n}\n\nli {\n\ndisplay: inline;\n\npadding: 0.5rem;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Playing and pausing a video {/*playing-and-pausing-a-video*/}\n\nThis example uses a ref to call [`play()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play) and [`pause()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause) on a `<video>` DOM node.\n\n<Sandpack>\n\n```js\n\nimport { useState, useRef } from 'react';\n\nexport default function VideoPlayer() {\n\nconst [isPlaying, setIsPlaying] = useState(false);\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nconst nextIsPlaying = !isPlaying;\n\nsetIsPlaying(nextIsPlaying);\n\nif (nextIsPlaying) {\n\nref.current.play();\n\n} else {\n\nref.current.pause();\n\n}\n\n}\n\nreturn (\n\n<>\n\n<button onClick={handleClick}>\n\n{isPlaying ? 'Pause' : 'Play'}\n\n</button>\n\n<video\n\nwidth=\"250\"\n\nref={ref}\n\nonPlay={() => setIsPlaying(true)}\n\nonPause={() => setIsPlaying(false)}\n\n>\n\n<source","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"572":{"pageContent":"}\n\n}\n\nreturn (\n\n<>\n\n<button onClick={handleClick}>\n\n{isPlaying ? 'Pause' : 'Play'}\n\n</button>\n\n<video\n\nwidth=\"250\"\n\nref={ref}\n\nonPlay={() => setIsPlaying(true)}\n\nonPause={() => setIsPlaying(false)}\n\n>\n\n<source\n\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n\ntype=\"video/mp4\"\n\n/>\n\n</video>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-bottom: 20px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Exposing a ref to your own component {/*exposing-a-ref-to-your-own-component*/}\n\nSometimes, you may want to let the parent component manipulate the DOM inside of your component. For example, maybe you're writing a `MyInput` component, but you want the parent to be able to focus the input (which the parent has no access to). You can use a combination of `useRef` to hold the input and [`forwardRef`](/reference/react/forwardRef) to expose it to the parent component. Read a [detailed walkthrough](/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes) here.\n\n<Sandpack>\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"573":{"pageContent":"<Sandpack>\n\n```js\n\nimport { forwardRef, useRef } from 'react';\n\nconst MyInput = forwardRef((props, ref) => {\n\nreturn <input {...props} ref={ref} />;\n\n});\n\nexport default function Form() {\n\nconst inputRef = useRef(null);\n\nfunction handleClick() {\n\ninputRef.current.focus();\n\n}\n\nreturn (\n\n<>\n\n<MyInput ref={inputRef} />\n\n<button onClick={handleClick}>\n\nFocus the input\n\n</button>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Avoiding recreating the ref contents {/*avoiding-recreating-the-ref-contents*/}\n\nReact saves the initial ref value once and ignores it on the next renders.\n\n```js\n\nfunction Video() {\n\nconst playerRef = useRef(new VideoPlayer());\n\n// ...\n\n```\n\nAlthough the result of `new VideoPlayer()` is only used for the initial render, you're still calling this function on every render. This can be wasteful if it's creating expensive objects.\n\nTo solve it, you may initialize the ref like this instead:\n\n```js\n\nfunction Video() {\n\nconst playerRef = useRef(null);\n\nif (playerRef.current === null) {\n\nplayerRef.current = new VideoPlayer();\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"574":{"pageContent":"To solve it, you may initialize the ref like this instead:\n\n```js\n\nfunction Video() {\n\nconst playerRef = useRef(null);\n\nif (playerRef.current === null) {\n\nplayerRef.current = new VideoPlayer();\n\n}\n\n// ...\n\n```\n\nNormally, writing or reading `ref.current` during render is not allowed. However, it's fine in this case because the result is always the same, and the condition only executes during initialization so it's fully predictable.\n\n<DeepDive>\n\n#### How to avoid null checks when initializing useRef later {/*how-to-avoid-null-checks-when-initializing-use-ref-later*/}\n\nIf you use a type checker and don't want to always check for `null`, you can try a pattern like this instead:\n\n```js\n\nfunction Video() {\n\nconst playerRef = useRef(null);\n\nfunction getPlayer() {\n\nif (playerRef.current !== null) {\n\nreturn playerRef.current;\n\n}\n\nconst player = new VideoPlayer();\n\nplayerRef.current = player;\n\nreturn player;\n\n}\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"575":{"pageContent":"const playerRef = useRef(null);\n\nfunction getPlayer() {\n\nif (playerRef.current !== null) {\n\nreturn playerRef.current;\n\n}\n\nconst player = new VideoPlayer();\n\nplayerRef.current = player;\n\nreturn player;\n\n}\n\n// ...\n\n```\n\nHere, the `playerRef` itself is nullable. However, you should be able to convince your type checker that there is no case in which `getPlayer()` returns `null`. Then use `getPlayer()` in your event handlers.\n\n</DeepDive>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### I can't get a ref to a custom component {/*i-cant-get-a-ref-to-a-custom-component*/}\n\nIf you try to pass a `ref` to your own component like this:\n\n```js\n\nconst inputRef = useRef(null);\n\nreturn <MyInput ref={inputRef} />;\n\n```\n\nYou might get an error in the console:\n\n<ConsoleBlock level=\"error\">\n\nWarning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\n\n</ConsoleBlock>\n\nBy default, your own components don't expose refs to the DOM nodes inside them.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"576":{"pageContent":"</ConsoleBlock>\n\nBy default, your own components don't expose refs to the DOM nodes inside them.\n\nTo fix this, find the component that you want to get a ref to:\n\n```js\n\nexport default function MyInput({ value, onChange }) {\n\nreturn (\n\n<input\n\nvalue={value}\n\nonChange={onChange}\n\n/>\n\n);\n\n}\n\n```\n\nAnd then wrap it in [`forwardRef`](/reference/react/forwardRef) like this:\n\n```js {3,8}\n\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef(({ value, onChange }, ref) => {\n\nreturn (\n\n<input\n\nvalue={value}\n\nonChange={onChange}\n\nref={ref}\n\n/>\n\n);\n\n});\n\nexport default MyInput;\n\n```\n\nThen the parent component can get a ref to it.\n\nRead more about [accessing another component's DOM nodes.](/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useRef.md"}},"577":{"pageContent":"--\n\ntitle: useReducer\n\n--\n\n<Intro>\n\n`useReducer` is a React Hook that lets you add a [reducer](/learn/extracting-state-logic-into-a-reducer) to your component.\n\n```js\n\nconst [state, dispatch] = useReducer(reducer, initialArg, init?)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useReducer(reducer, initialArg, init?)` {/*usereducer*/}\n\nCall `useReducer` at the top level of your component to manage its state with a [reducer.](/learn/extracting-state-logic-into-a-reducer)\n\n```js\n\nimport { useReducer } from 'react';\n\nfunction reducer(state, action) {\n\n// ...\n\n}\n\nfunction MyComponent() {\n\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`reducer`: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"578":{"pageContent":"`initialArg`: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next `init` argument.\n\n**optional** `init`: The initializer function that specifies how the initial state is calculated. If it's not specified, the initial state is set to `initialArg`. Otherwise, the initial state is set to the result of calling `init(initialArg)`.\n\n#### Returns {/*returns*/}\n\n`useReducer` returns an array with exactly two values:\n\n1. The current state. During the first render, it's set to `init(initialArg)` or `initialArg` (if there's no `init`).\n\n2. The [`dispatch` function](#dispatch) that lets you update the state to a different value and trigger a re-render.\n\n#### Caveats {/*caveats*/}\n\n`useReducer` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"579":{"pageContent":"In Strict Mode, React will **call your reducer and initializer twice** in order to [help you find accidental impurities.](#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect the logic of your component. The result from one of the calls is ignored.\n\n--\n\n### `dispatch` function {/*dispatch*/}\n\nThe `dispatch` function returned by `useReducer` lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the `dispatch` function:\n\n```js\n\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n\nfunction handleClick() {\n\ndispatch({ type: 'incremented_age' });\n\n// ...\n\n```\n\nReact will set the next state to the result of calling the `reducer` function you've provided with the current `state` and the action you've passed to `dispatch`.\n\n#### Parameters {/*dispatch-parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"580":{"pageContent":"#### Parameters {/*dispatch-parameters*/}\n\n`action`: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a `type` property identifying it and, optionally, other properties with additional information.\n\n#### Returns {/*dispatch-returns*/}\n\n`dispatch` functions do not have a return value.\n\n#### Caveats {/*setstate-caveats*/}\n\nThe `dispatch` function **only updates the state variable for the *next* render**. If you read the state variable after calling the `dispatch` function, [you will still get the old value](#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value) that was on the screen before your call.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"581":{"pageContent":"If the new value you provide is identical to the current `state`, as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison, React will **skip re-rendering the component and its children.** This is an optimization. React may still need to call your component before ignoring the result, but it shouldn't affect your code.\n\nReact [batches state updates.](/learn/queueing-a-series-of-state-updates) It updates the screen **after all the event handlers have run** and have called their `set` functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use [`flushSync`.](/reference/react-dom/flushsync)\n\n--\n\n## Usage {/*usage*/}\n\n### Adding a reducer to a component {/*adding-a-reducer-to-a-component*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"582":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Adding a reducer to a component {/*adding-a-reducer-to-a-component*/}\n\nCall `useReducer` at the top level of your component to manage state with a [reducer.](/learn/extracting-state-logic-into-a-reducer)\n\n```js [[1, 8, \"state\"], [2, 8, \"dispatch\"], [4, 8, \"reducer\"], [3, 8, \"{ age: 42 }\"]]\n\nimport { useReducer } from 'react';\n\nfunction reducer(state, action) {\n\n// ...\n\n}\n\nfunction MyComponent() {\n\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n\n// ...\n\n```\n\n`useReducer` returns an array with exactly two items:\n\n1. The <CodeStep step={1}>current state</CodeStep> of this state variable, initially set to the <CodeStep step={3}>initial state</CodeStep> you provided.\n\n2. The <CodeStep step={2}>`dispatch` function</CodeStep> that lets you change it in response to interaction.\n\nTo update what's on the screen, call <CodeStep step={2}>`dispatch`</CodeStep> with an object representing what the user did, called an *action*:\n\n```js [[2, 2, \"dispatch\"]]\n\nfunction handleClick() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"583":{"pageContent":"To update what's on the screen, call <CodeStep step={2}>`dispatch`</CodeStep> with an object representing what the user did, called an *action*:\n\n```js [[2, 2, \"dispatch\"]]\n\nfunction handleClick() {\n\ndispatch({ type: 'incremented_age' });\n\n}\n\n```\n\nReact will pass the current state and the action to your <CodeStep step={4}>reducer function</CodeStep>. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.\n\n<Sandpack>\n\n```js\n\nimport { useReducer } from 'react';\n\nfunction reducer(state, action) {\n\nif (action.type === 'incremented_age') {\n\nreturn {\n\nage: state.age + 1\n\n};\n\n}\n\nthrow Error('Unknown action.');\n\n}\n\nexport default function Counter() {\n\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n\nreturn (\n\n<>\n\n<button onClick={() => {\n\ndispatch({ type: 'incremented_age' })\n\n}}>\n\nIncrement age\n\n</button>\n\n<p>Hello! You are {state.age}.</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"584":{"pageContent":"<>\n\n<button onClick={() => {\n\ndispatch({ type: 'incremented_age' })\n\n}}>\n\nIncrement age\n\n</button>\n\n<p>Hello! You are {state.age}.</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\n`useReducer` is very similar to [`useState`](/reference/react/useState), but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about [choosing between `useState` and `useReducer`.](/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer)\n\n--\n\n### Writing the reducer function {/*writing-the-reducer-function*/}\n\nA reducer function is declared like this:\n\n```js\n\nfunction reducer(state, action) {\n\n// ...\n\n}\n\n```\n\nThen you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a [`switch` statement.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch) For each `case` in the `switch`, you need to calculate and return some next state.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"585":{"pageContent":"```js {4-7,10-13}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\nreturn {\n\nname: state.name,\n\nage: state.age + 1\n\n};\n\n}\n\ncase 'changed_name': {\n\nreturn {\n\nname: action.nextName,\n\nage: state.age\n\n};\n\n}\n\n}\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\n```\n\nActions can have any shape. By convention, it's common to pass objects with a `type` property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.\n\n```js {5,9-12}\n\nfunction Form() {\n\nconst [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });\n\nfunction handleButtonClick() {\n\ndispatch({ type: 'incremented_age' });\n\n}\n\nfunction handleInputChange(e) {\n\ndispatch({\n\ntype: 'changed_name',\n\nnextName: e.target.value\n\n});\n\n}\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"586":{"pageContent":"function handleButtonClick() {\n\ndispatch({ type: 'incremented_age' });\n\n}\n\nfunction handleInputChange(e) {\n\ndispatch({\n\ntype: 'changed_name',\n\nnextName: e.target.value\n\n});\n\n}\n\n// ...\n\n```\n\nThe action type names are local to your component. [Each action describes a single interaction, even if that leads to multiple changes in data.](/learn/extracting-state-logic-into-a-reducer#writing-reducers-well) The shape of the state is arbitrary, but usually it'll be an object or an array.\n\nRead [extracting state logic into a reducer](/learn/extracting-state-logic-into-a-reducer) to learn more.\n\n<Pitfall>\n\nState is read-only. Don't modify any objects or arrays in state:\n\n```js {4,5}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\n// ðŸš© Don't mutate an object in state like this:\n\nstate.age = state.age + 1;\n\nreturn state;\n\n}\n\n```\n\nInstead, always return new objects from your reducer:\n\n```js {4-8}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\n// âœ… Instead, return a new object","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"587":{"pageContent":"return state;\n\n}\n\n```\n\nInstead, always return new objects from your reducer:\n\n```js {4-8}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\n// âœ… Instead, return a new object\n\nreturn {\n\n...state,\n\nage: state.age + 1\n\n};\n\n}\n\n```\n\nRead [updating objects in state](/learn/updating-objects-in-state) and [updating arrays in state](/learn/updating-arrays-in-state) to learn more.\n\n</Pitfall>\n\n<Recipes titleText=\"Basic useReducer examples\" titleId=\"examples-basic\">\n\n#### Form (object) {/*form-object*/}\n\nIn this example, the reducer manages a state object with two fields: `name` and `age`.\n\n<Sandpack>\n\n```js\n\nimport { useReducer } from 'react';\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\nreturn {\n\nname: state.name,\n\nage: state.age + 1\n\n};\n\n}\n\ncase 'changed_name': {\n\nreturn {\n\nname: action.nextName,\n\nage: state.age\n\n};\n\n}\n\n}\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\nconst initialState = { name: 'Taylor', age: 42 };\n\nexport default function Form() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"588":{"pageContent":"}\n\ncase 'changed_name': {\n\nreturn {\n\nname: action.nextName,\n\nage: state.age\n\n};\n\n}\n\n}\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\nconst initialState = { name: 'Taylor', age: 42 };\n\nexport default function Form() {\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n\nfunction handleButtonClick() {\n\ndispatch({ type: 'incremented_age' });\n\n}\n\nfunction handleInputChange(e) {\n\ndispatch({\n\ntype: 'changed_name',\n\nnextName: e.target.value\n\n});\n\n}\n\nreturn (\n\n<>\n\n<input\n\nvalue={state.name}\n\nonChange={handleInputChange}\n\n/>\n\n<button onClick={handleButtonClick}>\n\nIncrement age\n\n</button>\n\n<p>Hello, {state.name}. You are {state.age}.</p>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { display: block; margin-top: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Todo list (array) {/*todo-list-array*/}\n\nIn this example, the reducer manages an array of tasks. The array needs to be updated [without mutation.](/learn/updating-arrays-in-state)\n\n<Sandpack>\n\n```js App.js\n\nimport { useReducer } from 'react';\n\nimport AddTask from './AddTask.js';\n\nimport TaskList from './TaskList.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"589":{"pageContent":"<Sandpack>\n\n```js App.js\n\nimport { useReducer } from 'react';\n\nimport AddTask from './AddTask.js';\n\nimport TaskList from './TaskList.js';\n\nfunction tasksReducer(tasks, action) {\n\nswitch (action.type) {\n\ncase 'added': {\n\nreturn [...tasks, {\n\nid: action.id,\n\ntext: action.text,\n\ndone: false\n\n}];\n\n}\n\ncase 'changed': {\n\nreturn tasks.map(t => {\n\nif (t.id === action.task.id) {\n\nreturn action.task;\n\n} else {\n\nreturn t;\n\n}\n\n});\n\n}\n\ncase 'deleted': {\n\nreturn tasks.filter(t => t.id !== action.id);\n\n}\n\ndefault: {\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\n}\n\n}\n\nexport default function TaskApp() {\n\nconst [tasks, dispatch] = useReducer(\n\ntasksReducer,\n\ninitialTasks\n\n);\n\nfunction handleAddTask(text) {\n\ndispatch({\n\ntype: 'added',\n\nid: nextId++,\n\ntext: text,\n\n});\n\n}\n\nfunction handleChangeTask(task) {\n\ndispatch({\n\ntype: 'changed',\n\ntask: task\n\n});\n\n}\n\nfunction handleDeleteTask(taskId) {\n\ndispatch({\n\ntype: 'deleted',\n\nid: taskId\n\n});\n\n}\n\nreturn (\n\n<>\n\n<h1>Prague itinerary</h1>\n\n<AddTask\n\nonAddTask={handleAddTask}\n\n/>\n\n<TaskList\n\ntasks={tasks}\n\nonChangeTask={handleChangeTask}\n\nonDeleteTask={handleDeleteTask}\n\n/>\n\n</>\n\n);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"590":{"pageContent":"type: 'deleted',\n\nid: taskId\n\n});\n\n}\n\nreturn (\n\n<>\n\n<h1>Prague itinerary</h1>\n\n<AddTask\n\nonAddTask={handleAddTask}\n\n/>\n\n<TaskList\n\ntasks={tasks}\n\nonChangeTask={handleChangeTask}\n\nonDeleteTask={handleDeleteTask}\n\n/>\n\n</>\n\n);\n\n}\n\nlet nextId = 3;\n\nconst initialTasks = [\n\n{ id: 0, text: 'Visit Kafka Museum', done: true },\n\n{ id: 1, text: 'Watch a puppet show', done: false },\n\n{ id: 2, text: 'Lennon Wall pic', done: false }\n\n];\n\n```\n\n```js AddTask.js hidden\n\nimport { useState } from 'react';\n\nexport default function AddTask({ onAddTask }) {\n\nconst [text, setText] = useState('');\n\nreturn (\n\n<>\n\n<input\n\nplaceholder=\"Add task\"\n\nvalue={text}\n\nonChange={e => setText(e.target.value)}\n\n/>\n\n<button onClick={() => {\n\nsetText('');\n\nonAddTask(text);\n\n}}>Add</button>\n\n</>\n\n)\n\n}\n\n```\n\n```js TaskList.js hidden\n\nimport { useState } from 'react';\n\nexport default function TaskList({\n\ntasks,\n\nonChangeTask,\n\nonDeleteTask\n\n}) {\n\nreturn (\n\n<ul>\n\n{tasks.map(task => (\n\n<li key={task.id}>\n\n<Task\n\ntask={task}\n\nonChange={onChangeTask}\n\nonDelete={onDeleteTask}\n\n/>\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\nfunction Task({ task, onChange, onDelete }) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"591":{"pageContent":"onDeleteTask\n\n}) {\n\nreturn (\n\n<ul>\n\n{tasks.map(task => (\n\n<li key={task.id}>\n\n<Task\n\ntask={task}\n\nonChange={onChangeTask}\n\nonDelete={onDeleteTask}\n\n/>\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\nfunction Task({ task, onChange, onDelete }) {\n\nconst [isEditing, setIsEditing] = useState(false);\n\nlet taskContent;\n\nif (isEditing) {\n\ntaskContent = (\n\n<>\n\n<input\n\nvalue={task.text}\n\nonChange={e => {\n\nonChange({\n\n...task,\n\ntext: e.target.value\n\n});\n\n}} />\n\n<button onClick={() => setIsEditing(false)}>\n\nSave\n\n</button>\n\n</>\n\n);\n\n} else {\n\ntaskContent = (\n\n<>\n\n{task.text}\n\n<button onClick={() => setIsEditing(true)}>\n\nEdit\n\n</button>\n\n</>\n\n);\n\n}\n\nreturn (\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={task.done}\n\nonChange={e => {\n\nonChange({\n\n...task,\n\ndone: e.target.checked\n\n});\n\n}}\n\n/>\n\n{taskContent}\n\n<button onClick={() => onDelete(task.id)}>\n\nDelete\n\n</button>\n\n</label>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin: 5px; }\n\nli { list-style-type: none; }\n\nul, li { margin: 0; padding: 0; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Writing concise update logic with Immer {/*writing-concise-update-logic-with-immer*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"592":{"pageContent":"li { list-style-type: none; }\n\nul, li { margin: 0; padding: 0; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Writing concise update logic with Immer {/*writing-concise-update-logic-with-immer*/}\n\nIf updating arrays and objects without mutation feels tedious, you can use a library like [Immer](https://github.com/immerjs/use-immer#useimmerreducer) to reduce repetitive code. Immer lets you write concise code as if you were mutating objects, but under the hood it performs immutable updates:\n\n<Sandpack>\n\n```js App.js\n\nimport { useImmerReducer } from 'use-immer';\n\nimport AddTask from './AddTask.js';\n\nimport TaskList from './TaskList.js';\n\nfunction tasksReducer(draft, action) {\n\nswitch (action.type) {\n\ncase 'added': {\n\ndraft.push({\n\nid: action.id,\n\ntext: action.text,\n\ndone: false\n\n});\n\nbreak;\n\n}\n\ncase 'changed': {\n\nconst index = draft.findIndex(t =>\n\nt.id === action.task.id\n\n);\n\ndraft[index] = action.task;\n\nbreak;\n\n}\n\ncase 'deleted': {\n\nreturn draft.filter(t => t.id !== action.id);\n\n}\n\ndefault: {\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\n}\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"593":{"pageContent":"t.id === action.task.id\n\n);\n\ndraft[index] = action.task;\n\nbreak;\n\n}\n\ncase 'deleted': {\n\nreturn draft.filter(t => t.id !== action.id);\n\n}\n\ndefault: {\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\n}\n\n}\n\nexport default function TaskApp() {\n\nconst [tasks, dispatch] = useImmerReducer(\n\ntasksReducer,\n\ninitialTasks\n\n);\n\nfunction handleAddTask(text) {\n\ndispatch({\n\ntype: 'added',\n\nid: nextId++,\n\ntext: text,\n\n});\n\n}\n\nfunction handleChangeTask(task) {\n\ndispatch({\n\ntype: 'changed',\n\ntask: task\n\n});\n\n}\n\nfunction handleDeleteTask(taskId) {\n\ndispatch({\n\ntype: 'deleted',\n\nid: taskId\n\n});\n\n}\n\nreturn (\n\n<>\n\n<h1>Prague itinerary</h1>\n\n<AddTask\n\nonAddTask={handleAddTask}\n\n/>\n\n<TaskList\n\ntasks={tasks}\n\nonChangeTask={handleChangeTask}\n\nonDeleteTask={handleDeleteTask}\n\n/>\n\n</>\n\n);\n\n}\n\nlet nextId = 3;\n\nconst initialTasks = [\n\n{ id: 0, text: 'Visit Kafka Museum', done: true },\n\n{ id: 1, text: 'Watch a puppet show', done: false },\n\n{ id: 2, text: 'Lennon Wall pic', done: false },\n\n];\n\n```\n\n```js AddTask.js hidden\n\nimport { useState } from 'react';\n\nexport default function AddTask({ onAddTask }) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"594":{"pageContent":"{ id: 2, text: 'Lennon Wall pic', done: false },\n\n];\n\n```\n\n```js AddTask.js hidden\n\nimport { useState } from 'react';\n\nexport default function AddTask({ onAddTask }) {\n\nconst [text, setText] = useState('');\n\nreturn (\n\n<>\n\n<input\n\nplaceholder=\"Add task\"\n\nvalue={text}\n\nonChange={e => setText(e.target.value)}\n\n/>\n\n<button onClick={() => {\n\nsetText('');\n\nonAddTask(text);\n\n}}>Add</button>\n\n</>\n\n)\n\n}\n\n```\n\n```js TaskList.js hidden\n\nimport { useState } from 'react';\n\nexport default function TaskList({\n\ntasks,\n\nonChangeTask,\n\nonDeleteTask\n\n}) {\n\nreturn (\n\n<ul>\n\n{tasks.map(task => (\n\n<li key={task.id}>\n\n<Task\n\ntask={task}\n\nonChange={onChangeTask}\n\nonDelete={onDeleteTask}\n\n/>\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\nfunction Task({ task, onChange, onDelete }) {\n\nconst [isEditing, setIsEditing] = useState(false);\n\nlet taskContent;\n\nif (isEditing) {\n\ntaskContent = (\n\n<>\n\n<input\n\nvalue={task.text}\n\nonChange={e => {\n\nonChange({\n\n...task,\n\ntext: e.target.value\n\n});\n\n}} />\n\n<button onClick={() => setIsEditing(false)}>\n\nSave\n\n</button>\n\n</>\n\n);\n\n} else {\n\ntaskContent = (\n\n<>\n\n{task.text}\n\n<button onClick={() => setIsEditing(true)}>\n\nEdit\n\n</button>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"595":{"pageContent":"onChange({\n\n...task,\n\ntext: e.target.value\n\n});\n\n}} />\n\n<button onClick={() => setIsEditing(false)}>\n\nSave\n\n</button>\n\n</>\n\n);\n\n} else {\n\ntaskContent = (\n\n<>\n\n{task.text}\n\n<button onClick={() => setIsEditing(true)}>\n\nEdit\n\n</button>\n\n</>\n\n);\n\n}\n\nreturn (\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={task.done}\n\nonChange={e => {\n\nonChange({\n\n...task,\n\ndone: e.target.checked\n\n});\n\n}}\n\n/>\n\n{taskContent}\n\n<button onClick={() => onDelete(task.id)}>\n\nDelete\n\n</button>\n\n</label>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin: 5px; }\n\nli { list-style-type: none; }\n\nul, li { margin: 0; padding: 0; }\n\n```\n\n```json package.json\n\n{\n\n\"dependencies\": {\n\n\"immer\": \"1.7.3\",\n\n\"react\": \"latest\",\n\n\"react-dom\": \"latest\",\n\n\"react-scripts\": \"latest\",\n\n\"use-immer\": \"0.5.1\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Avoiding recreating the initial state {/*avoiding-recreating-the-initial-state*/}\n\nReact saves the initial state once and ignores it on the next renders.\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"596":{"pageContent":"}\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Avoiding recreating the initial state {/*avoiding-recreating-the-initial-state*/}\n\nReact saves the initial state once and ignores it on the next renders.\n\n```js\n\nfunction createInitialState(username) {\n\n// ...\n\n}\n\nfunction TodoList({ username }) {\n\nconst [state, dispatch] = useReducer(reducer, createInitialState(username));\n\n// ...\n\n```\n\nAlthough the result of `createInitialState(username)` is only used for the initial render, you're still calling this function on every render. This can be wasteful if it's creating large arrays or performing expensive calculations.\n\nTo solve this, you may **pass it as an _initializer_ function** to `useReducer` as the third argument instead:\n\n```js {6}\n\nfunction createInitialState(username) {\n\n// ...\n\n}\n\nfunction TodoList({ username }) {\n\nconst [state, dispatch] = useReducer(reducer, username, createInitialState);\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"597":{"pageContent":"```js {6}\n\nfunction createInitialState(username) {\n\n// ...\n\n}\n\nfunction TodoList({ username }) {\n\nconst [state, dispatch] = useReducer(reducer, username, createInitialState);\n\n// ...\n\n```\n\nNotice that youâ€™re passing `createInitialState`, which is the *function itself*, and not `createInitialState()`, which is the result of calling it. This way, the initial state does not get re-created after initialization.\n\nIn the above example, `createInitialState` takes a `username` argument. If your initializer doesn't need any information to compute the initial state, you may pass `null` as the second argument to `useReducer`.\n\n<Recipes titleText=\"The difference between passing an initializer and passing the initial state directly\" titleId=\"examples-initializer\">\n\n#### Passing the initializer function {/*passing-the-initializer-function*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"598":{"pageContent":"#### Passing the initializer function {/*passing-the-initializer-function*/}\n\nThis example passes the initializer function, so the `createInitialState` function only runs during initialization. It does not run when component re-renders, such as when you type into the input.\n\n<Sandpack>\n\n```js App.js hidden\n\nimport TodoList from './TodoList.js';\n\nexport default function App() {\n\nreturn <TodoList username=\"Taylor\" />;\n\n}\n\n```\n\n```js TodoList.js active\n\nimport { useReducer } from 'react';\n\nfunction createInitialState(username) {\n\nconst initialTodos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ninitialTodos.push({\n\nid: i,\n\ntext: username + \"'s task #\" + (i + 1)\n\n});\n\n}\n\nreturn {\n\ndraft: '',\n\ntodos: initialTodos,\n\n};\n\n}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'changed_draft': {\n\nreturn {\n\ndraft: action.nextDraft,\n\ntodos: state.todos,\n\n};\n\n};\n\ncase 'added_todo': {\n\nreturn {\n\ndraft: '',\n\ntodos: [{\n\nid: state.todos.length,\n\ntext: state.draft\n\n}, ...state.todos]\n\n}\n\n}\n\n}\n\nthrow Error('Unknown action: ' + action.type);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"599":{"pageContent":"todos: state.todos,\n\n};\n\n};\n\ncase 'added_todo': {\n\nreturn {\n\ndraft: '',\n\ntodos: [{\n\nid: state.todos.length,\n\ntext: state.draft\n\n}, ...state.todos]\n\n}\n\n}\n\n}\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\nexport default function TodoList({ username }) {\n\nconst [state, dispatch] = useReducer(\n\nreducer,\n\nusername,\n\ncreateInitialState\n\n);\n\nreturn (\n\n<>\n\n<input\n\nvalue={state.draft}\n\nonChange={e => {\n\ndispatch({\n\ntype: 'changed_draft',\n\nnextDraft: e.target.value\n\n})\n\n}}\n\n/>\n\n<button onClick={() => {\n\ndispatch({ type: 'added_todo' });\n\n}}>Add</button>\n\n<ul>\n\n{state.todos.map(item => (\n\n<li key={item.id}>\n\n{item.text}\n\n</li>\n\n))}\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Passing the initial state directly {/*passing-the-initial-state-directly*/}\n\nThis example **does not** pass the initializer function, so the `createInitialState` function runs on every render, such as when you type into the input. There is no observable difference in behavior, but this code is less efficient.\n\n<Sandpack>\n\n```js App.js hidden\n\nimport TodoList from './TodoList.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"600":{"pageContent":"<Sandpack>\n\n```js App.js hidden\n\nimport TodoList from './TodoList.js';\n\nexport default function App() {\n\nreturn <TodoList username=\"Taylor\" />;\n\n}\n\n```\n\n```js TodoList.js active\n\nimport { useReducer } from 'react';\n\nfunction createInitialState(username) {\n\nconst initialTodos = [];\n\nfor (let i = 0; i < 50; i++) {\n\ninitialTodos.push({\n\nid: i,\n\ntext: username + \"'s task #\" + (i + 1)\n\n});\n\n}\n\nreturn {\n\ndraft: '',\n\ntodos: initialTodos,\n\n};\n\n}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'changed_draft': {\n\nreturn {\n\ndraft: action.nextDraft,\n\ntodos: state.todos,\n\n};\n\n};\n\ncase 'added_todo': {\n\nreturn {\n\ndraft: '',\n\ntodos: [{\n\nid: state.todos.length,\n\ntext: state.draft\n\n}, ...state.todos]\n\n}\n\n}\n\n}\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\nexport default function TodoList({ username }) {\n\nconst [state, dispatch] = useReducer(\n\nreducer,\n\ncreateInitialState(username)\n\n);\n\nreturn (\n\n<>\n\n<input\n\nvalue={state.draft}\n\nonChange={e => {\n\ndispatch({\n\ntype: 'changed_draft',\n\nnextDraft: e.target.value\n\n})\n\n}}\n\n/>\n\n<button onClick={() => {\n\ndispatch({ type: 'added_todo' });\n\n}}>Add</button>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"601":{"pageContent":");\n\nreturn (\n\n<>\n\n<input\n\nvalue={state.draft}\n\nonChange={e => {\n\ndispatch({\n\ntype: 'changed_draft',\n\nnextDraft: e.target.value\n\n})\n\n}}\n\n/>\n\n<button onClick={() => {\n\ndispatch({ type: 'added_todo' });\n\n}}>Add</button>\n\n<ul>\n\n{state.todos.map(item => (\n\n<li key={item.id}>\n\n{item.text}\n\n</li>\n\n))}\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### I've dispatched an action, but logging gives me the old state value {/*ive-dispatched-an-action-but-logging-gives-me-the-old-state-value*/}\n\nCalling the `dispatch` function **does not change state in the running code**:\n\n```js {4,5,8}\n\nfunction handleClick() {\n\nconsole.log(state.age);  // 42\n\ndispatch({ type: 'incremented_age' }); // Request a re-render with 43\n\nconsole.log(state.age);  // Still 42!\n\nsetTimeout(() => {\n\nconsole.log(state.age); // Also 42!\n\n}, 5000);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"602":{"pageContent":"dispatch({ type: 'incremented_age' }); // Request a re-render with 43\n\nconsole.log(state.age);  // Still 42!\n\nsetTimeout(() => {\n\nconsole.log(state.age); // Also 42!\n\n}, 5000);\n\n}\n\n```\n\nThis is because [states behaves like a snapshot.](/learn/state-as-a-snapshot) Updating state requests another render with the new state value, but does not affect the `state` JavaScript variable in your already-running event handler.\n\nIf you need to guess the next state value, you can calculate it manually by calling the reducer yourself:\n\n```js\n\nconst action = { type: 'incremented_age' };\n\ndispatch(action);\n\nconst nextState = reducer(state, action);\n\nconsole.log(state);     // { age: 42 }\n\nconsole.log(nextState); // { age: 43 }\n\n```\n\n--\n\n### I've dispatched an action, but the screen doesn't update {/*ive-dispatched-an-action-but-the-screen-doesnt-update*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"603":{"pageContent":"console.log(nextState); // { age: 43 }\n\n```\n\n--\n\n### I've dispatched an action, but the screen doesn't update {/*ive-dispatched-an-action-but-the-screen-doesnt-update*/}\n\nReact will **ignore your update if the next state is equal to the previous state,** as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. This usually happens when you change an object or an array in state directly:\n\n```js {4-5,9-10}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\n// ðŸš© Wrong: mutating existing object\n\nstate.age++;\n\nreturn state;\n\n}\n\ncase 'changed_name': {\n\n// ðŸš© Wrong: mutating existing object\n\nstate.name = action.nextName;\n\nreturn state;\n\n}\n\n// ...\n\n}\n\n}\n\n```\n\nYou mutated an existing `state` object and returned it, so React ignored the update. To fix this, you need to ensure that you're always [_replacing_ objects and arrays in state instead of _mutating_ them](#updating-objects-and-arrays-in-state):\n\n```js {4-8,11-15}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"604":{"pageContent":"```js {4-8,11-15}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\n// âœ… Correct: creating a new object\n\nreturn {\n\n...state,\n\nage: state.age + 1\n\n};\n\n}\n\ncase 'changed_name': {\n\n// âœ… Correct: creating a new object\n\nreturn {\n\n...state,\n\nname: action.nextName\n\n};\n\n}\n\n// ...\n\n}\n\n}\n\n```\n\n--\n\n### A part of my reducer state becomes undefined after dispatching {/*a-part-of-my-reducer-state-becomes-undefined-after-dispatching*/}\n\nMake sure that every `case` branch **copies all of the existing fields** when returning the new state:\n\n```js {5}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\nreturn {\n\n...state, // Don't forget this!\n\nage: state.age + 1\n\n};\n\n}\n\n// ...\n\n```\n\nWithout `...state` above, the returned next state would only contain the `age` field and nothing else.\n\n--\n\n### My entire reducer state becomes undefined after dispatching {/*my-entire-reducer-state-becomes-undefined-after-dispatching*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"605":{"pageContent":"--\n\n### My entire reducer state becomes undefined after dispatching {/*my-entire-reducer-state-becomes-undefined-after-dispatching*/}\n\nIf your state unexpectedly becomes `undefined`, you're likely forgetting to `return` state in one of the cases, or your action type doesn't match any of the `case` statements. To find why, throw an error outside the `switch`:\n\n```js {10}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'incremented_age': {\n\n// ...\n\n}\n\ncase 'edited_name': {\n\n// ...\n\n}\n\n}\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\n```\n\nYou can also use a static type checker like TypeScript to catch such mistakes.\n\n--\n\n### I'm getting an error: \"Too many re-renders\" {/*im-getting-an-error-too-many-re-renders*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"606":{"pageContent":"}\n\n```\n\nYou can also use a static type checker like TypeScript to catch such mistakes.\n\n--\n\n### I'm getting an error: \"Too many re-renders\" {/*im-getting-an-error-too-many-re-renders*/}\n\nYou might get an error that says: `Too many re-renders. React limits the number of renders to prevent an infinite loop.` Typically, this means that you're unconditionally dispatching an action *during render*, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n\n```js {1-2}\n\n// ðŸš© Wrong: calls the handler during render\n\nreturn <button onClick={handleClick()}>Click me</button>\n\n// âœ… Correct: passes down the event handler\n\nreturn <button onClick={handleClick}>Click me</button>\n\n// âœ… Correct: passes down an inline function\n\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"607":{"pageContent":"return <button onClick={handleClick}>Click me</button>\n\n// âœ… Correct: passes down an inline function\n\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n\n```\n\nIf you can't find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific `dispatch` function call responsible for the error.\n\n--\n\n### My reducer or initializer function runs twice {/*my-reducer-or-initializer-function-runs-twice*/}\n\nIn [Strict Mode](/reference/react/StrictMode), React will call your reducer and initializer functions twice. This shouldn't break your code.\n\nThis **development-only** behavior helps you [keep components pure.](/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn't affect your logic. However, if they are accidentally impure, this helps you notice the mistakes and fix it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"608":{"pageContent":"For example, this impure reducer function mutates an array in state:\n\n```js {4-6}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'added_todo': {\n\n// ðŸš© Mistake: mutating state\n\nstate.todos.push({ id: nextId++, text: action.text });\n\nreturn state;\n\n}\n\n// ...\n\n}\n\n}\n\n```\n\nBecause React calls your reducer function twice, you'll see the todo was added twice, so you'll know that there is a mistake. In this example, you can fix the mistake by [replacing the array instead of mutating it](#updating-objects-and-arrays-in-state):\n\n```js {4-11}\n\nfunction reducer(state, action) {\n\nswitch (action.type) {\n\ncase 'added_todo': {\n\n// âœ… Correct: replacing with new state\n\nreturn {\n\n...state,\n\ntodos: [\n\n...state.todos,\n\n{ id: nextId++, text: action.text }\n\n]\n\n};\n\n}\n\n// ...\n\n}\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"609":{"pageContent":"switch (action.type) {\n\ncase 'added_todo': {\n\n// âœ… Correct: replacing with new state\n\nreturn {\n\n...state,\n\ntodos: [\n\n...state.todos,\n\n{ id: nextId++, text: action.text }\n\n]\n\n};\n\n}\n\n// ...\n\n}\n\n}\n\n```\n\nNow that this reducer function is pure, calling it an extra time doesn't make a difference in behavior. This is why React calling it twice helps you find mistakes. **Only component, initializer, and reducer functions need to be pure.** Event handlers don't need to be pure, so React will never call your event handlers twice.\n\nRead [keeping components pure](/learn/keeping-components-pure) to learn more.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useReducer.md"}},"610":{"pageContent":"--\n\ntitle: forwardRef\n\n--\n\n<Intro>\n\n`forwardRef` lets your component expose a DOM node to parent component with a [ref.](/learn/manipulating-the-dom-with-refs)\n\n```js\n\nconst SomeComponent = forwardRef(render)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `forwardRef(render)` {/*forwardref*/}\n\nCall `forwardRef()` to let your component receive a ref and forward it to a child component:\n\n```js\n\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\n// ...\n\n});\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`render`: The render function for your component. React calls this function with the props and `ref` that your component received from its parent. The JSX you return will be the output of your component.\n\n#### Returns {/*returns*/}\n\n`forwardRef` returns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by `forwardRef` is also able to receive a `ref` prop.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"611":{"pageContent":"`forwardRef` returns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by `forwardRef` is also able to receive a `ref` prop.\n\n#### Caveats {/*caveats*/}\n\nIn Strict Mode, React will **call your render function twice** in order to [help you find accidental impurities.](#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.\n\n--\n\n### `render` function {/*render-function*/}\n\n`forwardRef` accepts a render function as an argument. React calls this function with `props` and `ref`:\n\n```js\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nreturn (\n\n<label>\n\n{props.label}\n\n<input ref={ref} />\n\n</label>\n\n);\n\n});\n\n```\n\n#### Parameters {/*render-parameters*/}\n\n`props`: The props passed by the parent component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"612":{"pageContent":"return (\n\n<label>\n\n{props.label}\n\n<input ref={ref} />\n\n</label>\n\n);\n\n});\n\n```\n\n#### Parameters {/*render-parameters*/}\n\n`props`: The props passed by the parent component.\n\n`ref`:  The `ref` attribute passed by the parent component. The `ref` can be an object or a function. If the parent component has not passed a ref, it will be `null`. You should either pass the `ref` you receive to another component, or pass it to [`useImperativeHandle`.](/reference/react/useImperativeHandle)\n\n#### Returns {/*render-returns*/}\n\n`forwardRef` returns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned by `forwardRef` is able to take a `ref` prop.\n\n--\n\n## Usage {/*usage*/}\n\n### Exposing a DOM node to the parent component {/*exposing-a-dom-node-to-the-parent-component*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"613":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Exposing a DOM node to the parent component {/*exposing-a-dom-node-to-the-parent-component*/}\n\nBy default, each component's DOM nodes are private. However, sometimes it's useful to expose a DOM node to the parent--for example, to allow focusing it. To opt in, wrap your component definition into `forwardRef()`:\n\n```js {3,11}\n\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst { label, ...otherProps } = props;\n\nreturn (\n\n<label>\n\n{label}\n\n<input {...otherProps} />\n\n</label>\n\n);\n\n});\n\n```\n\nYou will receive a <CodeStep step={1}>ref</CodeStep> as the second argument after props. Pass it to the DOM node that you want to expose:\n\n```js {8} [[1, 3, \"ref\"], [1, 8, \"ref\", 30]]\n\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst { label, ...otherProps } = props;\n\nreturn (\n\n<label>\n\n{label}\n\n<input {...otherProps} ref={ref} />\n\n</label>\n\n);\n\n});\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"614":{"pageContent":"const MyInput = forwardRef(function MyInput(props, ref) {\n\nconst { label, ...otherProps } = props;\n\nreturn (\n\n<label>\n\n{label}\n\n<input {...otherProps} ref={ref} />\n\n</label>\n\n);\n\n});\n\n```\n\nThis lets the parent `Form` component access the <CodeStep step={2}>`<input>` DOM node</CodeStep> exposed by `MyInput`:\n\n```js [[1, 2, \"ref\"], [1, 10, \"ref\", 41], [2, 5, \"ref.current\"]]\n\nfunction Form() {\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nref.current.focus();\n\n}\n\nreturn (\n\n<form>\n\n<MyInput label=\"Enter your name:\" ref={ref} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\nThis `Form` component [passes a ref](/reference/useref#manipulating-the-dom-with-a-ref) to `MyInput`. The `MyInput` component *forwards* that ref to the `<input>` browser tag. As a result, the `Form` component can access that `<input>` DOM node and call [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on it.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"615":{"pageContent":"Keep in mind that by exposing a ref to the DOM node inside your component, you're making it harder to change your component's internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won't do it for application-level components like an avatar or a comment.\n\n<Recipes title=\"Examples of forwarding a ref\">\n\n#### Focusing a text input {/*focusing-a-text-input*/}\n\nClicking the button will focus the input. The `Form` component defines a ref and passes it to the `MyInput` component. The `MyInput` component forwards that ref to the browser `<input>`. This lets the `Form` component focus the `<input>`.\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nref.current.focus();\n\n}\n\nreturn (\n\n<form>\n\n<MyInput label=\"Enter your name:\" ref={ref} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\n```js MyInput.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"616":{"pageContent":"function handleClick() {\n\nref.current.focus();\n\n}\n\nreturn (\n\n<form>\n\n<MyInput label=\"Enter your name:\" ref={ref} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\n```js MyInput.js\n\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst { label, ...otherProps } = props;\n\nreturn (\n\n<label>\n\n{label}\n\n<input {...otherProps} ref={ref} />\n\n</label>\n\n);\n\n});\n\nexport default MyInput;\n\n```\n\n```css\n\ninput {\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Playing and pausing a video {/*playing-and-pausing-a-video*/}\n\nClicking the button will call [`play()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play) and [`pause()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause) on a `<video>` DOM node. The `App` component defines a ref and passes it to the `MyVideoPlayer` component. The `MyVideoPlayer` component forwards that ref to the browser `<video>` node. This lets the `App` component play and pause the `<video>`.\n\n<Sandpack>\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"617":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport MyVideoPlayer from './MyVideoPlayer.js';\n\nexport default function App() {\n\nconst ref = useRef(null);\n\nreturn (\n\n<>\n\n<button onClick={() => ref.current.play()}>\n\nPlay\n\n</button>\n\n<button onClick={() => ref.current.pause()}>\n\nPause\n\n</button>\n\n<br />\n\n<MyVideoPlayer\n\nref={ref}\n\nsrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n\ntype=\"video/mp4\"\n\nwidth=\"250\"\n\n/>\n\n</>\n\n);\n\n}\n\n```\n\n```js MyVideoPlayer.js\n\nimport { forwardRef } from 'react';\n\nconst VideoPlayer = forwardRef(function VideoPlayer({ src, type, width }, ref) {\n\nreturn (\n\n<video width={width} ref={ref}>\n\n<source\n\nsrc={src}\n\ntype={type}\n\n/>\n\n</video>\n\n);\n\n});\n\nexport default VideoPlayer;\n\n```\n\n```css\n\nbutton { margin-bottom: 10px; margin-right: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Forwarding a ref through multiple components {/*forwarding-a-ref-through-multiple-components*/}\n\nInstead of forwarding a `ref` to a DOM node, you can forward it to your own component like `MyInput`:\n\n```js {1,5}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"618":{"pageContent":"Instead of forwarding a `ref` to a DOM node, you can forward it to your own component like `MyInput`:\n\n```js {1,5}\n\nconst FormField = forwardRef(function FormField(props, ref) {\n\n// ...\n\nreturn (\n\n<>\n\n<MyInput ref={ref} />\n\n...\n\n</>\n\n);\n\n});\n\n```\n\nIf that `MyInput` component forwards a ref to its `<input>`, a ref to `FormField` will give you that `<input>`:\n\n```js {2,5,10}\n\nfunction Form() {\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nref.current.focus();\n\n}\n\nreturn (\n\n<form>\n\n<FormField label=\"Enter your name:\" ref={ref} isRequired={true} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\nThe `Form` component defines a ref and passes it to `FormField`. The `FormField` component forwards that ref to `MyInput`, which forwards this ref to a browser `<input>` DOM node. This is how `Form` accesses that DOM node.\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport FormField from './FormField.js';\n\nexport default function Form() {\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nref.current.focus();\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"619":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport FormField from './FormField.js';\n\nexport default function Form() {\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nref.current.focus();\n\n}\n\nreturn (\n\n<form>\n\n<FormField label=\"Enter your name:\" ref={ref} isRequired={true} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\n```js FormField.js\n\nimport { forwardRef, useState } from 'react';\n\nimport MyInput from './MyInput.js';\n\nconst FormField = forwardRef(function FormField({ label, isRequired }, ref) {\n\nconst [value, setValue] = useState('');\n\nreturn (\n\n<>\n\n<MyInput\n\nref={ref}\n\nlabel={label}\n\nvalue={value}\n\nonChange={e => setValue(e.target.value)}\n\n/>\n\n{(isRequired && value === '') &&\n\n<i>Required</i>\n\n}\n\n</>\n\n);\n\n});\n\nexport default FormField;\n\n```\n\n```js MyInput.js\n\nimport { forwardRef } from 'react';\n\nconst MyInput = forwardRef((props, ref) => {\n\nconst { label, ...otherProps } = props;\n\nreturn (\n\n<label>\n\n{label}\n\n<input {...otherProps} ref={ref} />\n\n</label>\n\n);\n\n});\n\nexport default MyInput;\n\n```\n\n```css\n\ninput, button {\n\nmargin: 5px;\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"620":{"pageContent":"const { label, ...otherProps } = props;\n\nreturn (\n\n<label>\n\n{label}\n\n<input {...otherProps} ref={ref} />\n\n</label>\n\n);\n\n});\n\nexport default MyInput;\n\n```\n\n```css\n\ninput, button {\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Exposing an imperative handle instead of a DOM node {/*exposing-an-imperative-handle-instead-of-a-dom-node*/}\n\nInstead of exposing an entire DOM node, you can expose a custom object, called an *imperative handle,* with a more constrained set of methods. To do this, you'd need to define a separate ref to hold the DOM node:\n\n```js {2,6}\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst inputRef = useRef(null);\n\n// ...\n\nreturn <input {...props} ref={inputRef} />;\n\n});\n\n```\n\nThen pass the `ref` you received to [`useImperativeHandle`](/reference/react/useImperativeHandle) and specify the value you want to expose to the `ref`:\n\n```js {6-15}\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst inputRef = useRef(null);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"621":{"pageContent":"```js {6-15}\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst inputRef = useRef(null);\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\nfocus() {\n\ninputRef.current.focus();\n\n},\n\nscrollIntoView() {\n\ninputRef.current.scrollIntoView();\n\n},\n\n};\n\n}, []);\n\nreturn <input {...props} ref={inputRef} />;\n\n});\n\n```\n\nIf some component gets a ref to `MyInput` now, it will only receive your `{ focus, scrollIntoView }` object instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum.\n\n<Sandpack>\n\n```js\n\nimport { useRef } from 'react';\n\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n\nconst ref = useRef(null);\n\nfunction handleClick() {\n\nref.current.focus();\n\n// This won't work because the DOM node isn't exposed:\n\n// ref.current.style.opacity = 0.5;\n\n}\n\nreturn (\n\n<form>\n\n<MyInput label=\"Enter your name:\" ref={ref} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\n```js MyInput.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"622":{"pageContent":"// ref.current.style.opacity = 0.5;\n\n}\n\nreturn (\n\n<form>\n\n<MyInput label=\"Enter your name:\" ref={ref} />\n\n<button type=\"button\" onClick={handleClick}>\n\nEdit\n\n</button>\n\n</form>\n\n);\n\n}\n\n```\n\n```js MyInput.js\n\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst MyInput = forwardRef(function MyInput(props, ref) {\n\nconst inputRef = useRef(null);\n\nuseImperativeHandle(ref, () => {\n\nreturn {\n\nfocus() {\n\ninputRef.current.focus();\n\n},\n\nscrollIntoView() {\n\ninputRef.current.scrollIntoView();\n\n},\n\n};\n\n}, []);\n\nreturn <input {...props} ref={inputRef} />;\n\n});\n\nexport default MyInput;\n\n```\n\n```css\n\ninput {\n\nmargin: 5px;\n\n}\n\n```\n\n</Sandpack>\n\n[Read more about using imperative handles.](/reference/react/useImperativeHandle)\n\n<Pitfall>\n\n*Do not overuse refs.** You should only use refs for *imperative* behaviors that you can't express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"623":{"pageContent":"*If you can express something as a prop, you should not use a ref.** For example, instead of exposing an imperative handle like `{ open, close }` from a `Modal` component, it is better to take `isOpen` as a prop like `<Modal isOpen={isOpen} />`. [Effects](/learn/synchronizing-with-effects) can help you expose imperative behaviors via props.\n\n</Pitfall>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### My component is wrapped in `forwardRef`, but the `ref` to it is always `null` {/*my-component-is-wrapped-in-forwardref-but-the-ref-to-it-is-always-null*/}\n\nThis usually means that you forgot to actually use the `ref` that you received.\n\nFor example, this component doesn't do anything with its `ref`:\n\n```js {1}\n\nconst MyInput = forwardRef(function MyInput({ label }, ref) {\n\nreturn (\n\n<label>\n\n{label}\n\n<input />\n\n</label>\n\n);\n\n});\n\n```\n\nTo fix it, pass the `ref` down to a DOM node or another component that can accept a ref:\n\n```js {1,5}\n\nconst MyInput = forwardRef(function MyInput({ label }, ref) {\n\nreturn (\n\n<label>\n\n{label}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"624":{"pageContent":"</label>\n\n);\n\n});\n\n```\n\nTo fix it, pass the `ref` down to a DOM node or another component that can accept a ref:\n\n```js {1,5}\n\nconst MyInput = forwardRef(function MyInput({ label }, ref) {\n\nreturn (\n\n<label>\n\n{label}\n\n<input ref={ref} />\n\n</label>\n\n);\n\n});\n\n```\n\nThe `ref` to `MyInput` could also be `null` if some of the logic is conditional:\n\n```js {1,5}\n\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\n\nreturn (\n\n<label>\n\n{label}\n\n{showInput && <input ref={ref} />}\n\n</label>\n\n);\n\n});\n\n```\n\nIf `showInput` is `false`, then the ref won't be forwarded to any node, and a ref to `MyInput` will remain empty. This is particularly easy to miss if the condition is hidden inside another component, like `Panel` in this example:\n\n```js {5,7}\n\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\n\nreturn (\n\n<label>\n\n{label}\n\n<Panel isExpanded={showInput}>\n\n<input ref={ref} />\n\n</Panel>\n\n</label>\n\n);\n\n});\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/forwardRef.md"}},"625":{"pageContent":"--\n\ntitle: useDebugValue\n\n--\n\n<Intro>\n\n`useDebugValue` is a React Hook that lets you add a label to a custom Hook in [React DevTools.](/learn/react-developer-tools)\n\n```js\n\nuseDebugValue(value, format?)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useDebugValue(value, format?)` {/*usedebugvalue*/}\n\nCall `useDebugValue` at the top level of your [custom Hook](/learn/reusing-logic-with-custom-hooks) to display a readable debug value:\n\n```js\n\nimport { useDebugValue } from 'react';\n\nfunction useOnlineStatus() {\n\n// ...\n\nuseDebugValue(isOnline ? 'Online' : 'Offline');\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`value`: The value you want to display in React DevTools. It can have any type.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDebugValue.md"}},"626":{"pageContent":"// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`value`: The value you want to display in React DevTools. It can have any type.\n\n**optional** `format`: A formatting function. When the component is inspected, React DevTools will call the formatting function with the `value` as the argument, and then display the returned formatted value (which may have any type). If you don't specify the formatting function, the original `value` itself will be displayed.\n\n#### Returns {/*returns*/}\n\n`useDebugValue` does not return anything.\n\n## Usage {/*usage*/}\n\n### Adding a label to a custom Hook {/*adding-a-label-to-a-custom-hook*/}\n\nCall `useDebugValue` at the top level of your [custom Hook](/learn/reusing-logic-with-custom-hooks) to display a readable <CodeStep step={1}>debug value</CodeStep> for [React DevTools.](/learn/react-developer-tools)\n\n```js [[1, 5, \"isOnline ? 'Online' : 'Offline'\"]]\n\nimport { useDebugValue } from 'react';\n\nfunction useOnlineStatus() {\n\n// ...","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDebugValue.md"}},"627":{"pageContent":"```js [[1, 5, \"isOnline ? 'Online' : 'Offline'\"]]\n\nimport { useDebugValue } from 'react';\n\nfunction useOnlineStatus() {\n\n// ...\n\nuseDebugValue(isOnline ? 'Online' : 'Offline');\n\n// ...\n\n}\n\n```\n\nThis gives components calling `useOnlineStatus` a label like `OnlineStatus: \"Online\"` when you inspect them:\n\n![A screenshot of React DevTools showing the debug value](/images/docs/react-devtools-usedebugvalue.png)\n\nWithout the `useDebugValue` call, only the underlying data (in this example, `true`) would be displayed.\n\n<Sandpack>\n\n```js\n\nimport { useOnlineStatus } from './useOnlineStatus.js';\n\nfunction StatusBar() {\n\nconst isOnline = useOnlineStatus();\n\nreturn <h1>{isOnline ? 'âœ… Online' : 'âŒ Disconnected'}</h1>;\n\n}\n\nexport default function App() {\n\nreturn <StatusBar />;\n\n}\n\n```\n\n```js useOnlineStatus.js active\n\nimport { useSyncExternalStore, useDebugValue } from 'react';\n\nexport function useOnlineStatus() {\n\nconst isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true);\n\nuseDebugValue(isOnline ? 'Online' : 'Offline');","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDebugValue.md"}},"628":{"pageContent":"export function useOnlineStatus() {\n\nconst isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true);\n\nuseDebugValue(isOnline ? 'Online' : 'Offline');\n\nreturn isOnline;\n\n}\n\nfunction subscribe(callback) {\n\nwindow.addEventListener('online', callback);\n\nwindow.addEventListener('offline', callback);\n\nreturn () => {\n\nwindow.removeEventListener('online', callback);\n\nwindow.removeEventListener('offline', callback);\n\n};\n\n}\n\n```\n\n</Sandpack>\n\n<Note>\n\nWe don't recommend adding debug values to every custom Hook. It's most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that's difficult to inspect.\n\n</Note>\n\n--\n\n### Deferring formatting of a debug value {/*deferring-formatting-of-a-debug-value*/}\n\nYou can also pass a formatting function as the second argument to `useDebugValue`:\n\n```js [[1, 1, \"date\", 18], [2, 1, \"date.toDateString()\"]]\n\nuseDebugValue(date, date => date.toDateString());\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDebugValue.md"}},"629":{"pageContent":"You can also pass a formatting function as the second argument to `useDebugValue`:\n\n```js [[1, 1, \"date\", 18], [2, 1, \"date.toDateString()\"]]\n\nuseDebugValue(date, date => date.toDateString());\n\n```\n\nYour formatting function will receive the <CodeStep step={1}>debug value</CodeStep> as a parameter and should return a <CodeStep step={2}>formatted display value</CodeStep>. When your component is inspected, React DevTools will call the formatting function and display its result.\n\nThis lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if `date` is a Date value, this avoids calling `toDateString()` on it for every render of your component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useDebugValue.md"}},"630":{"pageContent":"--\n\ntitle: memo\n\n--\n\n<Intro>\n\n`memo` lets you skip re-rendering a component when its props are unchanged.\n\n```\n\nconst MemoizedComponent = memo(SomeComponent, arePropsEqual?)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `memo(Component, arePropsEqual?)` {/*memo*/}\n\nWrap a component in `memo` to get a *memoized* version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is only a performance optimization, not a guarantee.\n\n```js\n\nimport { memo } from 'react';\n\nconst SomeComponent = memo(function SomeComponent(props) {\n\n// ...\n\n});\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"631":{"pageContent":"```js\n\nimport { memo } from 'react';\n\nconst SomeComponent = memo(function SomeComponent(props) {\n\n// ...\n\n});\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`Component`: The component that you want to memoize. The `memo` does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and [`forwardRef`](/reference/react/forwardRef) components, is accepted.\n\n**optional** `arePropsEqual`: A function that accepts two arguments: the component's previous props, and its new props. It should return `true` if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return `false`.\n\n#### Returns {/*returns*/}\n\n`memo` returns a new React component. It behaves the same as the component provided to `memo` except that React will not always re-render it when its parent is being re-rendered unless its props have changed.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"632":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Skipping re-rendering when props are unchanged {/*skipping-re-rendering-when-props-are-unchanged*/}\n\nReact normally re-renders a component whenever its parent re-renders. With `memo`, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be *memoized*.\n\nTo memoize a component, wrap it in a call to `memo` and use the value that it returns in place of your original component:\n\n```js\n\nconst Greeting = memo(function Greeting({ name }) {\n\nreturn <h1>Hello, {name}!</h1>;\n\n});\n\nexport default Greeting;\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"633":{"pageContent":"```js\n\nconst Greeting = memo(function Greeting({ name }) {\n\nreturn <h1>Hello, {name}!</h1>;\n\n});\n\nexport default Greeting;\n\n```\n\nA React component should always have [pure rendering logic.](/learn/keeping-components-pure) This means that it must return the same output if its props, state, and context haven't changed. By using `memo`, you are telling React that your component complies with this requirement, so React doesn't need to re-render as long as its props haven't changed. When you use `memo`, your component will still re-render if its own state changes or if a context that it's using changes.\n\nIn this example, notice that the `Greeting` component re-renders whenever `name` is changed (because that's one of its props), but not when `address` is changed (because it's not passed to `Greeting` as a prop):\n\n<Sandpack>\n\n```js\n\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n\nconst [name, setName] = useState('');\n\nconst [address, setAddress] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nName{': '}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"634":{"pageContent":"<Sandpack>\n\n```js\n\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n\nconst [name, setName] = useState('');\n\nconst [address, setAddress] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nName{': '}\n\n<input value={name} onChange={e => setName(e.target.value)} />\n\n</label>\n\n<label>\n\nAddress{': '}\n\n<input value={address} onChange={e => setAddress(e.target.value)} />\n\n</label>\n\n<Greeting name={name} />\n\n</>\n\n);\n\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n\nconsole.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n\nreturn <h3>Hello{name && ', '}{name}!</h3>;\n\n});\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-bottom: 16px;\n\n}\n\n```\n\n</Sandpack>\n\n<Note>\n\n*You should only rely on `memo` as a performance optimization.** If your code doesn't work without it, find the underlying problem and fix it first. Then you may add `memo` to improve performance.\n\n</Note>\n\n<DeepDive>\n\n#### Should you add memo everywhere? {/*should-you-add-memo-everywhere*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"635":{"pageContent":"</Note>\n\n<DeepDive>\n\n#### Should you add memo everywhere? {/*should-you-add-memo-everywhere*/}\n\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"636":{"pageContent":"Optimizing with `memo`  is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, `memo` is unnecessary. Keep in mind that `memo` is completely useless if the props passed to your component are *always different,* such as if you pass an object or a plain function defined during rendering. This is why you will often need [`useMemo`](/reference/react/useMemo#skipping-re-rendering-of-components) and [`useCallback`](/reference/react/useCallback#skipping-re-rendering-of-components) together with `memo`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"637":{"pageContent":"There is no benefit to wrapping a component in `memo` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that's \"always new\" is enough to break memoization for an entire component.\n\n*In practice, you can make a lot of memoization unnecessary by following a few principles:**\n\n1. When a component visually wraps other components, let it [accept JSX as children.](/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don't need to re-render.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"638":{"pageContent":"1. Prefer local state and don't [lift state up](/learn/sharing-state-between-components) any further than necessary. For example, don't keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n\n1. Keep your [rendering logic pure.](/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it's a bug in your component! Fix the bug instead of adding memoization.\n\n1. Avoid [unnecessary Effects that update state.](/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n\n1. Try to [remove unnecessary dependencies from your Effects.](/learn/removing-effect-dependencies) For example, instead of memoization, it's often simpler to move some object or a function inside an Effect or outside the component.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"639":{"pageContent":"If a specific interaction still feels laggy, [use the React Developer Tools profiler](/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it's good to follow them in any case. In the long term, we're researching [doing granular memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.\n\n</DeepDive>\n\n--\n\n### Updating a memoized component using state {/*updating-a-memoized-component-using-state*/}\n\nEven when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.\n\n<Sandpack>\n\n```js\n\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n\nconst [name, setName] = useState('');\n\nconst [address, setAddress] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nName{': '}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"640":{"pageContent":"<Sandpack>\n\n```js\n\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n\nconst [name, setName] = useState('');\n\nconst [address, setAddress] = useState('');\n\nreturn (\n\n<>\n\n<label>\n\nName{': '}\n\n<input value={name} onChange={e => setName(e.target.value)} />\n\n</label>\n\n<label>\n\nAddress{': '}\n\n<input value={address} onChange={e => setAddress(e.target.value)} />\n\n</label>\n\n<Greeting name={name} />\n\n</>\n\n);\n\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n\nconsole.log('Greeting was rendered at', new Date().toLocaleTimeString());\n\nconst [greeting, setGreeting] = useState('Hello');\n\nreturn (\n\n<>\n\n<h3>{greeting}{name && ', '}{name}!</h3>\n\n<GreetingSelector value={greeting} onChange={setGreeting} />\n\n</>\n\n);\n\n});\n\nfunction GreetingSelector({ value, onChange }) {\n\nreturn (\n\n<>\n\n<label>\n\n<input\n\ntype=\"radio\"\n\nchecked={value === 'Hello'}\n\nonChange={e => onChange('Hello')}\n\n/>\n\nRegular greeting\n\n</label>\n\n<label>\n\n<input\n\ntype=\"radio\"\n\nchecked={value === 'Hello and welcome'}\n\nonChange={e => onChange('Hello and welcome')}\n\n/>\n\nEnthusiastic greeting\n\n</label>\n\n</>\n\n);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"641":{"pageContent":"/>\n\nRegular greeting\n\n</label>\n\n<label>\n\n<input\n\ntype=\"radio\"\n\nchecked={value === 'Hello and welcome'}\n\nonChange={e => onChange('Hello and welcome')}\n\n/>\n\nEnthusiastic greeting\n\n</label>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-bottom: 16px;\n\n}\n\n```\n\n</Sandpack>\n\nIf you set a state variable to its current value, React will skip re-rendering your component even without `memo`. You may still see your component function being called an extra time, but the result will be discarded.\n\n--\n\n### Updating a memoized component using a context {/*updating-a-memoized-component-using-a-context*/}\n\nEven when a component is memoized, it will still re-render when a context that it's using changes. Memoization only has to do with props that are passed to the component from its parent.\n\n<Sandpack>\n\n```js\n\nimport { createContext, memo, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n\nconst [theme, setTheme] = useState('dark');\n\nfunction handleClick() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"642":{"pageContent":"const ThemeContext = createContext(null);\n\nexport default function MyApp() {\n\nconst [theme, setTheme] = useState('dark');\n\nfunction handleClick() {\n\nsetTheme(theme === 'dark' ? 'light' : 'dark');\n\n}\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<button onClick={handleClick}>\n\nSwitch theme\n\n</button>\n\n<Greeting name=\"Taylor\" />\n\n</ThemeContext.Provider>\n\n);\n\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n\nconsole.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n\nconst theme = useContext(ThemeContext);\n\nreturn (\n\n<h3 className={theme}>Hello, {name}!</h3>\n\n);\n\n});\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\nmargin-bottom: 16px;\n\n}\n\n.light {\n\ncolor: black;\n\nbackground-color: white;\n\n}\n\n.dark {\n\ncolor: white;\n\nbackground-color: black;\n\n}\n\n```\n\n</Sandpack>\n\nTo make your component re-render only when a _part_ of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.\n\n--\n\n### Minimizing props changes {/*minimizing-props-changes*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"643":{"pageContent":"--\n\n### Minimizing props changes {/*minimizing-props-changes*/}\n\nWhen you use `memo`, your component re-renders whenever any prop is not *shallowly equal* to what it was previously. This means that React compares every prop in your component with the previous value of that prop using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. Note that `Object.is(3, 3)` is `true`, but `Object.is({}, {})` is `false`.\n\nTo get the most out of `memo`, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using [`useMemo`:](/reference/react/useMemo)\n\n```js {5-8}\n\nfunction Page() {\n\nconst [name, setName] = useState('Taylor');\n\nconst [age, setAge] = useState(42);\n\nconst person = useMemo(\n\n() => ({ name, age }),\n\n[name, age]\n\n);\n\nreturn <Profile person={person} />;\n\n}\n\nconst Profile = memo(function Profile({ person }) {\n\n// ...\n\n});\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"644":{"pageContent":"const [age, setAge] = useState(42);\n\nconst person = useMemo(\n\n() => ({ name, age }),\n\n[name, age]\n\n);\n\nreturn <Profile person={person} />;\n\n}\n\nconst Profile = memo(function Profile({ person }) {\n\n// ...\n\n});\n\n```\n\nA better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:\n\n```js {4,7}\n\nfunction Page() {\n\nconst [name, setName] = useState('Taylor');\n\nconst [age, setAge] = useState(42);\n\nreturn <Profile name={name} age={age} />;\n\n}\n\nconst Profile = memo(function Profile({ name, age }) {\n\n// ...\n\n});\n\n```\n\nEven individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:\n\n```js {3}\n\nfunction GroupsLanding({ person }) {\n\nconst hasGroups = person.groups !== null;\n\nreturn <CallToAction hasGroups={hasGroups} />;\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"645":{"pageContent":"```js {3}\n\nfunction GroupsLanding({ person }) {\n\nconst hasGroups = person.groups !== null;\n\nreturn <CallToAction hasGroups={hasGroups} />;\n\n}\n\nconst CallToAction = memo(function CallToAction({ hasGroups }) {\n\n// ...\n\n});\n\n```\n\nWhen you need to pass a function to memoized component, either declare it outside your component so that it never changes, or [`useCallback`](/reference/react/useCallback#skipping-re-rendering-of-components) to cache its definition between re-renders.\n\n--\n\n### Specifying a custom comparison function {/*specifying-a-custom-comparison-function*/}\n\nIn rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to `memo`. It should return `true` only if the new props would result in the same output as the old props; otherwise it should return `false`.\n\n```js {3}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"646":{"pageContent":"```js {3}\n\nconst Chart = memo(function Chart({ dataPoints }) {\n\n// ...\n\n}, arePropsEqual);\n\nfunction arePropsEqual(oldProps, newProps) {\n\nreturn (\n\noldProps.dataPoints.length === newProps.dataPoints.length &&\n\noldProps.dataPoints.every((oldPoint, index) => {\n\nconst newPoint = newProps.dataPoints[index];\n\nreturn oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;\n\n})\n\n);\n\n}\n\n```\n\nIf you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.\n\nWhen you do performance measurements, make sure that React is running in the production mode.\n\n<Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"647":{"pageContent":"When you do performance measurements, make sure that React is running in the production mode.\n\n<Pitfall>\n\nIf you provide a custom `arePropsEqual` implementation, **you must compare every prop, including functions.** Functions often [close over](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) the props and state of parent components. If you return `true` when `oldProps.onClick !== newProps.onClick`, your component will keep \"seeing\" the props and state from a previous render inside its `onClick` handler, leading to very confusing bugs.\n\nAvoid doing deep equality checks inside `arePropsEqual` unless you are 100% sure that the data structure you're working with has a known limited depth. **Deep equality checks can become incredibly slow** and can freeze your app for many seconds if someone changes the data structure later.\n\n</Pitfall>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"648":{"pageContent":"</Pitfall>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### My component re-renders when a prop is an object, array, or function {/*my-component-rerenders-when-a-prop-is-an-object-or-array*/}\n\nReact compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition.  Avoid this by [simplifying props or memoizing props in the parent component](#minimizing-props-changes).","metadata":{"source":"reactjs.org/beta/src/content/reference/react/memo.md"}},"649":{"pageContent":"--\n\ntitle: createFactory\n\n--\n\n<Deprecated>\n\nThis API will be removed in a future major version of React. [See the alternatives.](#alternatives)\n\n</Deprecated>\n\n<Intro>\n\n`createFactory` lets you create a function that produces React elements of a given type.\n\n```js\n\nconst factory = createFactory(type)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `createFactory(type)` {/*createfactory*/}\n\nCall `createFactory(type)` to create a factory function which produces React elements of a given `type`.\n\n```js\n\nimport { createFactory } from 'react';\n\nconst button = createFactory('button');\n\n```\n\nThen you can use it to create React elements without JSX:\n\n```js\n\nexport default function App() {\n\nreturn button({\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createFactory.md"}},"650":{"pageContent":"```js\n\nexport default function App() {\n\nreturn button({\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`type`: The `type` argument must be a valid React component type. For example, it could be a tag name string (such as `'div'` or `'span'`), or a React component (a function, a class, or a special component like [`Fragment`](/reference/react/Fragment)).\n\n#### Returns {/*returns*/}\n\nReturns a factory function. That factory function receives a `props` object as the first argument, followed by a list of `...children` arguments, and returns a React element with the given `type`, `props` and `children`.\n\n--\n\n## Usage {/*usage*/}\n\n### Creating React elements with a factory {/*creating-react-elements-with-a-factory*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createFactory.md"}},"651":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Creating React elements with a factory {/*creating-react-elements-with-a-factory*/}\n\nAlthough most React projects use [JSX](/learn/writing-markup-with-jsx) to describe the user interface, JSX is not required. In the past, `createFactory` used to be one of the ways you could describe the user interface without JSX.\n\nCall `createFactory` to create a *factory function* for a specific element type like `'button'`:\n\n```js\n\nimport { createFactory } from 'react';\n\nconst button = createFactory('button');\n\n```\n\nCalling that factory function will produce React elements with the props and children you have provided:\n\n<Sandpack>\n\n```js App.js\n\nimport { createFactory } from 'react';\n\nconst button = createFactory('button');\n\nexport default function App() {\n\nreturn button({\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createFactory.md"}},"652":{"pageContent":"```js App.js\n\nimport { createFactory } from 'react';\n\nconst button = createFactory('button');\n\nexport default function App() {\n\nreturn button({\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\n</Sandpack>\n\nThis is how `createFactory` was used as an alternative to JSX. However, `createFactory` is deprecated, and you should not call `createFactory` in any new code. See how to migrate away from `createFactory` below.\n\n--\n\n## Alternatives {/*alternatives*/}\n\n### Copying `createFactory` into your project {/*copying-createfactory-into-your-project*/}\n\nIf your project has many `createFactory` calls, copy this `createFactory.js` implementation into your project:\n\n<Sandpack>\n\n```js App.js\n\nimport { createFactory } from './createFactory.js';\n\nconst button = createFactory('button');\n\nexport default function App() {\n\nreturn button({\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\n```js createFactory.js\n\nimport { createElement } from 'react';\n\nexport function createFactory(type) {\n\nreturn createElement.bind(null, type);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createFactory.md"}},"653":{"pageContent":"onClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\n```js createFactory.js\n\nimport { createElement } from 'react';\n\nexport function createFactory(type) {\n\nreturn createElement.bind(null, type);\n\n}\n\n```\n\n</Sandpack>\n\nThis lets you keep all of your code unchanged except the imports.\n\n--\n\n### Replacing `createFactory` with `createElement` {/*replacing-createfactory-with-createelement*/}\n\nIf you have a few `createFactory` calls that you don't mind porting manually, and you don't want to use JSX, you can replace every call a factory function with a [`createElement`](/reference/react/createElement) call. For example, you can replace this code:\n\n```js {1,3,6}\n\nimport { createFactory } from 'react';\n\nconst button = createFactory('button');\n\nexport default function App() {\n\nreturn button({\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\nwith this code:\n\n```js {1,4}\n\nimport { createElement } from 'react';\n\nexport default function App() {\n\nreturn createElement('button', {\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createFactory.md"}},"654":{"pageContent":"}\n\n}, 'Click me');\n\n}\n\n```\n\nwith this code:\n\n```js {1,4}\n\nimport { createElement } from 'react';\n\nexport default function App() {\n\nreturn createElement('button', {\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\nHere is a complete example of using React without JSX:\n\n<Sandpack>\n\n```js App.js\n\nimport { createElement } from 'react';\n\nexport default function App() {\n\nreturn createElement('button', {\n\nonClick: () => {\n\nalert('Clicked!')\n\n}\n\n}, 'Click me');\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Replacing `createFactory` with JSX {/*replacing-createfactory-with-jsx*/}\n\nFinally, you can use JSX instead of `createFactory`. This is the most common way to use React:\n\n<Sandpack>\n\n```js App.js\n\nexport default function App() {\n\nreturn (\n\n<button onClick={() => {\n\nalert('Clicked!');\n\n}}>\n\nClick me\n\n</button>\n\n);\n\n};\n\n```\n\n</Sandpack>\n\n<Pitfall>\n\nSometimes, your existing code might pass some variable as a `type` instead of a constant like `'button'`:\n\n```js {3}\n\nfunction Heading({ isSubheading, ...props }) {\n\nconst type = isSubheading ? 'h2' : 'h1';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createFactory.md"}},"655":{"pageContent":"Sometimes, your existing code might pass some variable as a `type` instead of a constant like `'button'`:\n\n```js {3}\n\nfunction Heading({ isSubheading, ...props }) {\n\nconst type = isSubheading ? 'h2' : 'h1';\n\nconst factory = createFactory(type);\n\nreturn factory(props);\n\n}\n\n```\n\nTo do the same in JSX, you need to rename your variable to start with an uppercase letter like `Type`:\n\n```js {2,3}\n\nfunction Heading({ isSubheading, ...props }) {\n\nconst Type = isSubheading ? 'h2' : 'h1';\n\nreturn <Type {...props} />;\n\n}\n\n```\n\nOtherwise React will interpret `<type>` as a built-in HTML tag because it is lowercase.\n\n</Pitfall>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createFactory.md"}},"656":{"pageContent":"--\n\ntitle: createElement\n\n--\n\n<Intro>\n\n`createElement` lets you create a React element. It serves as an alternative to writing [JSX.](/learn/writing-markup-with-jsx)\n\n```js\n\nconst element = createElement(type, props, ...children)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `createElement(type, props, ...children)` {/*createelement*/}\n\nCall `createElement` to create a React element with the given `type`, `props`, and `children`.\n\n```js\n\nimport { createElement } from 'react';\n\nfunction Greeting({ name }) {\n\nreturn createElement(\n\n'h1',\n\n{ className: 'greeting' },\n\n'Hello'\n\n);\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`type`: The `type` argument must be a valid React component type. For example, it could be a tag name string (such as `'div'` or `'span'`), or a React component (a function, a class, or a special component like [`Fragment`](/reference/react/Fragment)).","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"657":{"pageContent":"`props`: The `props` argument must either be an object or `null`. If you pass `null`, it will be treated the same as an empty object. React will create an element with props matching the `props` you have passed. Note that `ref` and `key` from your `props` object are special and will *not* be available as `element.props.ref` and `element.props.key` on the returned `element`. They will be available as `element.ref` and `element.key`.\n\n**optional** `...children`: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, [portals](/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes.\n\n#### Returns {/*returns*/}\n\n`createElement` returns a React element object with a few properties:\n\n`type`: The `type` you have passed.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"658":{"pageContent":"#### Returns {/*returns*/}\n\n`createElement` returns a React element object with a few properties:\n\n`type`: The `type` you have passed.\n\n`props`: The `props` you have passed except for `ref` and `key`. If the `type` is a component with legacy `type.defaultProps`, then any missing or undefined `props` will get the values from `type.defaultProps`.\n\n`ref`: The `ref` you have passed. If missing, `null`.\n\n`key`: The `key` you have passed, coerced to a string. If missing, `null`.\n\nUsually, you'll return the element from your component or make it a child of another element. Although you may read the element's properties, it's best to treat every element as opaque after it's created, and only render it.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"659":{"pageContent":"#### Caveats {/*caveats*/}\n\nYou must **treat React elements and their props as [immutable](https://en.wikipedia.org/wiki/Immutable_object)** and never change their contents after creation. In development, React will [freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) the returned element and its `props` property shallowly to enforce this.\n\nWhen you use JSX, **you must start a tag with a capital letter to render your own custom component.** In other words, `<Something />` is equivalent to `createElement(Something)`, but `<something />` (lowercase) is equivalent to `createElement('something')` (note it's a string, so it will be treated as a built-in HTML tag).","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"660":{"pageContent":"You should only **pass children as multiple arguments to `createElement` if they are all statically known,** like `createElement('h1', {}, child1, child2, child3)`. If your children are dynamic, pass the entire array as the third argument: `createElement('ul', {}, listItems)`. This ensures that React will [warn you about missing `key`s](/learn/rendering-lists#keeping-list-items-in-order-with-key) for any dynamic lists. For static lists this is not necessary because they never reorder.\n\n--\n\n## Usage {/*usage*/}\n\n### Creating an element without JSX {/*creating-an-element-without-jsx*/}\n\nIf you don't like [JSX](/learn/writing-markup-with-jsx) or can't use it in your project, you can use `createElement` as an alternative.\n\nTo create an element without JSX, call `createElement` with some <CodeStep step={1}>type</CodeStep>, <CodeStep step={2}>props</CodeStep>, and <CodeStep step={3}>children</CodeStep>:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"661":{"pageContent":"To create an element without JSX, call `createElement` with some <CodeStep step={1}>type</CodeStep>, <CodeStep step={2}>props</CodeStep>, and <CodeStep step={3}>children</CodeStep>:\n\n```js [[1, 5, \"'h1'\"], [2, 6, \"{ className: 'greeting' }\"], [3, 7, \"'Hello ',\"], [3, 8, \"createElement('i', null, name),\"], [3, 9, \"'. Welcome!'\"]]\n\nimport { createElement } from 'react';\n\nfunction Greeting({ name }) {\n\nreturn createElement(\n\n'h1',\n\n{ className: 'greeting' },\n\n'Hello ',\n\ncreateElement('i', null, name),\n\n'. Welcome!'\n\n);\n\n}\n\n```\n\nThe <CodeStep step={3}>children</CodeStep> are optional, and you can pass as many as you need (the example above has three children). This code will display a `<h1>` header with a greeting. For comparison, here is the same example rewritten with JSX:\n\n```js [[1, 3, \"h1\"], [2, 3, \"className=\\\\\"greeting\\\\\"\"], [3, 4, \"Hello <i>{name}</i>. Welcome!\"], [1, 5, \"h1\"]]\n\nfunction Greeting({ name }) {\n\nreturn (\n\n<h1 className=\"greeting\">\n\nHello <i>{name}</i>. Welcome!\n\n</h1>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"662":{"pageContent":"function Greeting({ name }) {\n\nreturn (\n\n<h1 className=\"greeting\">\n\nHello <i>{name}</i>. Welcome!\n\n</h1>\n\n);\n\n}\n\n```\n\nTo render your own React component, pass a function like `Greeting` as the <CodeStep step={1}>type</CodeStep> instead of a string like `'h1'`:\n\n```js [[1, 2, \"Greeting\"], [2, 2, \"{ name: 'Taylor' }\"]]\n\nexport default function App() {\n\nreturn createElement(Greeting, { name: 'Taylor' });\n\n}\n\n```\n\nWith JSX, it would look like this:\n\n```js [[1, 2, \"Greeting\"], [2, 2, \"name=\\\\\"Taylor\\\\\"\"]]\n\nexport default function App() {\n\nreturn <Greeting name=\"Taylor\" />;\n\n}\n\n```\n\nHere is a complete example written with `createElement`:\n\n<Sandpack>\n\n```js\n\nimport { createElement } from 'react';\n\nfunction Greeting({ name }) {\n\nreturn createElement(\n\n'h1',\n\n{ className: 'greeting' },\n\n'Hello ',\n\ncreateElement('i', null, name),\n\n'. Welcome!'\n\n);\n\n}\n\nexport default function App() {\n\nreturn createElement(\n\nGreeting,\n\n{ name: 'Taylor' }\n\n);\n\n}\n\n```\n\n```css\n\n.greeting {\n\ncolor: darkgreen;\n\nfont-family: Georgia;\n\n}\n\n```\n\n</Sandpack>\n\nAnd here is the same example written using JSX:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"663":{"pageContent":"return createElement(\n\nGreeting,\n\n{ name: 'Taylor' }\n\n);\n\n}\n\n```\n\n```css\n\n.greeting {\n\ncolor: darkgreen;\n\nfont-family: Georgia;\n\n}\n\n```\n\n</Sandpack>\n\nAnd here is the same example written using JSX:\n\n<Sandpack>\n\n```js\n\nfunction Greeting({ name }) {\n\nreturn (\n\n<h1 className=\"greeting\">\n\nHello <i>{name}</i>. Welcome!\n\n</h1>\n\n);\n\n}\n\nexport default function App() {\n\nreturn <Greeting name=\"Taylor\" />;\n\n}\n\n```\n\n```css\n\n.greeting {\n\ncolor: darkgreen;\n\nfont-family: Georgia;\n\n}\n\n```\n\n</Sandpack>\n\nBoth coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared to `createElement` is that it's easy to see which closing tag corresponds to which opening tag.\n\n<DeepDive>\n\n#### What is a React element, exactly? {/*what-is-a-react-element-exactly*/}\n\nAn element is a lightweight description of a piece of the user interface. For example, both `<Greeting name=\"Taylor\" />` and `createElement(Greeting, { name: 'Taylor' })` produce an object like this:\n\n```js\n\n// Slightly simplified\n\n{\n\ntype: Greeting,\n\nprops: {\n\nname: 'Taylor'\n\n},","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"664":{"pageContent":"```js\n\n// Slightly simplified\n\n{\n\ntype: Greeting,\n\nprops: {\n\nname: 'Taylor'\n\n},\n\nkey: null,\n\nref: null,\n\n}\n\n```\n\n*Note that creating this object does not render the `Greeting` component or create any DOM elements.**\n\nA React element is more like a description--an instruction for React to later render the `Greeting` component. By returning this object from your `App` component, you tell React what to do next.\n\nCreating elements is extremely cheap so you don't need to try to optimize or avoid it.\n\n</DeepDive>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/createElement.md"}},"665":{"pageContent":"--\n\ntitle: useLayoutEffect\n\n--\n\n<Pitfall>\n\n`useLayoutEffect` can hurt performance. Prefer [`useEffect`](/reference/react/useEffect) when possible.\n\n</Pitfall>\n\n<Intro>\n\n`useLayoutEffect` is a version of [`useEffect`](/reference/react/useEffect) that fires before the browser repaints the screen.\n\n```js\n\nuseLayoutEffect(setup, dependencies?)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useLayoutEffect(setup, dependencies?)` {/*useinsertioneffect*/}\n\nCall `useLayoutEffect` perform the layout measurements before the browser repaints the screen:\n\n```js\n\nimport { useState, useRef, useLayoutEffect } from 'react';\n\nfunction Tooltip() {\n\nconst ref = useRef(null);\n\nconst [tooltipHeight, setTooltipHeight] = useState(0);\n\nuseLayoutEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height);\n\n}, []);\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"666":{"pageContent":"useLayoutEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height);\n\n}, []);\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`setup`: The function with your Effect's logic. Your setup function may also optionally return a *cleanup* function. Before your component is first added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function one last time.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"667":{"pageContent":"**optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm. If you don't specify the dependencies at all, your Effect will re-run after every re-render of the component.\n\n#### Returns {/*returns*/}\n\n`useLayoutEffect` returns `undefined`.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"668":{"pageContent":"#### Returns {/*returns*/}\n\n`useLayoutEffect` returns `undefined`.\n\n#### Caveats {/*caveats*/}\n\n`useLayoutEffect` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can't call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n\nWhen Strict Mode is on, React will **run one extra development-only setup+cleanup cycle** before the first real setup. This is a stress-test that ensures that your cleanup logic \"mirrors\" your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, [you need to implement the cleanup function.](/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"669":{"pageContent":"If some of your dependencies are objects or functions defined inside the component, there is a risk that they will **cause the Effect to re-run more often than needed.** To fix this, remove unnecessary [object](/reference/react/useEffect#removing-unnecessary-object-dependencies) and [function](/reference/react/useEffect#removing-unnecessary-function-dependencies) dependencies. You can also [extract state updates](/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect) and [non-reactive logic](/reference/react/useEffect#reading-the-latest-props-and-state-from-an-effect) outside of your Effect.\n\nEffects **only run on the client.** They don't run during server rendering.\n\nThe code inside `useLayoutEffect` and all state updates scheduled from it **block the browser from repainting the screen.** When used excessively, this can make your app very slow. When possible, prefer [`useEffect`.](/reference/reac/useEffect)\n\n--\n\n## Usage {/*usage*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"670":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Measuring layout before the browser repaints the screen {/*measuring-layout-before-the-browser-repaints-the-screen*/}\n\nMost components don't need to know their position and size on the screen to decide what to render. They only return some JSX with CSS. Then the browser calculates their *layout* (position and size) and repaints the screen.\n\nSometimes, that's not enough. Imagine a tooltip that appears next to some element on hover. If there's enough space, the tooltip should appear above the element, but if it doesn't fit, it should appear below. This means that in order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).\n\nTo do this, you need to render in two passes:\n\n1. Render the tooltip anywhere (even with a wrong position).\n\n2. Measure its height and decide where to place the tooltip.\n\n3. Render the tooltip *again* in the correct place.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"671":{"pageContent":"1. Render the tooltip anywhere (even with a wrong position).\n\n2. Measure its height and decide where to place the tooltip.\n\n3. Render the tooltip *again* in the correct place.\n\n*All of this needs to happen before the browser repaints the screen.** You don't want the user to see the tooltip moving. Call `useLayoutEffect` to perform the layout measurements before the browser repaints the screen:\n\n```js {5-8}\n\nfunction Tooltip() {\n\nconst ref = useRef(null);\n\nconst [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet\n\nuseLayoutEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height); // Re-render now that you know the real height\n\n}, []);\n\n// ...use tooltipHeight in the rendering logic below...\n\n}\n\n```\n\nHere's how this works step by step:\n\n1. `Tooltip` renders with the initial `tooltipHeight = 0`  (so the tooltip may be wrongly positioned).\n\n2. React places it in the DOM and runs the code in `useLayoutEffect`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"672":{"pageContent":"1. `Tooltip` renders with the initial `tooltipHeight = 0`  (so the tooltip may be wrongly positioned).\n\n2. React places it in the DOM and runs the code in `useLayoutEffect`.\n\n3. Your `useLayoutEffect` [measures the height](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) of the tooltip content and triggers an immediate re-render.\n\n4. `Tooltip` renders again with the real `tooltipHeight` (so the tooltip is correctly positioned).\n\n5. React updates it in the DOM, and the browser finally displays the tooltip.\n\nHover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:\n\n<Sandpack>\n\n```js\n\nimport ButtonWithTooltip from './ButtonWithTooltip.js';\n\nexport default function App() {\n\nreturn (\n\n<div>\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>\n\nThis tooltip does not fit above the button.\n\n<br />\n\nThis is why it's displayed below instead!\n\n</div>\n\n}\n\n>\n\nHover over me (tooltip above)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"673":{"pageContent":"<div>\n\nThis tooltip does not fit above the button.\n\n<br />\n\nThis is why it's displayed below instead!\n\n</div>\n\n}\n\n>\n\nHover over me (tooltip above)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n</div>\n\n);\n\n}\n\n```\n\n```js ButtonWithTooltip.js\n\nimport { useState, useRef } from 'react';\n\nimport Tooltip from './Tooltip.js';\n\nexport default function ButtonWithTooltip({ tooltipContent, ...rest }) {\n\nconst [targetRect, setTargetRect] = useState(null);\n\nconst buttonRef = useRef(null);\n\nreturn (\n\n<>\n\n<button\n\n{...rest}\n\nref={buttonRef}\n\nonPointerEnter={() => {\n\nconst rect = buttonRef.current.getBoundingClientRect();\n\nsetTargetRect({\n\nleft: rect.left,\n\ntop: rect.top,\n\nright: rect.right,\n\nbottom: rect.bottom,\n\n});\n\n}}\n\nonPointerLeave={() => {\n\nsetTargetRect(null);\n\n}}\n\n/>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"674":{"pageContent":"const rect = buttonRef.current.getBoundingClientRect();\n\nsetTargetRect({\n\nleft: rect.left,\n\ntop: rect.top,\n\nright: rect.right,\n\nbottom: rect.bottom,\n\n});\n\n}}\n\nonPointerLeave={() => {\n\nsetTargetRect(null);\n\n}}\n\n/>\n\n{targetRect !== null && (\n\n<Tooltip targetRect={targetRect}>\n\n{tooltipContent}\n\n</Tooltip>\n\n)\n\n}\n\n</>\n\n);\n\n}\n\n```\n\n```js Tooltip.js active\n\nimport { useRef, useLayoutEffect, useState } from 'react';\n\nimport { createPortal } from 'react-dom';\n\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n\nconst ref = useRef(null);\n\nconst [tooltipHeight, setTooltipHeight] = useState(0);\n\nuseLayoutEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height);\n\nconsole.log('Measured tooltip height: ' + height);\n\n}, []);\n\nlet tooltipX = 0;\n\nlet tooltipY = 0;\n\nif (targetRect !== null) {\n\ntooltipX = targetRect.left;\n\ntooltipY = targetRect.top - tooltipHeight;\n\nif (tooltipY < 0) {\n\n// It doesn't fit above, so place below.\n\ntooltipY = targetRect.bottom;\n\n}\n\n}\n\nreturn createPortal(","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"675":{"pageContent":"tooltipX = targetRect.left;\n\ntooltipY = targetRect.top - tooltipHeight;\n\nif (tooltipY < 0) {\n\n// It doesn't fit above, so place below.\n\ntooltipY = targetRect.bottom;\n\n}\n\n}\n\nreturn createPortal(\n\n<TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n\n{children}\n\n</TooltipContainer>,\n\ndocument.body\n\n);\n\n}\n\n```\n\n```js TooltipContainer.js\n\nexport default function TooltipContainer({ children, x, y, contentRef }) {\n\nreturn (\n\n<div\n\nstyle={{\n\nposition: 'absolute',\n\npointerEvents: 'none',\n\nleft: 0,\n\ntop: 0,\n\ntransform: `translate3d(${x}px, ${y}px, 0)`\n\n}}\n\n>\n\n<div ref={contentRef} className=\"tooltip\">\n\n{children}\n\n</div>\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.tooltip {\n\ncolor: white;\n\nbackground: #222;\n\nborder-radius: 4px;\n\npadding: 4px;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"676":{"pageContent":"}}\n\n>\n\n<div ref={contentRef} className=\"tooltip\">\n\n{children}\n\n</div>\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.tooltip {\n\ncolor: white;\n\nbackground: #222;\n\nborder-radius: 4px;\n\npadding: 4px;\n\n}\n\n```\n\n</Sandpack>\n\nNotice that even though the `Tooltip` component has to render in two passes (first, with `tooltipHeight` initialized to `0` and then with the real measured height), you only see the final result. This is why you need `useLayoutEffect` instead of [`useEffect`](/reference/react/useEffect) for this example. Let's look at the difference in detail below.\n\n<Recipes titleText=\"useLayoutEffect vs useEffect\" titleId=\"examples\">\n\n#### `useLayoutEffect` blocks the browser from repainting {/*uselayouteffect-blocks-the-browser-from-repainting*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"677":{"pageContent":"<Recipes titleText=\"useLayoutEffect vs useEffect\" titleId=\"examples\">\n\n#### `useLayoutEffect` blocks the browser from repainting {/*uselayouteffect-blocks-the-browser-from-repainting*/}\n\nReact guarantees that the code inside `useLayoutEffect` and any state updates scheduled inside it will be processed **before the browser repaints the screen.** This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words, `useLayoutEffect` blocks the browser from painting.\n\n<Sandpack>\n\n```js\n\nimport ButtonWithTooltip from './ButtonWithTooltip.js';\n\nexport default function App() {\n\nreturn (\n\n<div>\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>\n\nThis tooltip does not fit above the button.\n\n<br />\n\nThis is why it's displayed below instead!\n\n</div>\n\n}\n\n>\n\nHover over me (tooltip above)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"678":{"pageContent":"</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n</div>\n\n);\n\n}\n\n```\n\n```js ButtonWithTooltip.js\n\nimport { useState, useRef } from 'react';\n\nimport Tooltip from './Tooltip.js';\n\nexport default function ButtonWithTooltip({ tooltipContent, ...rest }) {\n\nconst [targetRect, setTargetRect] = useState(null);\n\nconst buttonRef = useRef(null);\n\nreturn (\n\n<>\n\n<button\n\n{...rest}\n\nref={buttonRef}\n\nonPointerEnter={() => {\n\nconst rect = buttonRef.current.getBoundingClientRect();\n\nsetTargetRect({\n\nleft: rect.left,\n\ntop: rect.top,\n\nright: rect.right,\n\nbottom: rect.bottom,\n\n});\n\n}}\n\nonPointerLeave={() => {\n\nsetTargetRect(null);\n\n}}\n\n/>\n\n{targetRect !== null && (\n\n<Tooltip targetRect={targetRect}>\n\n{tooltipContent}\n\n</Tooltip>\n\n)\n\n}\n\n</>\n\n);\n\n}\n\n```\n\n```js Tooltip.js active","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"679":{"pageContent":"bottom: rect.bottom,\n\n});\n\n}}\n\nonPointerLeave={() => {\n\nsetTargetRect(null);\n\n}}\n\n/>\n\n{targetRect !== null && (\n\n<Tooltip targetRect={targetRect}>\n\n{tooltipContent}\n\n</Tooltip>\n\n)\n\n}\n\n</>\n\n);\n\n}\n\n```\n\n```js Tooltip.js active\n\nimport { useRef, useLayoutEffect, useState } from 'react';\n\nimport { createPortal } from 'react-dom';\n\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n\nconst ref = useRef(null);\n\nconst [tooltipHeight, setTooltipHeight] = useState(0);\n\nuseLayoutEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height);\n\n}, []);\n\nlet tooltipX = 0;\n\nlet tooltipY = 0;\n\nif (targetRect !== null) {\n\ntooltipX = targetRect.left;\n\ntooltipY = targetRect.top - tooltipHeight;\n\nif (tooltipY < 0) {\n\n// It doesn't fit above, so place below.\n\ntooltipY = targetRect.bottom;\n\n}\n\n}\n\nreturn createPortal(\n\n<TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n\n{children}\n\n</TooltipContainer>,\n\ndocument.body\n\n);\n\n}\n\n```\n\n```js TooltipContainer.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"680":{"pageContent":"tooltipY = targetRect.bottom;\n\n}\n\n}\n\nreturn createPortal(\n\n<TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n\n{children}\n\n</TooltipContainer>,\n\ndocument.body\n\n);\n\n}\n\n```\n\n```js TooltipContainer.js\n\nexport default function TooltipContainer({ children, x, y, contentRef }) {\n\nreturn (\n\n<div\n\nstyle={{\n\nposition: 'absolute',\n\npointerEvents: 'none',\n\nleft: 0,\n\ntop: 0,\n\ntransform: `translate3d(${x}px, ${y}px, 0)`\n\n}}\n\n>\n\n<div ref={contentRef} className=\"tooltip\">\n\n{children}\n\n</div>\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.tooltip {\n\ncolor: white;\n\nbackground: #222;\n\nborder-radius: 4px;\n\npadding: 4px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### `useEffect` does not block the browser {/*useeffect-does-not-block-the-browser*/}\n\nHere is the same example, but with [`useEffect`](/reference/react/useEffect) instead of `useLayoutEffect`. If you're on a slower device, you might notice that sometimes the tooltip \"flickers\" and you briefly see its initial position before the corrected position.\n\n<Sandpack>\n\n```js\n\nimport ButtonWithTooltip from './ButtonWithTooltip.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"681":{"pageContent":"<Sandpack>\n\n```js\n\nimport ButtonWithTooltip from './ButtonWithTooltip.js';\n\nexport default function App() {\n\nreturn (\n\n<div>\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>\n\nThis tooltip does not fit above the button.\n\n<br />\n\nThis is why it's displayed below instead!\n\n</div>\n\n}\n\n>\n\nHover over me (tooltip above)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n</div>\n\n);\n\n}\n\n```\n\n```js ButtonWithTooltip.js\n\nimport { useState, useRef } from 'react';\n\nimport Tooltip from './Tooltip.js';\n\nexport default function ButtonWithTooltip({ tooltipContent, ...rest }) {\n\nconst [targetRect, setTargetRect] = useState(null);\n\nconst buttonRef = useRef(null);\n\nreturn (\n\n<>\n\n<button\n\n{...rest}\n\nref={buttonRef}\n\nonPointerEnter={() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"682":{"pageContent":"const [targetRect, setTargetRect] = useState(null);\n\nconst buttonRef = useRef(null);\n\nreturn (\n\n<>\n\n<button\n\n{...rest}\n\nref={buttonRef}\n\nonPointerEnter={() => {\n\nconst rect = buttonRef.current.getBoundingClientRect();\n\nsetTargetRect({\n\nleft: rect.left,\n\ntop: rect.top,\n\nright: rect.right,\n\nbottom: rect.bottom,\n\n});\n\n}}\n\nonPointerLeave={() => {\n\nsetTargetRect(null);\n\n}}\n\n/>\n\n{targetRect !== null && (\n\n<Tooltip targetRect={targetRect}>\n\n{tooltipContent}\n\n</Tooltip>\n\n)\n\n}\n\n</>\n\n);\n\n}\n\n```\n\n```js Tooltip.js active\n\nimport { useRef, useEffect, useState } from 'react';\n\nimport { createPortal } from 'react-dom';\n\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n\nconst ref = useRef(null);\n\nconst [tooltipHeight, setTooltipHeight] = useState(0);\n\nuseEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height);\n\n}, []);\n\nlet tooltipX = 0;\n\nlet tooltipY = 0;\n\nif (targetRect !== null) {\n\ntooltipX = targetRect.left;\n\ntooltipY = targetRect.top - tooltipHeight;\n\nif (tooltipY < 0) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"683":{"pageContent":"setTooltipHeight(height);\n\n}, []);\n\nlet tooltipX = 0;\n\nlet tooltipY = 0;\n\nif (targetRect !== null) {\n\ntooltipX = targetRect.left;\n\ntooltipY = targetRect.top - tooltipHeight;\n\nif (tooltipY < 0) {\n\n// It doesn't fit above, so place below.\n\ntooltipY = targetRect.bottom;\n\n}\n\n}\n\nreturn createPortal(\n\n<TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n\n{children}\n\n</TooltipContainer>,\n\ndocument.body\n\n);\n\n}\n\n```\n\n```js TooltipContainer.js\n\nexport default function TooltipContainer({ children, x, y, contentRef }) {\n\nreturn (\n\n<div\n\nstyle={{\n\nposition: 'absolute',\n\npointerEvents: 'none',\n\nleft: 0,\n\ntop: 0,\n\ntransform: `translate3d(${x}px, ${y}px, 0)`\n\n}}\n\n>\n\n<div ref={contentRef} className=\"tooltip\">\n\n{children}\n\n</div>\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.tooltip {\n\ncolor: white;\n\nbackground: #222;\n\nborder-radius: 4px;\n\npadding: 4px;\n\n}\n\n```\n\n</Sandpack>\n\nTo make the bug easier to reproduce, this version adds an artificial delay during rendering. React will let the browser paint the screen before it processes the state update inside `useEffect`. As a result, the tooltip flickers:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"684":{"pageContent":"<Sandpack>\n\n```js\n\nimport ButtonWithTooltip from './ButtonWithTooltip.js';\n\nexport default function App() {\n\nreturn (\n\n<div>\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>\n\nThis tooltip does not fit above the button.\n\n<br />\n\nThis is why it's displayed below instead!\n\n</div>\n\n}\n\n>\n\nHover over me (tooltip above)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n<div style={{ height: 50 }} />\n\n<ButtonWithTooltip\n\ntooltipContent={\n\n<div>This tooltip fits above the button</div>\n\n}\n\n>\n\nHover over me (tooltip below)\n\n</ButtonWithTooltip>\n\n</div>\n\n);\n\n}\n\n```\n\n```js ButtonWithTooltip.js\n\nimport { useState, useRef } from 'react';\n\nimport Tooltip from './Tooltip.js';\n\nexport default function ButtonWithTooltip({ tooltipContent, ...rest }) {\n\nconst [targetRect, setTargetRect] = useState(null);\n\nconst buttonRef = useRef(null);\n\nreturn (\n\n<>\n\n<button\n\n{...rest}\n\nref={buttonRef}\n\nonPointerEnter={() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"685":{"pageContent":"const [targetRect, setTargetRect] = useState(null);\n\nconst buttonRef = useRef(null);\n\nreturn (\n\n<>\n\n<button\n\n{...rest}\n\nref={buttonRef}\n\nonPointerEnter={() => {\n\nconst rect = buttonRef.current.getBoundingClientRect();\n\nsetTargetRect({\n\nleft: rect.left,\n\ntop: rect.top,\n\nright: rect.right,\n\nbottom: rect.bottom,\n\n});\n\n}}\n\nonPointerLeave={() => {\n\nsetTargetRect(null);\n\n}}\n\n/>\n\n{targetRect !== null && (\n\n<Tooltip targetRect={targetRect}>\n\n{tooltipContent}\n\n</Tooltip>\n\n)\n\n}\n\n</>\n\n);\n\n}\n\n```\n\n```js Tooltip.js active\n\nimport { useRef, useEffect, useState } from 'react';\n\nimport { createPortal } from 'react-dom';\n\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n\nconst ref = useRef(null);\n\nconst [tooltipHeight, setTooltipHeight] = useState(0);\n\n// This artificially slows down rendering\n\nlet now = performance.now();\n\nwhile (performance.now() - now < 100) {\n\n// Do nothing for a bit...\n\n}\n\nuseEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height);\n\n}, []);\n\nlet tooltipX = 0;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"686":{"pageContent":"while (performance.now() - now < 100) {\n\n// Do nothing for a bit...\n\n}\n\nuseEffect(() => {\n\nconst { height } = ref.current.getBoundingClientRect();\n\nsetTooltipHeight(height);\n\n}, []);\n\nlet tooltipX = 0;\n\nlet tooltipY = 0;\n\nif (targetRect !== null) {\n\ntooltipX = targetRect.left;\n\ntooltipY = targetRect.top - tooltipHeight;\n\nif (tooltipY < 0) {\n\n// It doesn't fit above, so place below.\n\ntooltipY = targetRect.bottom;\n\n}\n\n}\n\nreturn createPortal(\n\n<TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>\n\n{children}\n\n</TooltipContainer>,\n\ndocument.body\n\n);\n\n}\n\n```\n\n```js TooltipContainer.js\n\nexport default function TooltipContainer({ children, x, y, contentRef }) {\n\nreturn (\n\n<div\n\nstyle={{\n\nposition: 'absolute',\n\npointerEvents: 'none',\n\nleft: 0,\n\ntop: 0,\n\ntransform: `translate3d(${x}px, ${y}px, 0)`\n\n}}\n\n>\n\n<div ref={contentRef} className=\"tooltip\">\n\n{children}\n\n</div>\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.tooltip {\n\ncolor: white;\n\nbackground: #222;\n\nborder-radius: 4px;\n\npadding: 4px;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"687":{"pageContent":"}}\n\n>\n\n<div ref={contentRef} className=\"tooltip\">\n\n{children}\n\n</div>\n\n</div>\n\n);\n\n}\n\n```\n\n```css\n\n.tooltip {\n\ncolor: white;\n\nbackground: #222;\n\nborder-radius: 4px;\n\npadding: 4px;\n\n}\n\n```\n\n</Sandpack>\n\nEdit this example to `useLayoutEffect` and observe that it blocks the paint even if rendering is slowed down.\n\n<Solution />\n\n</Recipes>\n\n<Note>\n\nRendering in two passes and blocking the browser hurts performance. Try to avoid this when you can.\n\n</Note>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### I'm getting an error: \"`useLayoutEffect` does nothing on the server\" {/*im-getting-an-error-uselayouteffect-does-nothing-on-the-server*/}\n\nThe purpose of `useLayoutEffect` is to let your component [use layout information for rendering:](#measuring-layout-before-the-browser-repaints-the-screen)\n\n1. Render the initial content.\n\n2. Measure the layout *before the browser repaints the screen.*\n\n3. Render the final content using the layout information you've read.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"688":{"pageContent":"1. Render the initial content.\n\n2. Measure the layout *before the browser repaints the screen.*\n\n3. Render the final content using the layout information you've read.\n\nWhen you or your framework uses [server rendering](/reference/react-dom/server), your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.\n\nThe problem is that on the server, there is no layout information.\n\nIn the [earlier example](#measuring-layout-before-the-browser-repaints-the-screen), the `useLayoutEffect` call in the `Tooltip` component lets it position itself correctly (either above or below content) depending on the content height. If you tried to render `Tooltip` as a part of the initial server HTML, this would be impossible to determine. On the server, there is no browser and no layout! So, even if you rendered it on the server, its position would \"jump\" on the client after the JavaScript loads and runs.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"689":{"pageContent":"Usually, components that rely on layout information don't need to render on the server anyway. For example, it probably doesn't make sense to show a `Tooltip` during the initial render. It is triggered by a client interaction.\n\nHowever, if you're running into this problem, you have a few options:\n\n1. You can replace `useLayoutEffect` with [`useEffect`.](/reference/react/useEffect) This tells React that it's okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).\n\n2. You can [mark your component as client-only.](/reference/react/Suspense#providing-a-fallback-for-server-errors-and-server-only-content) This tells React to replace its content up to the closest [`<Suspense>`](/reference/react/Suspense) boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"690":{"pageContent":"3. You can display different components on the server and on the client. One way to do this is to keep a boolean `isMounted` state that's initialized to `false`, and set it to `true` inside a `useEffect` call. Your rendering logic can then be like `return isMounted ? <RealContent /> : <FallbackContent />`. On the server and during the hydration, the user will see `FallbackContent` which should not call `useLayoutEffect`. Then React will replace it with `RealContent` which runs on the client only and can include `useLayoutEffect` calls.\n\n4. If you synchronize your component with an external data store and rely on `useLayoutEffect` for different reasons than measuring layout, consider [`useSyncExternalStore`](/reference/react/useSyncExternalStore) instead which [supports server rendering.](/reference/react/useSyncExternalStore#adding-support-for-server-rendering)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useLayoutEffect.md"}},"691":{"pageContent":"--\n\ntitle: useTransition\n\n--\n\n<Intro>\n\n`useTransition` is a React Hook that lets you update the state without blocking the UI.\n\n```js\n\nconst [isPending, startTransition] = useTransition()\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useTransition()` {/*usetransition*/}\n\nCall `useTransition` at the top level of your component to mark some state updates as transitions.\n\n```js\n\nimport { useTransition } from 'react';\n\nfunction TabContainer() {\n\nconst [isPending, startTransition] = useTransition();\n\n// ...\n\n}\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`useTransition` does not take any parameters.\n\n#### Returns {/*returns*/}\n\n`useTransition` returns an array with exactly two items:\n\n1. The `isPending` flag that tells you whether there is a pending transition.\n\n2. The [`startTransition` function](#starttransition) that lets you mark a state update as a transition.\n\n--\n\n### `startTransition` function {/*starttransition*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"692":{"pageContent":"2. The [`startTransition` function](#starttransition) that lets you mark a state update as a transition.\n\n--\n\n### `startTransition` function {/*starttransition*/}\n\nThe `startTransition` function returned by `useTransition` lets you mark a state update as a transition.\n\n```js {6,8}\n\nfunction TabContainer() {\n\nconst [isPending, startTransition] = useTransition();\n\nconst [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\n// ...\n\n}\n\n```\n\n#### Parameters {/*starttransition-parameters*/}\n\n`scope`: A function that updates some state by calling one or more [`set` functions.](/reference/react/useState#setstate) React immediately calls `scope` with no parameters and marks all state updates scheduled synchronously during the `scope` function call as transitions. They will be [non-blocking](#marking-a-state-update-as-a-non-blocking-transition) and [will not display unwanted loading indicators.](#preventing-unwanted-loading-indicators)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"693":{"pageContent":"#### Returns {/*starttransition-returns*/}\n\n`startTransition` does not return anything.\n\n#### Caveats {/*starttransition-caveats*/}\n\n`useTransition` is a Hook, so it can only be called inside components or custom Hooks. If you need to start a transition somewhere else (for example, from a data library), call the standalone [`startTransition`](/reference/react/startTransition) instead.\n\nYou can wrap an update into a transition only if you have access to the `set` function of that state. If you want to start a transition in response to some prop or a custom Hook return value, try [`useDeferredValue`](/reference/react/useDeferredValue) instead.\n\nThe function you pass to `startTransition` must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as transitions. If you try to perform more state updates later (for example, in a timeout), they won't be marked as transitions.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"694":{"pageContent":"A state update marked as a transition will be interrupted by other state updates. For example, if you update a chart component inside a transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.\n\nTransition updates can't be used to control text inputs.\n\nIf there are multiple ongoing transitions, React currently batches them together. This is a limitation that will likely be removed in a future release.\n\n--\n\n## Usage {/*usage*/}\n\n### Marking a state update as a non-blocking transition {/*marking-a-state-update-as-a-non-blocking-transition*/}\n\nCall `useTransition` at the top level of your component to mark some state updates as non-blocking *transitions*.\n\n```js [[1, 4, \"isPending\"], [2, 4, \"startTransition\"]]\n\nimport { useState, useTransition } from 'react';\n\nfunction TabContainer() {\n\nconst [isPending, startTransition] = useTransition();\n\n// ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"695":{"pageContent":"```js [[1, 4, \"isPending\"], [2, 4, \"startTransition\"]]\n\nimport { useState, useTransition } from 'react';\n\nfunction TabContainer() {\n\nconst [isPending, startTransition] = useTransition();\n\n// ...\n\n}\n\n```\n\n`useTransition` returns an array with exactly two items:\n\n1. The <CodeStep step={1}>`isPending` flag</CodeStep> that tells you whether there is a pending transition.\n\n2. The <CodeStep step={2}>`startTransition` function</CodeStep> that lets you mark a state update as a transition.\n\nYou can then mark a state update as a transition like this:\n\n```js {6,8}\n\nfunction TabContainer() {\n\nconst [isPending, startTransition] = useTransition();\n\nconst [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\n// ...\n\n}\n\n```\n\nTransitions let you keep the user interface updates responsive even on slow devices.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"696":{"pageContent":"function selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\n// ...\n\n}\n\n```\n\nTransitions let you keep the user interface updates responsive even on slow devices.\n\nWith a transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.\n\n<Recipes titleText=\"The difference between useTransition and regular state updates\" titleId=\"examples\">\n\n#### Updating the current tab in a transition {/*updating-the-current-tab-in-a-transition*/}\n\nIn this example, the \"Posts\" tab is **artificially slowed down** so that it takes at least a second to render.\n\nClick \"Posts\" and then immediately click \"Contact\". Notice that this interrupts the slow render of \"Posts\". The \"Contact\" tab shows immediately. Because this state update is marked as a transition, a slow re-render did not freeze the user interface.\n\n<Sandpack>\n\n```js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"697":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useState, useTransition } from 'react';\n\nimport TabButton from './TabButton.js';\n\nimport AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';\n\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n\nconst [isPending, startTransition] = useTransition();\n\nconst [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nstartTransition(() => {\n\nsetTab(nextTab);\n\n});\n\n}\n\nreturn (\n\n<>\n\n<TabButton\n\nisActive={tab === 'about'}\n\nonClick={() => selectTab('about')}\n\n>\n\nAbout\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'posts'}\n\nonClick={() => selectTab('posts')}\n\n>\n\nPosts (slow)\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'contact'}\n\nonClick={() => selectTab('contact')}\n\n>\n\nContact\n\n</TabButton>\n\n<hr />\n\n{tab === 'about' && <AboutTab />}\n\n{tab === 'posts' && <PostsTab />}\n\n{tab === 'contact' && <ContactTab />}\n\n</>\n\n);\n\n}\n\n```\n\n```js TabButton.js\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"698":{"pageContent":"</>\n\n);\n\n}\n\n```\n\n```js TabButton.js\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nonClick();\n\n}}>\n\n{children}\n\n</button>\n\n)\n\n}\n\n```\n\n```js AboutTab.js\n\nexport default function AboutTab() {\n\nreturn (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js\n\nimport { memo } from 'react';\n\nconst PostsTab = memo(function PostsTab() {\n\n// Log once. The actual slowdown is inside SlowPost.\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering 500 <SlowPost />');\n\nlet items = [];\n\nfor (let i = 0; i < 500; i++) {\n\nitems.push(<SlowPost key={i} index={i} />);\n\n}\n\nreturn (\n\n<ul className=\"items\">\n\n{items}\n\n</ul>\n\n);\n\n});\n\nfunction SlowPost({ index }) {\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 1) {\n\n// Do nothing for 1 ms per item to emulate extremely slow code\n\n}\n\nreturn (\n\n<li className=\"item\">\n\nPost #{index + 1}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n```\n\n```js ContactTab.js\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"699":{"pageContent":"}\n\nreturn (\n\n<li className=\"item\">\n\nPost #{index + 1}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n```\n\n```js ContactTab.js\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Updating the current tab without a transition {/*updating-the-current-tab-without-a-transition*/}\n\nIn this example, the \"Posts\" tab is also **artificially slowed down** so that it takes at least a second to render. Unlike in the previous example, this state update is **not a transition.**\n\nClick \"Posts\" and then immediately click \"Contact\". Notice that the app freezes while rendering the slowed down tab, and the UI becomes unresponsive. This state update is not a transition, so a slow re-render freezed the user interface.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport TabButton from './TabButton.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"700":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport TabButton from './TabButton.js';\n\nimport AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';\n\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nfunction selectTab(nextTab) {\n\nsetTab(nextTab);\n\n}\n\nreturn (\n\n<>\n\n<TabButton\n\nisActive={tab === 'about'}\n\nonClick={() => selectTab('about')}\n\n>\n\nAbout\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'posts'}\n\nonClick={() => selectTab('posts')}\n\n>\n\nPosts (slow)\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'contact'}\n\nonClick={() => selectTab('contact')}\n\n>\n\nContact\n\n</TabButton>\n\n<hr />\n\n{tab === 'about' && <AboutTab />}\n\n{tab === 'posts' && <PostsTab />}\n\n{tab === 'contact' && <ContactTab />}\n\n</>\n\n);\n\n}\n\n```\n\n```js TabButton.js\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nonClick();\n\n}}>\n\n{children}\n\n</button>\n\n)\n\n}\n\n```\n\n```js AboutTab.js","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"701":{"pageContent":"export default function TabButton({ children, isActive, onClick }) {\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nonClick();\n\n}}>\n\n{children}\n\n</button>\n\n)\n\n}\n\n```\n\n```js AboutTab.js\n\nexport default function AboutTab() {\n\nreturn (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js\n\nimport { memo } from 'react';\n\nconst PostsTab = memo(function PostsTab() {\n\n// Log once. The actual slowdown is inside SlowPost.\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering 500 <SlowPost />');\n\nlet items = [];\n\nfor (let i = 0; i < 500; i++) {\n\nitems.push(<SlowPost key={i} index={i} />);\n\n}\n\nreturn (\n\n<ul className=\"items\">\n\n{items}\n\n</ul>\n\n);\n\n});\n\nfunction SlowPost({ index }) {\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 1) {\n\n// Do nothing for 1 ms per item to emulate extremely slow code\n\n}\n\nreturn (\n\n<li className=\"item\">\n\nPost #{index + 1}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n```\n\n```js ContactTab.js\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"702":{"pageContent":"Post #{index + 1}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n```\n\n```js ContactTab.js\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Updating the parent component in a transition {/*updating-the-parent-component-in-a-transition*/}\n\nThe `useTransition` call does not have to be in the same component whose state you're updating. You can also move it into a child component. For example, this `TabButton` component wraps its `onClick` logic in a transition:\n\n```js {8-10}\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nconst [isPending, startTransition] = useTransition();\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nstartTransition(() => {\n\nonClick();\n\n});\n\n}}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"703":{"pageContent":"const [isPending, startTransition] = useTransition();\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nstartTransition(() => {\n\nonClick();\n\n});\n\n}}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\nBecause the parent component updates its state inside the `onClick` event handler, that state update gets marked as a transition. This is why, like in the earlier example, you can click on \"Posts\" and then immediately click \"Contact\". Updating the selected tab is marked as a transition, so it does not block further user interactions.\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport TabButton from './TabButton.js';\n\nimport AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';\n\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nreturn (\n\n<>\n\n<TabButton\n\nisActive={tab === 'about'}\n\nonClick={() => setTab('about')}\n\n>\n\nAbout\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'posts'}\n\nonClick={() => setTab('posts')}\n\n>\n\nPosts (slow)\n\n</TabButton>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"704":{"pageContent":"return (\n\n<>\n\n<TabButton\n\nisActive={tab === 'about'}\n\nonClick={() => setTab('about')}\n\n>\n\nAbout\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'posts'}\n\nonClick={() => setTab('posts')}\n\n>\n\nPosts (slow)\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'contact'}\n\nonClick={() => setTab('contact')}\n\n>\n\nContact\n\n</TabButton>\n\n<hr />\n\n{tab === 'about' && <AboutTab />}\n\n{tab === 'posts' && <PostsTab />}\n\n{tab === 'contact' && <ContactTab />}\n\n</>\n\n);\n\n}\n\n```\n\n```js TabButton.js active\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nconst [isPending, startTransition] = useTransition();\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nstartTransition(() => {\n\nonClick();\n\n});\n\n}}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```js AboutTab.js\n\nexport default function AboutTab() {\n\nreturn (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js\n\nimport { memo } from 'react';\n\nconst PostsTab = memo(function PostsTab() {\n\n// Log once. The actual slowdown is inside SlowPost.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"705":{"pageContent":"return (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js\n\nimport { memo } from 'react';\n\nconst PostsTab = memo(function PostsTab() {\n\n// Log once. The actual slowdown is inside SlowPost.\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering 500 <SlowPost />');\n\nlet items = [];\n\nfor (let i = 0; i < 500; i++) {\n\nitems.push(<SlowPost key={i} index={i} />);\n\n}\n\nreturn (\n\n<ul className=\"items\">\n\n{items}\n\n</ul>\n\n);\n\n});\n\nfunction SlowPost({ index }) {\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 1) {\n\n// Do nothing for 1 ms per item to emulate extremely slow code\n\n}\n\nreturn (\n\n<li className=\"item\">\n\nPost #{index + 1}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n```\n\n```js ContactTab.js\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n```\n\n</Sandpack>\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"706":{"pageContent":"<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n```\n\n</Sandpack>\n\n--\n\n### Displaying a pending visual state during the transition {/*displaying-a-pending-visual-state-during-the-transition*/}\n\nYou can use the `isPending` boolean value returned by `useTransition` to indicate to the user that a transition is in progress. For example, the tab button can have a special \"pending\" visual state:\n\n```js {4-6}\n\nfunction TabButton({ children, isActive, onClick }) {\n\nconst [isPending, startTransition] = useTransition();\n\n// ...\n\nif (isPending) {\n\nreturn <b className=\"pending\">{children}</b>;\n\n}\n\n// ...\n\n```\n\nNotice how clicking \"Posts\" now feels more responsive because the tab button itself updates right away:\n\n<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport TabButton from './TabButton.js';\n\nimport AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"707":{"pageContent":"<Sandpack>\n\n```js\n\nimport { useState } from 'react';\n\nimport TabButton from './TabButton.js';\n\nimport AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';\n\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nreturn (\n\n<>\n\n<TabButton\n\nisActive={tab === 'about'}\n\nonClick={() => setTab('about')}\n\n>\n\nAbout\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'posts'}\n\nonClick={() => setTab('posts')}\n\n>\n\nPosts (slow)\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'contact'}\n\nonClick={() => setTab('contact')}\n\n>\n\nContact\n\n</TabButton>\n\n<hr />\n\n{tab === 'about' && <AboutTab />}\n\n{tab === 'posts' && <PostsTab />}\n\n{tab === 'contact' && <ContactTab />}\n\n</>\n\n);\n\n}\n\n```\n\n```js TabButton.js active\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nconst [isPending, startTransition] = useTransition();\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nif (isPending) {\n\nreturn <b className=\"pending\">{children}</b>;\n\n}\n\nreturn (\n\n<button onClick={() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"708":{"pageContent":"const [isPending, startTransition] = useTransition();\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nif (isPending) {\n\nreturn <b className=\"pending\">{children}</b>;\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nstartTransition(() => {\n\nonClick();\n\n});\n\n}}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```js AboutTab.js\n\nexport default function AboutTab() {\n\nreturn (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js\n\nimport { memo } from 'react';\n\nconst PostsTab = memo(function PostsTab() {\n\n// Log once. The actual slowdown is inside SlowPost.\n\nconsole.log('[ARTIFICIALLY SLOW] Rendering 500 <SlowPost />');\n\nlet items = [];\n\nfor (let i = 0; i < 500; i++) {\n\nitems.push(<SlowPost key={i} index={i} />);\n\n}\n\nreturn (\n\n<ul className=\"items\">\n\n{items}\n\n</ul>\n\n);\n\n});\n\nfunction SlowPost({ index }) {\n\nlet startTime = performance.now();\n\nwhile (performance.now() - startTime < 1) {\n\n// Do nothing for 1 ms per item to emulate extremely slow code\n\n}\n\nreturn (\n\n<li className=\"item\">\n\nPost #{index + 1}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n```\n\n```js ContactTab.js\n\nexport default function ContactTab() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"709":{"pageContent":"}\n\nreturn (\n\n<li className=\"item\">\n\nPost #{index + 1}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n```\n\n```js ContactTab.js\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n.pending { color: #777; }\n\n```\n\n</Sandpack>\n\n--\n\n### Preventing unwanted loading indicators {/*preventing-unwanted-loading-indicators*/}\n\nIn this example, the `PostsTab` component fetches some data using a [Suspense-enabled](/reference/react/Suspense) data source. When you click the \"Posts\" tab, the `PostsTab` component *suspends*, causing the closest loading fallback to be displayed:\n\n<Sandpack>\n\n```js\n\nimport { Suspense, useState } from 'react';\n\nimport TabButton from './TabButton.js';\n\nimport AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';\n\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n\nconst [tab, setTab] = useState('about');","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"710":{"pageContent":"import AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';\n\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nreturn (\n\n<Suspense fallback={<h1>ðŸŒ€ Loading...</h1>}>\n\n<TabButton\n\nisActive={tab === 'about'}\n\nonClick={() => setTab('about')}\n\n>\n\nAbout\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'posts'}\n\nonClick={() => setTab('posts')}\n\n>\n\nPosts\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'contact'}\n\nonClick={() => setTab('contact')}\n\n>\n\nContact\n\n</TabButton>\n\n<hr />\n\n{tab === 'about' && <AboutTab />}\n\n{tab === 'posts' && <PostsTab />}\n\n{tab === 'contact' && <ContactTab />}\n\n</Suspense>\n\n);\n\n}\n\n```\n\n```js TabButton.js\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nonClick();\n\n}}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```js AboutTab.js hidden\n\nexport default function AboutTab() {\n\nreturn (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js hidden\n\nimport { fetchData } from './data.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"711":{"pageContent":"}}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```js AboutTab.js hidden\n\nexport default function AboutTab() {\n\nreturn (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nfunction PostsTab() {\n\nconst posts = use(fetchData('/posts'));\n\nreturn (\n\n<ul className=\"items\">\n\n{posts.map(post =>\n\n<Post key={post.id} title={post.title} />\n\n)}\n\n</ul>\n\n);\n\n}\n\nfunction Post({ title }) {\n\nreturn (\n\n<li className=\"item\">\n\n{title}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"712":{"pageContent":"function use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js ContactTab.js hidden\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/posts')) {\n\nreturn await getPosts();\n\n} else {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"713":{"pageContent":"export function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/posts')) {\n\nreturn await getPosts();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getPosts() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 1000);\n\n});\n\nlet posts = [];\n\nfor (let i = 0; i < 500; i++) {\n\nposts.push({\n\nid: i,\n\ntitle: 'Post #' + (i + 1)\n\n});\n\n}\n\nreturn posts;\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n.pending { color: #777; }\n\n```\n\n</Sandpack>\n\nHiding the entire tab container to show a loading indicator leads to a jarring user experience. If you add `useTransition` to `TabButton`, you can instead indicate display the pending state in the tab button instead.\n\nNotice that clicking \"Posts\" no longer replaces the entire tab container with a spinner:\n\n<Sandpack>\n\n```js\n\nimport { Suspense, useState } from 'react';\n\nimport TabButton from './TabButton.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"714":{"pageContent":"Notice that clicking \"Posts\" no longer replaces the entire tab container with a spinner:\n\n<Sandpack>\n\n```js\n\nimport { Suspense, useState } from 'react';\n\nimport TabButton from './TabButton.js';\n\nimport AboutTab from './AboutTab.js';\n\nimport PostsTab from './PostsTab.js';\n\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n\nconst [tab, setTab] = useState('about');\n\nreturn (\n\n<Suspense fallback={<h1>ðŸŒ€ Loading...</h1>}>\n\n<TabButton\n\nisActive={tab === 'about'}\n\nonClick={() => setTab('about')}\n\n>\n\nAbout\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'posts'}\n\nonClick={() => setTab('posts')}\n\n>\n\nPosts\n\n</TabButton>\n\n<TabButton\n\nisActive={tab === 'contact'}\n\nonClick={() => setTab('contact')}\n\n>\n\nContact\n\n</TabButton>\n\n<hr />\n\n{tab === 'about' && <AboutTab />}\n\n{tab === 'posts' && <PostsTab />}\n\n{tab === 'contact' && <ContactTab />}\n\n</Suspense>\n\n);\n\n}\n\n```\n\n```js TabButton.js active\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"715":{"pageContent":"{tab === 'contact' && <ContactTab />}\n\n</Suspense>\n\n);\n\n}\n\n```\n\n```js TabButton.js active\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n\nconst [isPending, startTransition] = useTransition();\n\nif (isActive) {\n\nreturn <b>{children}</b>\n\n}\n\nif (isPending) {\n\nreturn <b className=\"pending\">{children}</b>;\n\n}\n\nreturn (\n\n<button onClick={() => {\n\nstartTransition(() => {\n\nonClick();\n\n});\n\n}}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```js AboutTab.js hidden\n\nexport default function AboutTab() {\n\nreturn (\n\n<p>Welcome to my profile!</p>\n\n);\n\n}\n\n```\n\n```js PostsTab.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nfunction PostsTab() {\n\nconst posts = use(fetchData('/posts'));\n\nreturn (\n\n<ul className=\"items\">\n\n{posts.map(post =>\n\n<Post key={post.id} title={post.title} />\n\n)}\n\n</ul>\n\n);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"716":{"pageContent":"function PostsTab() {\n\nconst posts = use(fetchData('/posts'));\n\nreturn (\n\n<ul className=\"items\">\n\n{posts.map(post =>\n\n<Post key={post.id} title={post.title} />\n\n)}\n\n</ul>\n\n);\n\n}\n\nfunction Post({ title }) {\n\nreturn (\n\n<li className=\"item\">\n\n{title}\n\n</li>\n\n);\n\n}\n\nexport default PostsTab;\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js ContactTab.js hidden\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```js data.js hidden","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"717":{"pageContent":"}\n\n}\n\n```\n\n```js ContactTab.js hidden\n\nexport default function ContactTab() {\n\nreturn (\n\n<>\n\n<p>\n\nYou can find me online here:\n\n</p>\n\n<ul>\n\n<li>admin@mysite.com</li>\n\n<li>+123456789</li>\n\n</ul>\n\n</>\n\n);\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url.startsWith('/posts')) {\n\nreturn await getPosts();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getPosts() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 1000);\n\n});\n\nlet posts = [];\n\nfor (let i = 0; i < 500; i++) {\n\nposts.push({\n\nid: i,\n\ntitle: 'Post #' + (i + 1)\n\n});\n\n}\n\nreturn posts;\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n.pending { color: #777; }\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"718":{"pageContent":"posts.push({\n\nid: i,\n\ntitle: 'Post #' + (i + 1)\n\n});\n\n}\n\nreturn posts;\n\n}\n\n```\n\n```css\n\nbutton { margin-right: 10px }\n\nb { display: inline-block; margin-right: 10px; }\n\n.pending { color: #777; }\n\n```\n\n</Sandpack>\n\n[Read more about using transitions with Suspense.](/reference/react/Suspense#preventing-already-revealed-content-from-hiding)\n\n<Note>\n\nTransitions will only \"wait\" long enough to avoid hiding *already revealed* content (like the tab container). For example, if the Posts tab had a [nested `<Suspense>` boundary,](/reference/react/Suspense#revealing-nested-content-as-it-loads) the transition would not \"wait\" for it.\n\n</Note>\n\n--\n\n### Building a Suspense-enabled router {/*building-a-suspense-enabled-router*/}\n\nIf you're building your own React framework or a router, we recommend to mark page navigations as transitions.\n\n```js {3,6,8}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nconst [isPending, startTransition] = useTransition();\n\nfunction navigate(url) {\n\nstartTransition(() => {\n\nsetPage(url);\n\n});\n\n}\n\n// ...\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"719":{"pageContent":"```js {3,6,8}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nconst [isPending, startTransition] = useTransition();\n\nfunction navigate(url) {\n\nstartTransition(() => {\n\nsetPage(url);\n\n});\n\n}\n\n// ...\n\n```\n\nThis is recommended for two reasons:\n\n[Transitions are interruptible,](#marking-a-state-update-as-a-non-blocking-transition) which lets the user click away without waiting for the re-render to complete.\n\n[Transitions prevent unwanted loading indicators,](#preventing-unwanted-loading-indicators) which lets the user avoid jarring jumps on navigation.\n\nHere is a tiny simplified router example using transitions for navigations.\n\n<Sandpack>\n\n```json package.json hidden\n\n{\n\n\"dependencies\": {\n\n\"react\": \"experimental\",\n\n\"react-dom\": \"experimental\"\n\n},\n\n\"scripts\": {\n\n\"start\": \"react-scripts start\",\n\n\"build\": \"react-scripts build\",\n\n\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState, useTransition } from 'react';\n\nimport IndexPage from './IndexPage.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"720":{"pageContent":"\"test\": \"react-scripts test --env=jsdom\",\n\n\"eject\": \"react-scripts eject\"\n\n}\n\n}\n\n```\n\n```js App.js\n\nimport { Suspense, useState, useTransition } from 'react';\n\nimport IndexPage from './IndexPage.js';\n\nimport ArtistPage from './ArtistPage.js';\n\nimport Layout from './Layout.js';\n\nexport default function App() {\n\nreturn (\n\n<Suspense fallback={<BigSpinner />}>\n\n<Router />\n\n</Suspense>\n\n);\n\n}\n\nfunction Router() {\n\nconst [page, setPage] = useState('/');\n\nconst [isPending, startTransition] = useTransition();\n\nfunction navigate(url) {\n\nstartTransition(() => {\n\nsetPage(url);\n\n});\n\n}\n\nlet content;\n\nif (page === '/') {\n\ncontent = (\n\n<IndexPage navigate={navigate} />\n\n);\n\n} else if (page === '/the-beatles') {\n\ncontent = (\n\n<ArtistPage\n\nartist={{\n\nid: 'the-beatles',\n\nname: 'The Beatles',\n\n}}\n\n/>\n\n);\n\n}\n\nreturn (\n\n<Layout isPending={isPending}>\n\n{content}\n\n</Layout>\n\n);\n\n}\n\nfunction BigSpinner() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Layout.js\n\nexport default function Layout({ children, isPending }) {\n\nreturn (\n\n<div className=\"layout\">\n\n<section className=\"header\" style={{","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"721":{"pageContent":");\n\n}\n\nfunction BigSpinner() {\n\nreturn <h2>ðŸŒ€ Loading...</h2>;\n\n}\n\n```\n\n```js Layout.js\n\nexport default function Layout({ children, isPending }) {\n\nreturn (\n\n<div className=\"layout\">\n\n<section className=\"header\" style={{\n\nopacity: isPending ? 0.7 : 1\n\n}}>\n\nMusic Browser\n\n</section>\n\n<main>\n\n{children}\n\n</main>\n\n</div>\n\n);\n\n}\n\n```\n\n```js IndexPage.js\n\nexport default function IndexPage({ navigate }) {\n\nreturn (\n\n<button onClick={() => navigate('/the-beatles')}>\n\nOpen The Beatles artist page\n\n</button>\n\n);\n\n}\n\n```\n\n```js ArtistPage.js\n\nimport { Suspense } from 'react';\n\nimport Albums from './Albums.js';\n\nimport Biography from './Biography.js';\n\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n\nreturn (\n\n<>\n\n<h1>{artist.name}</h1>\n\n<Biography artistId={artist.id} />\n\n<Suspense fallback={<AlbumsGlimmer />}>\n\n<Panel>\n\n<Albums artistId={artist.id} />\n\n</Panel>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction AlbumsGlimmer() {\n\nreturn (\n\n<div className=\"glimmer-panel\">\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"722":{"pageContent":"</Panel>\n\n</Suspense>\n\n</>\n\n);\n\n}\n\nfunction AlbumsGlimmer() {\n\nreturn (\n\n<div className=\"glimmer-panel\">\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n<div className=\"glimmer-line\" />\n\n</div>\n\n);\n\n}\n\n```\n\n```js Albums.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Albums({ artistId }) {\n\nconst albums = use(fetchData(`/${artistId}/albums`));\n\nreturn (\n\n<ul>\n\n{albums.map(album => (\n\n<li key={album.id}>\n\n{album.title} ({album.year})\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"723":{"pageContent":"function use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Biography.js hidden\n\nimport { fetchData } from './data.js';\n\n// Note: this component is written using an experimental API\n\n// that's not yet available in stable versions of React.\n\n// For a realistic example you can follow today, try a framework\n\n// that's integrated with Suspense, like Relay or Next.js.\n\nexport default function Biography({ artistId }) {\n\nconst bio = use(fetchData(`/${artistId}/bio`));\n\nreturn (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"724":{"pageContent":"return (\n\n<section>\n\n<p className=\"bio\">{bio}</p>\n\n</section>\n\n);\n\n}\n\n// This is a workaround for a bug to get the demo running.\n\n// TODO: replace with real implementation when the bug is fixed.\n\nfunction use(promise) {\n\nif (promise.status === 'fulfilled') {\n\nreturn promise.value;\n\n} else if (promise.status === 'rejected') {\n\nthrow promise.reason;\n\n} else if (promise.status === 'pending') {\n\nthrow promise;\n\n} else {\n\npromise.status = 'pending';\n\npromise.then(\n\nresult => {\n\npromise.status = 'fulfilled';\n\npromise.value = result;\n\n},\n\nreason => {\n\npromise.status = 'rejected';\n\npromise.reason = reason;\n\n},\n\n);\n\nthrow promise;\n\n}\n\n}\n\n```\n\n```js Panel.js hidden\n\nexport default function Panel({ children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n{children}\n\n</section>\n\n);\n\n}\n\n```\n\n```js data.js hidden\n\n// Note: the way you would do data fetching depends on\n\n// the framework that you use together with Suspense.\n\n// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"725":{"pageContent":"// Normally, the caching logic would be inside a framework.\n\nlet cache = new Map();\n\nexport function fetchData(url) {\n\nif (!cache.has(url)) {\n\ncache.set(url, getData(url));\n\n}\n\nreturn cache.get(url);\n\n}\n\nasync function getData(url) {\n\nif (url === '/the-beatles/albums') {\n\nreturn await getAlbums();\n\n} else if (url === '/the-beatles/bio') {\n\nreturn await getBio();\n\n} else {\n\nthrow Error('Not implemented');\n\n}\n\n}\n\nasync function getBio() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 500);\n\n});\n\nreturn `The Beatles were an English rock band,\n\nformed in Liverpool in 1960, that comprised\n\nJohn Lennon, Paul McCartney, George Harrison\n\nand Ringo Starr.`;\n\n}\n\nasync function getAlbums() {\n\n// Add a fake delay to make waiting noticeable.\n\nawait new Promise(resolve => {\n\nsetTimeout(resolve, 3000);\n\n});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"726":{"pageContent":"});\n\nreturn [{\n\nid: 13,\n\ntitle: 'Let It Be',\n\nyear: 1970\n\n}, {\n\nid: 12,\n\ntitle: 'Abbey Road',\n\nyear: 1969\n\n}, {\n\nid: 11,\n\ntitle: 'Yellow Submarine',\n\nyear: 1969\n\n}, {\n\nid: 10,\n\ntitle: 'The Beatles',\n\nyear: 1968\n\n}, {\n\nid: 9,\n\ntitle: 'Magical Mystery Tour',\n\nyear: 1967\n\n}, {\n\nid: 8,\n\ntitle: 'Sgt. Pepper\\'s Lonely Hearts Club Band',\n\nyear: 1967\n\n}, {\n\nid: 7,\n\ntitle: 'Revolver',\n\nyear: 1966\n\n}, {\n\nid: 6,\n\ntitle: 'Rubber Soul',\n\nyear: 1965\n\n}, {\n\nid: 5,\n\ntitle: 'Help!',\n\nyear: 1965\n\n}, {\n\nid: 4,\n\ntitle: 'Beatles For Sale',\n\nyear: 1964\n\n}, {\n\nid: 3,\n\ntitle: 'A Hard Day\\'s Night',\n\nyear: 1964\n\n}, {\n\nid: 2,\n\ntitle: 'With The Beatles',\n\nyear: 1963\n\n}, {\n\nid: 1,\n\ntitle: 'Please Please Me',\n\nyear: 1963\n\n}];\n\n}\n\n```\n\n```css\n\nmain {\n\nmin-height: 200px;\n\npadding: 10px;\n\n}\n\n.layout {\n\nborder: 1px solid black;\n\n}\n\n.header {\n\nbackground: #222;\n\npadding: 10px;\n\ntext-align: center;\n\ncolor: white;\n\n}\n\n.bio { font-style: italic; }\n\n.panel {\n\nborder: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-panel {\n\nborder: 1px dashed #aaa;\n\nbackground: linear-gradient(90deg, rgba(221,221,221,1) 0%, rgba(255,255,255,1) 100%);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"727":{"pageContent":"border: 1px solid #aaa;\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-panel {\n\nborder: 1px dashed #aaa;\n\nbackground: linear-gradient(90deg, rgba(221,221,221,1) 0%, rgba(255,255,255,1) 100%);\n\nborder-radius: 6px;\n\nmargin-top: 20px;\n\npadding: 10px;\n\n}\n\n.glimmer-line {\n\ndisplay: block;\n\nwidth: 60%;\n\nheight: 20px;\n\nmargin: 10px;\n\nborder-radius: 4px;\n\nbackground: #f0f0f0;\n\n}\n\n```\n\n</Sandpack>\n\n<Note>\n\n[Suspense-enabled](/reference/react/Suspense) routers are expected to wrap the navigation updates into transitions by default.\n\n</Note>\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### Updating an input in a transition doesn't work {/*updating-an-input-in-a-transition-doesnt-work*/}\n\nYou can't use a transition for a state variable that controls an input:\n\n```js {4,10}\n\nconst [text, setText] = useState('');\n\n// ...\n\nfunction handleChange(e) {\n\n// âŒ Can't use transitions for controlled input state\n\nstartTransition(() => {\n\nsetText(e.target.value);\n\n});\n\n}\n\n// ...\n\nreturn <input value={text} onChange={handleChange} />;\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"728":{"pageContent":"// ...\n\nfunction handleChange(e) {\n\n// âŒ Can't use transitions for controlled input state\n\nstartTransition(() => {\n\nsetText(e.target.value);\n\n});\n\n}\n\n// ...\n\nreturn <input value={text} onChange={handleChange} />;\n\n```\n\nThis is because transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a transition in response to typing, you have two options:\n\n1. You can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a transition. This lets you control the input using the synchronous state, and pass the transition state variable (which will \"lag behind\" the input) to the rest of your rendering logic.\n\n2. Alternatively, you can have one state variable, and add [`useDeferredValue`](/reference/react/useDeferredValue) which will \"lag behind\" the real value. It will trigger non-blocking re-renders to \"catch up\" with the new value automatically.\n\n--","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"729":{"pageContent":"--\n\n### React doesn't treat my state update as a transition {/*react-doesnt-treat-my-state-update-as-a-transition*/}\n\nWhen you wrap a state update in a transition, make sure that it happens *during* the `startTransition` call:\n\n```js\n\nstartTransition(() => {\n\n// âœ… Setting state *during* startTransition call\n\nsetPage('/about');\n\n});\n\n```\n\nThe function you pass to `startTransition` must be synchronous.\n\nYou can't mark an update as a transition like this:\n\n```js\n\nstartTransition(() => {\n\n// âŒ Setting state *after* startTransition call\n\nsetTimeout(() => {\n\nsetPage('/about');\n\n}, 1000);\n\n});\n\n```\n\nInstead, you could do this:\n\n```js\n\nsetTimeout(() => {\n\nstartTransition(() => {\n\n// âœ… Setting state *during* startTransition call\n\nsetPage('/about');\n\n});\n\n}, 1000);\n\n```\n\nSimilarly, you can't mark an update as a transition like this:\n\n```js\n\nstartTransition(async () => {\n\nawait someAsyncFunction();\n\n// âŒ Setting state *after* startTransition call\n\nsetPage('/about');\n\n});\n\n```\n\nHowever, this works instead:\n\n```js\n\nawait someAsyncFunction();\n\nstartTransition(() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"730":{"pageContent":"await someAsyncFunction();\n\n// âŒ Setting state *after* startTransition call\n\nsetPage('/about');\n\n});\n\n```\n\nHowever, this works instead:\n\n```js\n\nawait someAsyncFunction();\n\nstartTransition(() => {\n\n// âœ… Setting state *during* startTransition call\n\nsetPage('/about');\n\n});\n\n```\n\n--\n\n### I want to call `useTransition` from outside a component {/*i-want-to-call-usetransition-from-outside-a-component*/}\n\nYou can't call `useTransition` outside a component because it's a Hook. In this case, use the standalone [`startTransition`](/reference/react/startTransition) method instead. It works the same way, but it doesn't provide the `isPending` indicator.\n\n--\n\n### The function I pass to `startTransition` executes immediately {/*the-function-i-pass-to-starttransition-executes-immediately*/}\n\nIf you run this code, it will print 1, 2, 3:\n\n```js {1,3,6}\n\nconsole.log(1);\n\nstartTransition(() => {\n\nconsole.log(2);\n\nsetPage('/about');\n\n});\n\nconsole.log(3);\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"731":{"pageContent":"If you run this code, it will print 1, 2, 3:\n\n```js {1,3,6}\n\nconsole.log(1);\n\nstartTransition(() => {\n\nconsole.log(2);\n\nsetPage('/about');\n\n});\n\nconsole.log(3);\n\n```\n\n*It is expected to print 1, 2, 3.** The function you pass to `startTransition` does not get delayed. Unlike with the browser `setTimeout`, it does not run the callback later. React executes your function immediately, but any state updates scheduled *while it is running* will get marked as transitions. You can imagine that it works like this:\n\n```js\n\n// A simplified version of how React works\n\nlet isInsideTransition = false;\n\nfunction startTransition(scope) {\n\nisInsideTransition = true;\n\nscope();\n\nisInsideTransition = false;\n\n}\n\nfunction setState() {\n\nif (isInsideTransition) {\n\n// ... schedule a transition state update ...\n\n} else {\n\n// ... schedule an urgent state update ...\n\n}\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useTransition.md"}},"732":{"pageContent":"--\n\ntitle: useEffectEvent\n\n--\n\n<Wip>\n\n*This API is experimental and is not available in a stable version of React yet.**\n\nYou can try it by upgrading React packages to the most recent experimental version:\n\n`react@experimental`\n\n`react-dom@experimental`\n\n`eslint-plugin-react-hooks@experimental`\n\nExperimental versions of React may contain bugs. Don't use them in production.\n\n</Wip>\n\n<Intro>\n\n`useEffectEvent` is a React Hook that lets you extract non-reactive logic into an [Effect Event.](/learn/separating-events-from-effects#declaring-an-effect-event)\n\n```js\n\nconst onSomething = useEffectEvent(callback)\n\n```\n\n</Intro>\n\n<InlineToc />","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useEffectEvent.md"}},"733":{"pageContent":"--\n\ntitle: useContext\n\n--\n\n<Intro>\n\n`useContext` is a React Hook that lets you read and subscribe to [context](/learn/passing-data-deeply-with-context) from your component.\n\n```js\n\nconst value = useContext(SomeContext)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `useContext(SomeContext)` {/*usecontext*/}\n\nCall `useContext` at the top level of your component to read and subscribe to [context.](/learn/passing-data-deeply-with-context)\n\n```js\n\nimport { useContext } from 'react';\n\nfunction MyComponent() {\n\nconst theme = useContext(ThemeContext);\n\n// ...\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`SomeContext`: The context that you've previously created with [`createContext`](/reference/react/createContext). The context itself does not hold the information, it only represents the kind of information you can provide or read from components.\n\n#### Returns {/*returns*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"734":{"pageContent":"#### Returns {/*returns*/}\n\n`useContext` returns the context value for the calling component. It is determined as the `value` passed to the closest `SomeContext.Provider` above the calling component in the tree. If there is no such provider, then the returned value will be the `defaultValue` you have passed to [`createContext`](/reference/react/createContext) for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.\n\n#### Caveats {/*caveats*/}\n\n`useContext()` call in a component is not affected by providers returned from the *same* component. The corresponding `<Context.Provider>` **needs to be *above*** the component doing the `useContext()` call.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"735":{"pageContent":"React **automatically re-renders** all the children that use a particular context starting from the provider that receives a different `value`. The previous and the next values are compared with the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. Skipping re-renders with [`memo`](/reference/react/memo) does not prevent the children receiving fresh context values from above.\n\nIf your build system produces duplicates modules in the output (which can happen if you use symlinks), this can break context. Passing something via context only works if `SomeContext` that you use to provide context and `SomeContext` that you use to read it are ***exactly* the same object**, as determined by a `===` comparison.\n\n--\n\n## Usage {/*usage*/}\n\n### Passing data deeply into the tree {/*passing-data-deeply-into-the-tree*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"736":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Passing data deeply into the tree {/*passing-data-deeply-into-the-tree*/}\n\nCall `useContext` at the top level of your component to read and subscribe to [context.](/learn/passing-data-deeply-with-context)\n\n```js [[2, 4, \"theme\"], [1, 4, \"ThemeContext\"]]\n\nimport { useContext } from 'react';\n\nfunction Button() {\n\nconst theme = useContext(ThemeContext);\n\n// ...\n\n```\n\n`useContext` returns the <CodeStep step={2}>context value</CodeStep> for the <CodeStep step={1}>context</CodeStep> you passed. To determine the context value, React searches the component tree and finds **the closest context provider above** for that particular context.\n\nTo pass context to a `Button`, wrap it or one of its parent components into the corresponding context provider:\n\n```js [[1, 3, \"ThemeContext\"], [2, 3, \"\\\\\"dark\\\\\"\"], [1, 5, \"ThemeContext\"]]\n\nfunction MyPage() {\n\nreturn (\n\n<ThemeContext.Provider value=\"dark\">\n\n<Form />\n\n</ThemeContext.Provider>\n\n);\n\n}\n\nfunction Form() {\n\n// ... renders buttons inside ...\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"737":{"pageContent":"function MyPage() {\n\nreturn (\n\n<ThemeContext.Provider value=\"dark\">\n\n<Form />\n\n</ThemeContext.Provider>\n\n);\n\n}\n\nfunction Form() {\n\n// ... renders buttons inside ...\n\n}\n\n```\n\nIt doesn't matter how many layers of components there are between the provider and the `Button`. When a `Button` *anywhere* inside of `Form` calls `useContext(ThemeContext)`, it will receive `\"dark\"` as the value.\n\n<Pitfall>\n\n`useContext()` always looks for the closest provider *above* the component that calls it. It searches upwards and **does not** consider providers in the component from which you're calling `useContext()`.\n\n</Pitfall>\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n\nreturn (\n\n<ThemeContext.Provider value=\"dark\">\n\n<Form />\n\n</ThemeContext.Provider>\n\n)\n\n}\n\nfunction Form() {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n</Panel>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"738":{"pageContent":")\n\n}\n\nfunction Form() {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n</Panel>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n<h1>{title}</h1>\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Updating data passed via context {/*updating-data-passed-via-context*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"739":{"pageContent":"margin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Updating data passed via context {/*updating-data-passed-via-context*/}\n\nOften, you'll want the context to change over time. To update context, you need to combine it with [state.](/reference/react/useState) Declare a state variable in the parent component, and pass the current state down as the <CodeStep step={2}>context value</CodeStep> to the provider.\n\n```js {2} [[1, 4, \"ThemeContext\"], [2, 4, \"theme\"], [1, 11, \"ThemeContext\"]]\n\nfunction MyPage() {\n\nconst [theme, setTheme] = useState('dark');\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<Form />\n\n<Button onClick={() => {\n\nsetTheme('light');\n\n}}>\n\nSwitch to light theme\n\n</Button>\n\n</ThemeContext.Provider>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"740":{"pageContent":"return (\n\n<ThemeContext.Provider value={theme}>\n\n<Form />\n\n<Button onClick={() => {\n\nsetTheme('light');\n\n}}>\n\nSwitch to light theme\n\n</Button>\n\n</ThemeContext.Provider>\n\n);\n\n}\n\n```\n\nNow any `Button` inside of the provider will receive the current `theme` value. If you call `setTheme` to update the `theme` value that you pass to the provider, all `Button` components will re-render with the new `'light'` value.\n\n<Recipes titleText=\"Examples of updating context\" titleId=\"examples-basic\">\n\n#### Updating a value via context {/*updating-a-value-via-context*/}\n\nIn this example, the `MyApp` component holds a state variable which is then passed to the `ThemeContext` provider. Checking the \"Dark mode\" checkbox updates the state. Changing the provided value re-renders all the components using that context.\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n\nconst [theme, setTheme] = useState('light');\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"741":{"pageContent":"```js\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n\nconst [theme, setTheme] = useState('light');\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<Form />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={theme === 'dark'}\n\nonChange={(e) => {\n\nsetTheme(e.target.checked ? 'dark' : 'light')\n\n}}\n\n/>\n\nUse dark mode\n\n</label>\n\n</ThemeContext.Provider>\n\n)\n\n}\n\nfunction Form({ children }) {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n</Panel>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n<h1>{title}</h1>\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\nmargin-bottom: 10px;\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"742":{"pageContent":"return (\n\n<button className={className}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\nmargin-bottom: 10px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\nNote that `value=\"dark\"` passes the `\"dark\"` string, but `value={theme}` passes the value of the JavaScript `theme` variable with [JSX curly braces.](/learn/javascript-in-jsx-with-curly-braces) Curly braces also let you pass context values that aren't strings.\n\n<Solution />\n\n#### Updating an object via context {/*updating-an-object-via-context*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"743":{"pageContent":"<Solution />\n\n#### Updating an object via context {/*updating-an-object-via-context*/}\n\nIn this example, there is a `currentUser` state variable which holds an object. You combine `{ currentUser, setCurrentUser }` into a single object and pass it down through the context inside the `value={}`. This lets any component below, such as `LoginButton`, read both `currentUser` and `setCurrentUser`, and then call `setCurrentUser` when needed.\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext, useState } from 'react';\n\nconst CurrentUserContext = createContext(null);\n\nexport default function MyApp() {\n\nconst [currentUser, setCurrentUser] = useState(null);\n\nreturn (\n\n<CurrentUserContext.Provider\n\nvalue={{\n\ncurrentUser,\n\nsetCurrentUser\n\n}}\n\n>\n\n<Form />\n\n</CurrentUserContext.Provider>\n\n);\n\n}\n\nfunction Form({ children }) {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<LoginButton />\n\n</Panel>\n\n);\n\n}\n\nfunction LoginButton() {\n\nconst {\n\ncurrentUser,\n\nsetCurrentUser\n\n} = useContext(CurrentUserContext);\n\nif (currentUser !== null) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"744":{"pageContent":"return (\n\n<Panel title=\"Welcome\">\n\n<LoginButton />\n\n</Panel>\n\n);\n\n}\n\nfunction LoginButton() {\n\nconst {\n\ncurrentUser,\n\nsetCurrentUser\n\n} = useContext(CurrentUserContext);\n\nif (currentUser !== null) {\n\nreturn <p>You logged in as {currentUser.name}.</p>;\n\n}\n\nreturn (\n\n<Button onClick={() => {\n\nsetCurrentUser({ name: 'Advika' })\n\n}}>Log in as Advika</Button>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nreturn (\n\n<section className=\"panel\">\n\n<h1>{title}</h1>\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children, onClick }) {\n\nreturn (\n\n<button className=\"button\" onClick={onClick}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\n}\n\n.panel {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\nmargin-bottom: 10px;\n\n}\n\n.button {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Multiple contexts {/*multiple-contexts*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"745":{"pageContent":"padding: 20px;\n\nmargin-bottom: 10px;\n\n}\n\n.button {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Multiple contexts {/*multiple-contexts*/}\n\nIn this example, there are two independent contexts. `ThemeContext` provides the current theme, which is a string, while `CurrentUserContext` holds the object representing the current user.\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nconst CurrentUserContext = createContext(null);\n\nexport default function MyApp() {\n\nconst [theme, setTheme] = useState('light');\n\nconst [currentUser, setCurrentUser] = useState(null);\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<CurrentUserContext.Provider\n\nvalue={{\n\ncurrentUser,\n\nsetCurrentUser\n\n}}\n\n>\n\n<WelcomePanel />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={theme === 'dark'}\n\nonChange={(e) => {\n\nsetTheme(e.target.checked ? 'dark' : 'light')\n\n}}\n\n/>\n\nUse dark mode\n\n</label>\n\n</CurrentUserContext.Provider>\n\n</ThemeContext.Provider>\n\n)\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"746":{"pageContent":"<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={theme === 'dark'}\n\nonChange={(e) => {\n\nsetTheme(e.target.checked ? 'dark' : 'light')\n\n}}\n\n/>\n\nUse dark mode\n\n</label>\n\n</CurrentUserContext.Provider>\n\n</ThemeContext.Provider>\n\n)\n\n}\n\nfunction WelcomePanel({ children }) {\n\nconst {currentUser} = useContext(CurrentUserContext);\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n{currentUser !== null ?\n\n<Greeting /> :\n\n<LoginForm />\n\n}\n\n</Panel>\n\n);\n\n}\n\nfunction Greeting() {\n\nconst {currentUser} = useContext(CurrentUserContext);\n\nreturn (\n\n<p>You logged in as {currentUser.name}.</p>\n\n)\n\n}\n\nfunction LoginForm() {\n\nconst {setCurrentUser} = useContext(CurrentUserContext);\n\nconst [firstName, setFirstName] = useState('');\n\nconst [lastName, setLastName] = useState('');\n\nconst canLogin = firstName !== '' && lastName !== '';\n\nreturn (\n\n<>\n\n<label>\n\nFirst name{': '}\n\n<input\n\nrequired\n\nvalue={firstName}\n\nonChange={e => setFirstName(e.target.value)}\n\n/>\n\n</label>\n\n<label>\n\nLast name{': '}\n\n<input\n\nrequired\n\nvalue={lastName}\n\nonChange={e => setLastName(e.target.value)}\n\n/>\n\n</label>\n\n<Button\n\ndisabled={!canLogin}\n\nonClick={() => {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"747":{"pageContent":"/>\n\n</label>\n\n<label>\n\nLast name{': '}\n\n<input\n\nrequired\n\nvalue={lastName}\n\nonChange={e => setLastName(e.target.value)}\n\n/>\n\n</label>\n\n<Button\n\ndisabled={!canLogin}\n\nonClick={() => {\n\nsetCurrentUser({\n\nname: firstName + ' ' + lastName\n\n});\n\n}}\n\n>\n\nLog in\n\n</Button>\n\n{!canLogin && <i>Fill in both fields.</i>}\n\n</>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n<h1>{title}</h1>\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children, disabled, onClick }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button\n\nclassName={className}\n\ndisabled={disabled}\n\nonClick={onClick}\n\n>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\n}\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\nmargin-bottom: 10px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"748":{"pageContent":"padding: 20px;\n\nmargin-bottom: 10px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Extracting providers to a component {/*extracting-providers-to-a-component*/}\n\nAs your app grows, it is expected that you'll have a \"pyramid\" of contexts closer to the root of your app. There is nothing wrong with that. However, if you dislike the nesting aesthetically, you can extract the providers into a single component. In this example, `MyProviders` hides the \"plumbing\" and renders the children passed to it inside the necessary providers. Note that the `theme` and `setTheme` state is needed in `MyApp` itself, so `MyApp` still owns that piece of the state.\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext, useState } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"749":{"pageContent":"<Sandpack>\n\n```js\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nconst CurrentUserContext = createContext(null);\n\nexport default function MyApp() {\n\nconst [theme, setTheme] = useState('light');\n\nreturn (\n\n<MyProviders theme={theme} setTheme={setTheme}>\n\n<WelcomePanel />\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={theme === 'dark'}\n\nonChange={(e) => {\n\nsetTheme(e.target.checked ? 'dark' : 'light')\n\n}}\n\n/>\n\nUse dark mode\n\n</label>\n\n</MyProviders>\n\n);\n\n}\n\nfunction MyProviders({ children, theme, setTheme }) {\n\nconst [currentUser, setCurrentUser] = useState(null);\n\nreturn (\n\n<ThemeContext.Provider value={theme}>\n\n<CurrentUserContext.Provider\n\nvalue={{\n\ncurrentUser,\n\nsetCurrentUser\n\n}}\n\n>\n\n{children}\n\n</CurrentUserContext.Provider>\n\n</ThemeContext.Provider>\n\n);\n\n}\n\nfunction WelcomePanel({ children }) {\n\nconst {currentUser} = useContext(CurrentUserContext);\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n{currentUser !== null ?\n\n<Greeting /> :\n\n<LoginForm />\n\n}\n\n</Panel>\n\n);\n\n}\n\nfunction Greeting() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"750":{"pageContent":"const {currentUser} = useContext(CurrentUserContext);\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n{currentUser !== null ?\n\n<Greeting /> :\n\n<LoginForm />\n\n}\n\n</Panel>\n\n);\n\n}\n\nfunction Greeting() {\n\nconst {currentUser} = useContext(CurrentUserContext);\n\nreturn (\n\n<p>You logged in as {currentUser.name}.</p>\n\n)\n\n}\n\nfunction LoginForm() {\n\nconst {setCurrentUser} = useContext(CurrentUserContext);\n\nconst [firstName, setFirstName] = useState('');\n\nconst [lastName, setLastName] = useState('');\n\nconst canLogin = firstName !== '' && lastName !== '';\n\nreturn (\n\n<>\n\n<label>\n\nFirst name{': '}\n\n<input\n\nrequired\n\nvalue={firstName}\n\nonChange={e => setFirstName(e.target.value)}\n\n/>\n\n</label>\n\n<label>\n\nLast name{': '}\n\n<input\n\nrequired\n\nvalue={lastName}\n\nonChange={e => setLastName(e.target.value)}\n\n/>\n\n</label>\n\n<Button\n\ndisabled={!canLogin}\n\nonClick={() => {\n\nsetCurrentUser({\n\nname: firstName + ' ' + lastName\n\n});\n\n}}\n\n>\n\nLog in\n\n</Button>\n\n{!canLogin && <i>Fill in both fields.</i>}\n\n</>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"751":{"pageContent":"});\n\n}}\n\n>\n\nLog in\n\n</Button>\n\n{!canLogin && <i>Fill in both fields.</i>}\n\n</>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n<h1>{title}</h1>\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children, disabled, onClick }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button\n\nclassName={className}\n\ndisabled={disabled}\n\nonClick={onClick}\n\n>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\nlabel {\n\ndisplay: block;\n\n}\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\nmargin-bottom: 10px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"752":{"pageContent":"border: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Scaling up with context and a reducer {/*scaling-up-with-context-and-a-reducer*/}\n\nIn larger apps, it is common to combine context with a [reducer](/reference/react/useReducer) to extract the logic related to some state out of components. In this example, all the \"wiring\" is hidden in the `TasksContext.js`, which contains a reducer and two separate contexts.\n\nRead a [full walkthrough](/learn/scaling-up-with-reducer-and-context) of this example.\n\n<Sandpack>\n\n```js App.js\n\nimport AddTask from './AddTask.js';\n\nimport TaskList from './TaskList.js';\n\nimport { TasksProvider } from './TasksContext.js';\n\nexport default function TaskApp() {\n\nreturn (\n\n<TasksProvider>\n\n<h1>Day off in Kyoto</h1>\n\n<AddTask />\n\n<TaskList />\n\n</TasksProvider>\n\n);\n\n}\n\n```\n\n```js TasksContext.js\n\nimport { createContext, useContext, useReducer } from 'react';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"753":{"pageContent":"return (\n\n<TasksProvider>\n\n<h1>Day off in Kyoto</h1>\n\n<AddTask />\n\n<TaskList />\n\n</TasksProvider>\n\n);\n\n}\n\n```\n\n```js TasksContext.js\n\nimport { createContext, useContext, useReducer } from 'react';\n\nconst TasksContext = createContext(null);\n\nconst TasksDispatchContext = createContext(null);\n\nexport function TasksProvider({ children }) {\n\nconst [tasks, dispatch] = useReducer(\n\ntasksReducer,\n\ninitialTasks\n\n);\n\nreturn (\n\n<TasksContext.Provider value={tasks}>\n\n<TasksDispatchContext.Provider value={dispatch}>\n\n{children}\n\n</TasksDispatchContext.Provider>\n\n</TasksContext.Provider>\n\n);\n\n}\n\nexport function useTasks() {\n\nreturn useContext(TasksContext);\n\n}\n\nexport function useTasksDispatch() {\n\nreturn useContext(TasksDispatchContext);\n\n}\n\nfunction tasksReducer(tasks, action) {\n\nswitch (action.type) {\n\ncase 'added': {\n\nreturn [...tasks, {\n\nid: action.id,\n\ntext: action.text,\n\ndone: false\n\n}];\n\n}\n\ncase 'changed': {\n\nreturn tasks.map(t => {\n\nif (t.id === action.task.id) {\n\nreturn action.task;\n\n} else {\n\nreturn t;\n\n}\n\n});\n\n}\n\ncase 'deleted': {\n\nreturn tasks.filter(t => t.id !== action.id);\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"754":{"pageContent":"done: false\n\n}];\n\n}\n\ncase 'changed': {\n\nreturn tasks.map(t => {\n\nif (t.id === action.task.id) {\n\nreturn action.task;\n\n} else {\n\nreturn t;\n\n}\n\n});\n\n}\n\ncase 'deleted': {\n\nreturn tasks.filter(t => t.id !== action.id);\n\n}\n\ndefault: {\n\nthrow Error('Unknown action: ' + action.type);\n\n}\n\n}\n\n}\n\nconst initialTasks = [\n\n{ id: 0, text: 'Philosopherâ€™s Path', done: true },\n\n{ id: 1, text: 'Visit the temple', done: false },\n\n{ id: 2, text: 'Drink matcha', done: false }\n\n];\n\n```\n\n```js AddTask.js\n\nimport { useState, useContext } from 'react';\n\nimport { useTasksDispatch } from './TasksContext.js';\n\nexport default function AddTask() {\n\nconst [text, setText] = useState('');\n\nconst dispatch = useTasksDispatch();\n\nreturn (\n\n<>\n\n<input\n\nplaceholder=\"Add task\"\n\nvalue={text}\n\nonChange={e => setText(e.target.value)}\n\n/>\n\n<button onClick={() => {\n\nsetText('');\n\ndispatch({\n\ntype: 'added',\n\nid: nextId++,\n\ntext: text,\n\n});\n\n}}>Add</button>\n\n</>\n\n);\n\n}\n\nlet nextId = 3;\n\n```\n\n```js TaskList.js\n\nimport { useState, useContext } from 'react';\n\nimport { useTasks, useTasksDispatch } from './TasksContext.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"755":{"pageContent":"id: nextId++,\n\ntext: text,\n\n});\n\n}}>Add</button>\n\n</>\n\n);\n\n}\n\nlet nextId = 3;\n\n```\n\n```js TaskList.js\n\nimport { useState, useContext } from 'react';\n\nimport { useTasks, useTasksDispatch } from './TasksContext.js';\n\nexport default function TaskList() {\n\nconst tasks = useTasks();\n\nreturn (\n\n<ul>\n\n{tasks.map(task => (\n\n<li key={task.id}>\n\n<Task task={task} />\n\n</li>\n\n))}\n\n</ul>\n\n);\n\n}\n\nfunction Task({ task }) {\n\nconst [isEditing, setIsEditing] = useState(false);\n\nconst dispatch = useTasksDispatch();\n\nlet taskContent;\n\nif (isEditing) {\n\ntaskContent = (\n\n<>\n\n<input\n\nvalue={task.text}\n\nonChange={e => {\n\ndispatch({\n\ntype: 'changed',\n\ntask: {\n\n...task,\n\ntext: e.target.value\n\n}\n\n});\n\n}} />\n\n<button onClick={() => setIsEditing(false)}>\n\nSave\n\n</button>\n\n</>\n\n);\n\n} else {\n\ntaskContent = (\n\n<>\n\n{task.text}\n\n<button onClick={() => setIsEditing(true)}>\n\nEdit\n\n</button>\n\n</>\n\n);\n\n}\n\nreturn (\n\n<label>\n\n<input\n\ntype=\"checkbox\"\n\nchecked={task.done}\n\nonChange={e => {\n\ndispatch({\n\ntype: 'changed',\n\ntask: {\n\n...task,\n\ndone: e.target.checked\n\n}\n\n});\n\n}}\n\n/>\n\n{taskContent}\n\n<button onClick={() => {\n\ndispatch({\n\ntype: 'deleted',\n\nid: task.id\n\n});\n\n}}>\n\nDelete","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"756":{"pageContent":"checked={task.done}\n\nonChange={e => {\n\ndispatch({\n\ntype: 'changed',\n\ntask: {\n\n...task,\n\ndone: e.target.checked\n\n}\n\n});\n\n}}\n\n/>\n\n{taskContent}\n\n<button onClick={() => {\n\ndispatch({\n\ntype: 'deleted',\n\nid: task.id\n\n});\n\n}}>\n\nDelete\n\n</button>\n\n</label>\n\n);\n\n}\n\n```\n\n```css\n\nbutton { margin: 5px; }\n\nli { list-style-type: none; }\n\nul, li { margin: 0; padding: 0; }\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Specifying a fallback default value {/*specifying-a-fallback-default-value*/}\n\nIf React can't find any providers of that particular <CodeStep step={1}>context</CodeStep> in the parent tree, the context value returned by `useContext()` will be equal to the <CodeStep step={3}>default value</CodeStep> that you specified when you [created that context](/reference/react/createContext):\n\n```js [[1, 1, \"ThemeContext\"], [3, 1, \"null\"]]\n\nconst ThemeContext = createContext(null);\n\n```\n\nThe default value **never changes**. If you want to update context, use it with state as [described above.](#updating-data-passed-via-context)","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"757":{"pageContent":"const ThemeContext = createContext(null);\n\n```\n\nThe default value **never changes**. If you want to update context, use it with state as [described above.](#updating-data-passed-via-context)\n\nOften, instead of `null`, there is some more meaningful value you can use as a default, for example:\n\n```js [[1, 1, \"ThemeContext\"], [3, 1, \"light\"]]\n\nconst ThemeContext = createContext('light');\n\n```\n\nThis way, if you accidentally render some component without a corresponding provider, it won't break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.\n\nIn the example below, the \"Toggle theme\" button is always light because it's **outside any theme context provider** and the default context theme value is `'light'`. Try editing the default theme to be `'dark'`.\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext('light');\n\nexport default function MyApp() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"758":{"pageContent":"<Sandpack>\n\n```js\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext('light');\n\nexport default function MyApp() {\n\nconst [theme, setTheme] = useState('light');\n\nreturn (\n\n<>\n\n<ThemeContext.Provider value={theme}>\n\n<Form />\n\n</ThemeContext.Provider>\n\n<Button onClick={() => {\n\nsetTheme(theme === 'dark' ? 'light' : 'dark');\n\n}}>\n\nToggle theme\n\n</Button>\n\n</>\n\n)\n\n}\n\nfunction Form({ children }) {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n</Panel>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n<h1>{title}</h1>\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children, onClick }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className} onClick={onClick}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\nmargin-bottom: 10px;\n\n}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"759":{"pageContent":"return (\n\n<button className={className} onClick={onClick}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\nmargin-bottom: 10px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n--\n\n### Overriding context for a part of the tree {/*overriding-context-for-a-part-of-the-tree*/}\n\nYou can override the context for a part of the tree by wrapping that part in a provider with a different value.\n\n```js {3,5}\n\n<ThemeContext.Provider value=\"dark\">\n\n...\n\n<ThemeContext.Provider value=\"light\">\n\n<Footer />\n\n</ThemeContext.Provider>\n\n...\n\n</ThemeContext.Provider>\n\n```\n\nYou can nest and override providers as many times as you need.\n\n<Recipes title=\"Examples of overriding context\">","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"760":{"pageContent":"<Footer />\n\n</ThemeContext.Provider>\n\n...\n\n</ThemeContext.Provider>\n\n```\n\nYou can nest and override providers as many times as you need.\n\n<Recipes title=\"Examples of overriding context\">\n\n#### Overriding a theme {/*overriding-a-theme*/}\n\nHere, the button *inside* the `Footer` receives a different context value (`\"light\"`) than the buttons outside (`\"dark\"`).\n\n<Sandpack>\n\n```js\n\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n\nreturn (\n\n<ThemeContext.Provider value=\"dark\">\n\n<Form />\n\n</ThemeContext.Provider>\n\n)\n\n}\n\nfunction Form() {\n\nreturn (\n\n<Panel title=\"Welcome\">\n\n<Button>Sign up</Button>\n\n<Button>Log in</Button>\n\n<ThemeContext.Provider value=\"light\">\n\n<Footer />\n\n</ThemeContext.Provider>\n\n</Panel>\n\n);\n\n}\n\nfunction Footer() {\n\nreturn (\n\n<footer>\n\n<Button>Settings</Button>\n\n</footer>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n{title && <h1>{title}</h1>}\n\n{children}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"761":{"pageContent":"</footer>\n\n);\n\n}\n\nfunction Panel({ title, children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'panel-' + theme;\n\nreturn (\n\n<section className={className}>\n\n{title && <h1>{title}</h1>}\n\n{children}\n\n</section>\n\n)\n\n}\n\nfunction Button({ children }) {\n\nconst theme = useContext(ThemeContext);\n\nconst className = 'button-' + theme;\n\nreturn (\n\n<button className={className}>\n\n{children}\n\n</button>\n\n);\n\n}\n\n```\n\n```css\n\nfooter {\n\nmargin-top: 20px;\n\nborder-top: 1px solid #aaa;\n\n}\n\n.panel-light,\n\n.panel-dark {\n\nborder: 1px solid black;\n\nborder-radius: 4px;\n\npadding: 20px;\n\n}\n\n.panel-light {\n\ncolor: #222;\n\nbackground: #fff;\n\n}\n\n.panel-dark {\n\ncolor: #fff;\n\nbackground: rgb(23, 32, 42);\n\n}\n\n.button-light,\n\n.button-dark {\n\nborder: 1px solid #777;\n\npadding: 5px;\n\nmargin-right: 10px;\n\nmargin-top: 10px;\n\n}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Automatically nested headings {/*automatically-nested-headings*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"762":{"pageContent":"}\n\n.button-dark {\n\nbackground: #222;\n\ncolor: #fff;\n\n}\n\n.button-light {\n\nbackground: #fff;\n\ncolor: #222;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n#### Automatically nested headings {/*automatically-nested-headings*/}\n\nYou can \"accumulate\" information when you nest context providers. In this example, the `Section` component keeps track of the `LevelContext` which specifies the depth of the section nesting. It reads the `LevelContext` from the parent section, and provides the `LevelContext` number increased by one to its children. As a result, the `Heading` component can automatically decide which of the `<h1>`, `<h2>`, `<h3>`, ..., tags to use based on how many `Section` components it is nested inside of.\n\nRead a [detailed walkthrough](/learn/passing-data-deeply-with-context) of this example.\n\n<Sandpack>\n\n```js\n\nimport Heading from './Heading.js';\n\nimport Section from './Section.js';\n\nexport default function Page() {\n\nreturn (\n\n<Section>\n\n<Heading>Title</Heading>\n\n<Section>\n\n<Heading>Heading</Heading>\n\n<Heading>Heading</Heading>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"763":{"pageContent":"import Section from './Section.js';\n\nexport default function Page() {\n\nreturn (\n\n<Section>\n\n<Heading>Title</Heading>\n\n<Section>\n\n<Heading>Heading</Heading>\n\n<Heading>Heading</Heading>\n\n<Heading>Heading</Heading>\n\n<Section>\n\n<Heading>Sub-heading</Heading>\n\n<Heading>Sub-heading</Heading>\n\n<Heading>Sub-heading</Heading>\n\n<Section>\n\n<Heading>Sub-sub-heading</Heading>\n\n<Heading>Sub-sub-heading</Heading>\n\n<Heading>Sub-sub-heading</Heading>\n\n</Section>\n\n</Section>\n\n</Section>\n\n</Section>\n\n);\n\n}\n\n```\n\n```js Section.js\n\nimport { useContext } from 'react';\n\nimport { LevelContext } from './LevelContext.js';\n\nexport default function Section({ children }) {\n\nconst level = useContext(LevelContext);\n\nreturn (\n\n<section className=\"section\">\n\n<LevelContext.Provider value={level + 1}>\n\n{children}\n\n</LevelContext.Provider>\n\n</section>\n\n);\n\n}\n\n```\n\n```js Heading.js\n\nimport { useContext } from 'react';\n\nimport { LevelContext } from './LevelContext.js';\n\nexport default function Heading({ children }) {\n\nconst level = useContext(LevelContext);\n\nswitch (level) {\n\ncase 0:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"764":{"pageContent":"import { useContext } from 'react';\n\nimport { LevelContext } from './LevelContext.js';\n\nexport default function Heading({ children }) {\n\nconst level = useContext(LevelContext);\n\nswitch (level) {\n\ncase 0:\n\nthrow Error('Heading must be inside a Section!');\n\ncase 1:\n\nreturn <h1>{children}</h1>;\n\ncase 2:\n\nreturn <h2>{children}</h2>;\n\ncase 3:\n\nreturn <h3>{children}</h3>;\n\ncase 4:\n\nreturn <h4>{children}</h4>;\n\ncase 5:\n\nreturn <h5>{children}</h5>;\n\ncase 6:\n\nreturn <h6>{children}</h6>;\n\ndefault:\n\nthrow Error('Unknown level: ' + level);\n\n}\n\n}\n\n```\n\n```js LevelContext.js\n\nimport { createContext } from 'react';\n\nexport const LevelContext = createContext(0);\n\n```\n\n```css\n\n.section {\n\npadding: 10px;\n\nmargin: 5px;\n\nborder-radius: 5px;\n\nborder: 1px solid #aaa;\n\n}\n\n```\n\n</Sandpack>\n\n<Solution />\n\n</Recipes>\n\n--\n\n### Optimizing re-renders when passing objects and functions {/*optimizing-re-renders-when-passing-objects-and-functions*/}\n\nYou can pass any values via context, including objects and functions.\n\n```js [[2, 10, \"{ currentUser, login }\"]]\n\nfunction MyApp() {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"765":{"pageContent":"You can pass any values via context, including objects and functions.\n\n```js [[2, 10, \"{ currentUser, login }\"]]\n\nfunction MyApp() {\n\nconst [currentUser, setCurrentUser] = useState(null);\n\nfunction login(response) {\n\nstoreCredentials(response.credentials);\n\nsetCurrentUser(response.user);\n\n}\n\nreturn (\n\n<AuthContext.Provider value={{ currentUser, login }}>\n\n<Page />\n\n</AuthContext.Provider>\n\n);\n\n}\n\n```\n\nHere, the <CodeStep step={2}>context value</CodeStep> is a JavaScript object with two properties, one of which is a function. Whenever `MyApp` re-renders (for example, on a route update), this will be a *different* object pointing at a *different* function, so React will also have to re-render all components deep in the tree that call `useContext(AuthContext)`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"766":{"pageContent":"In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like `currentUser`, has not changed. To help React take advantage of that fact, you may wrap the `login` function with [`useCallback`](/reference/react/useCallback) and wrap the object creation into [`useMemo`](/reference/react/useMemo). This is a performance optimization:\n\n```js {6,9,11,14,17}\n\nimport { useCallback, useMemo } from 'react';\n\nfunction MyApp() {\n\nconst [currentUser, setCurrentUser] = useState(null);\n\nconst login = useCallback((response) => {\n\nstoreCredentials(response.credentials);\n\nsetCurrentUser(response.user);\n\n}, []);\n\nconst contextValue = useMemo(() => ({\n\ncurrentUser,\n\nlogin\n\n}), [currentUser, login]);\n\nreturn (\n\n<AuthContext.Provider value={contextValue}>\n\n<Page />\n\n</AuthContext.Provider>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"767":{"pageContent":"}, []);\n\nconst contextValue = useMemo(() => ({\n\ncurrentUser,\n\nlogin\n\n}), [currentUser, login]);\n\nreturn (\n\n<AuthContext.Provider value={contextValue}>\n\n<Page />\n\n</AuthContext.Provider>\n\n);\n\n}\n\n```\n\nAs a result of this change, even if `MyApp` needs to re-render, the components calling `useContext(AuthProvider)` won't need to re-render unless `currentUser` has changed. Read more about [`useMemo`](/reference/react/useMemo#skipping-re-rendering-of-components) and [`useCallback`.](/reference/react/useCallback#skipping-re-rendering-of-components)\n\n--\n\n## Troubleshooting {/*troubleshooting*/}\n\n### My component doesn't see the value from my provider {/*my-component-doesnt-see-the-value-from-my-provider*/}\n\nThere are a few common ways that this can happen:\n\n1. You're rendering `<SomeContext.Provider>` in the same component (or below) as where you're calling `useContext()`. Move `<SomeContext.Provider>` *above and outside* the component calling `useContext()`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"768":{"pageContent":"2. You may have forgotten to wrap your component with `<SomeContext.Provider>`, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using [React DevTools.](/learn/react-developer-tools)\n\n3. You might be running into some build issue with your tooling that causes `SomeContext` as seen from the providing component and `SomeContext` as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like `window.SomeContext1` and `window.SomeContext2` and then checking whether `window.SomeContext1 === window.SomeContext2` in the console. If they're not the same, you need to fix that issue on the build tool level.\n\n### I am always getting `undefined` from my context although the default value is different {/*i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"769":{"pageContent":"### I am always getting `undefined` from my context although the default value is different {/*i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different*/}\n\nYou might have a provider without a `value` in the tree:\n\n```js {1,2}\n\n// ðŸš© Doesn't work: no value prop\n\n<ThemeContext.Provider>\n\n<Button />\n\n</ThemeContext.Provider>\n\n```\n\nIf you forget to specify `value`, it's like passing `value={undefined}`.\n\nYou may have also mistakingly used a different prop name by mistake:\n\n```js {1,2}\n\n// ðŸš© Doesn't work: prop should be called \"value\"\n\n<ThemeContext.Provider theme={theme}>\n\n<Button />\n\n</ThemeContext.Provider>\n\n```\n\nIn both of these cases you should see a warning from React in the console. To fix them, call the prop `value`:\n\n```js {1,2}\n\n// âœ… Passing the value prop\n\n<ThemeContext.Provider value={theme}>\n\n<Button />\n\n</ThemeContext.Provider>\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"770":{"pageContent":"```js {1,2}\n\n// âœ… Passing the value prop\n\n<ThemeContext.Provider value={theme}>\n\n<Button />\n\n</ThemeContext.Provider>\n\n```\n\nNote that the [default value from your `createContext(defaultValue)` call](#specifying-a-fallback-default-value) is only used **if there is no matching provider above at all.** If there is a `<SomeContext.Provider value={undefined}>` component somewhere in the parent tree, the component calling `useContext(SomeContext)` *will* receive `undefined` as the context value.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/useContext.md"}},"771":{"pageContent":"--\n\ntitle: cloneElement\n\n--\n\n<Pitfall>\n\nUsing `cloneElement` is uncommon and can lead to fragile code. [See common alternatives.](#alternatives)\n\n</Pitfall>\n\n<Intro>\n\n`cloneElement` lets you create a new React element using another element as a starting point.\n\n```js\n\nconst clonedElement = cloneElement(element, props, ...children)\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `cloneElement(element, props, ...children)` {/*cloneelement*/}\n\nCall `cloneElement` to create a React element based on the `element`, but with different `props` and `children`:\n\n```js\n\nimport { cloneElement } from 'react';\n\n// ...\n\nconst clonedElement = cloneElement(\n\n<Row title=\"Cabbage\">\n\nHello\n\n</Row>,\n\n{ isHighlighted: true },\n\n'Goodbye'\n\n);\n\nconsole.log(clonedElement); // <Row title=\"Cabbage\">Goodbye</Row>\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"772":{"pageContent":"Hello\n\n</Row>,\n\n{ isHighlighted: true },\n\n'Goodbye'\n\n);\n\nconsole.log(clonedElement); // <Row title=\"Cabbage\">Goodbye</Row>\n\n```\n\n[See more examples below.](#usage)\n\n#### Parameters {/*parameters*/}\n\n`element`: The `element` argument must be a valid React element. For example, it could be a JSX node like `<Something />`, the result of calling [`createElement`](/reference/react/createElement), or the result of another `cloneElement` call.\n\n`props`: The `props` argument must either be an object or `null`. If you pass `null`, the cloned element will retain all of the original `element.props`. Otherwise, for every prop in the `props` object, the returned element will \"prefer\" the value from `props` over the value from `element.props`. The rest of the props will be filled from the original `element.props`. If you pass `props.key` or `props.ref`, they will replace the original ones.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"773":{"pageContent":"**optional** `...children`: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, [portals](/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes. If you don't pass any `...children` arguments, the original `element.props.children` will be preserved.\n\n#### Returns {/*returns*/}\n\n`cloneElement` returns a React element object with a few properties:\n\n`type`: Same as `element.type`.\n\n`props`: The result of shallowly merging `element.props` with the overriding `props` you have passed.\n\n`ref`: The original `element.ref`, unless it was overridden by `props.ref`.\n\n`key`: The original `element.key`, unless it was overridden by `props.key`.\n\nUsually, you'll return the element from your component or make it a child of another element. Although you may read the element's properties, it's best to treat every element as opaque after it's created, and only render it.\n\n#### Caveats {/*caveats*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"774":{"pageContent":"#### Caveats {/*caveats*/}\n\nCloning an element **does not modify the original element.**\n\nYou should only **pass children as multiple arguments to `cloneElement` if they are all statically known,** like `cloneElement(element, null, child1, child2, child3)`. If your children are dynamic, pass the entire array as the third argument: `cloneElement(element, null, listItems)`. This ensures that React will [warn you about missing `key`s](/learn/rendering-lists#keeping-list-items-in-order-with-key) for any dynamic lists. For static lists this is not necessary because they never reorder.\n\n`cloneElement` makes it harder to trace the data flow, so **try the [alternatives](/#alternatives) instead.**\n\n--\n\n## Usage {/*usage*/}\n\n### Overriding props of an element {/*overriding-props-of-an-element*/}\n\nTo override the props of some <CodeStep step={1}>React element</CodeStep>, pass it to `cloneElement` with the <CodeStep step={2}>props you want to override</CodeStep>:","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"775":{"pageContent":"To override the props of some <CodeStep step={1}>React element</CodeStep>, pass it to `cloneElement` with the <CodeStep step={2}>props you want to override</CodeStep>:\n\n```js [[1, 5, \"<Row title=\\\\\"Cabbage\\\\\" />\"], [2, 6, \"{ isHighlighted: true }\"], [3, 4, \"clonedElement\"]]\n\nimport { cloneElement } from 'react';\n\n// ...\n\nconst clonedElement = cloneElement(\n\n<Row title=\"Cabbage\" />,\n\n{ isHighlighted: true }\n\n);\n\n```\n\nHere, the resulting <CodeStep step={3}>cloned element</CodeStep> will be `<Row title=\"Cabbage\" isHighlighted={true} />`.\n\n*Let's walk through an example to see when it's useful.**\n\nImagine a `List` component that renders its [`children`](/learn/passing-props-to-a-component#passing-jsx-as-children) as a list of selectable rows with a \"Next\" button that changes which row is selected. The `List` component needs to render the selected `Row` differently, so it clones every `<Row>` child that it has received, and adds an extra `isHighlighted: true` or `isHighlighted: false` prop:\n\n```js {6-8}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"776":{"pageContent":"```js {6-8}\n\nexport default function List({ children }) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nreturn (\n\n<div className=\"List\">\n\n{Children.map(children, (child, index) =>\n\ncloneElement(child, {\n\nisHighlighted: index === selectedIndex\n\n})\n\n)}\n\n```\n\nLet's say the original JSX received by `List` looks like this:\n\n```js {2-4}\n\n<List>\n\n<Row title=\"Cabbage\" />\n\n<Row title=\"Garlic\" />\n\n<Row title=\"Apple\" />\n\n</List>\n\n```\n\nBy cloning its children, the `List` can pass extra information to every `Row` inside. The result looks like this:\n\n```js {4,8,12}\n\n<List>\n\n<Row\n\ntitle=\"Cabbage\"\n\nisHighlighted={true}\n\n/>\n\n<Row\n\ntitle=\"Garlic\"\n\nisHighlighted={false}\n\n/>\n\n<Row\n\ntitle=\"Apple\"\n\nisHighlighted={false}\n\n/>\n\n</List>\n\n```\n\nNotice how pressing \"Next\" updates the state of the `List`, and highlights a different row:\n\n<Sandpack>\n\n```js\n\nimport List from './List.js';\n\nimport Row from './Row.js';\n\nimport { products } from './data.js';\n\nexport default function App() {\n\nreturn (\n\n<List>\n\n{products.map(product =>\n\n<Row\n\nkey={product.id}\n\ntitle={product.title}\n\n/>\n\n)}\n\n</List>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"777":{"pageContent":"import Row from './Row.js';\n\nimport { products } from './data.js';\n\nexport default function App() {\n\nreturn (\n\n<List>\n\n{products.map(product =>\n\n<Row\n\nkey={product.id}\n\ntitle={product.title}\n\n/>\n\n)}\n\n</List>\n\n);\n\n}\n\n```\n\n```js List.js active\n\nimport { Children, cloneElement, useState } from 'react';\n\nexport default function List({ children }) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nreturn (\n\n<div className=\"List\">\n\n{Children.map(children, (child, index) =>\n\ncloneElement(child, {\n\nisHighlighted: index === selectedIndex\n\n})\n\n)}\n\n<hr />\n\n<button onClick={() => {\n\nsetSelectedIndex(i =>\n\n(i + 1) % Children.count(children)\n\n);\n\n}}>\n\nNext\n\n</button>\n\n</div>\n\n);\n\n}\n\n```\n\n```js Row.js\n\nexport default function Row({ title, isHighlighted }) {\n\nreturn (\n\n<div className={[\n\n'Row',\n\nisHighlighted ? 'RowHighlighted' : ''\n\n].join(' ')}>\n\n{title}\n\n</div>\n\n);\n\n}\n\n```\n\n```js data.js\n\nexport const products = [\n\n{ title: 'Cabbage', id: 1 },\n\n{ title: 'Garlic', id: 2 },\n\n{ title: 'Apple', id: 3 },\n\n];\n\n```\n\n```css\n\n.List {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"778":{"pageContent":"{ title: 'Cabbage', id: 1 },\n\n{ title: 'Garlic', id: 2 },\n\n{ title: 'Apple', id: 3 },\n\n];\n\n```\n\n```css\n\n.List {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n.RowHighlighted {\n\nbackground: #ffa;\n\n}\n\nbutton {\n\nheight: 40px;\n\nfont-size: 20px;\n\n}\n\n```\n\n</Sandpack>\n\nTo summarize, the `List` cloned the `<Row />` elements it received and added an extra prop to them.\n\n<Pitfall>\n\nCloning children makes it hard to tell how the data flows through your app. Try one of the [alternatives.](#alternatives)\n\n</Pitfall>\n\n--\n\n## Alternatives {/*alternatives*/}\n\n### Passing data with a render prop {/*passing-data-with-a-render-prop*/}\n\nInstead of using `cloneElement`, consider accepting a *render prop* like `renderItem`. Here, `List` receives `renderItem` as a prop. `List` calls `renderItem` for every item and passes `isHighlighted` as an argument:\n\n```js {1,7}\n\nexport default function List({ items, renderItem }) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"779":{"pageContent":"```js {1,7}\n\nexport default function List({ items, renderItem }) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nreturn (\n\n<div className=\"List\">\n\n{items.map((item, index) => {\n\nconst isHighlighted = index === selectedIndex;\n\nreturn renderItem(item, isHighlighted);\n\n})}\n\n```\n\nThe `renderItem` prop is called a \"render prop\" because it's a prop that specifies how to render something. For example, you can pass a `renderItem` implementation that renders a `<Row>` with the given `isHighlighted` value:\n\n```js {3,7}\n\n<List\n\nitems={products}\n\nrenderItem={(product, isHighlighted) =>\n\n<Row\n\nkey={product.id}\n\ntitle={product.title}\n\nisHighlighted={isHighlighted}\n\n/>\n\n}\n\n/>\n\n```\n\nThe end result is the same as with `cloneElement`:\n\n```js {4,8,12}\n\n<List>\n\n<Row\n\ntitle=\"Cabbage\"\n\nisHighlighted={true}\n\n/>\n\n<Row\n\ntitle=\"Garlic\"\n\nisHighlighted={false}\n\n/>\n\n<Row\n\ntitle=\"Apple\"\n\nisHighlighted={false}\n\n/>\n\n</List>\n\n```\n\nHowever, you can clearly trace where the `isHighlighted` value is coming from.\n\n<Sandpack>\n\n```js\n\nimport List from './List.js';\n\nimport Row from './Row.js';","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"780":{"pageContent":"<Row\n\ntitle=\"Apple\"\n\nisHighlighted={false}\n\n/>\n\n</List>\n\n```\n\nHowever, you can clearly trace where the `isHighlighted` value is coming from.\n\n<Sandpack>\n\n```js\n\nimport List from './List.js';\n\nimport Row from './Row.js';\n\nimport { products } from './data.js';\n\nexport default function App() {\n\nreturn (\n\n<List\n\nitems={products}\n\nrenderItem={(product, isHighlighted) =>\n\n<Row\n\nkey={product.id}\n\ntitle={product.title}\n\nisHighlighted={isHighlighted}\n\n/>\n\n}\n\n/>\n\n);\n\n}\n\n```\n\n```js List.js active\n\nimport { useState } from 'react';\n\nexport default function List({ items, renderItem }) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nreturn (\n\n<div className=\"List\">\n\n{items.map((item, index) => {\n\nconst isHighlighted = index === selectedIndex;\n\nreturn renderItem(item, isHighlighted);\n\n})}\n\n<hr />\n\n<button onClick={() => {\n\nsetSelectedIndex(i =>\n\n(i + 1) % items.length\n\n);\n\n}}>\n\nNext\n\n</button>\n\n</div>\n\n);\n\n}\n\n```\n\n```js Row.js\n\nexport default function Row({ title, isHighlighted }) {\n\nreturn (\n\n<div className={[\n\n'Row',\n\nisHighlighted ? 'RowHighlighted' : ''\n\n].join(' ')}>\n\n{title}\n\n</div>\n\n);\n\n}\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"781":{"pageContent":");\n\n}}>\n\nNext\n\n</button>\n\n</div>\n\n);\n\n}\n\n```\n\n```js Row.js\n\nexport default function Row({ title, isHighlighted }) {\n\nreturn (\n\n<div className={[\n\n'Row',\n\nisHighlighted ? 'RowHighlighted' : ''\n\n].join(' ')}>\n\n{title}\n\n</div>\n\n);\n\n}\n\n```\n\n```js data.js\n\nexport const products = [\n\n{ title: 'Cabbage', id: 1 },\n\n{ title: 'Garlic', id: 2 },\n\n{ title: 'Apple', id: 3 },\n\n];\n\n```\n\n```css\n\n.List {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n.RowHighlighted {\n\nbackground: #ffa;\n\n}\n\nbutton {\n\nheight: 40px;\n\nfont-size: 20px;\n\n}\n\n```\n\n</Sandpack>\n\nThis pattern is preferred to `cloneElement` because it is more explicit.\n\n--\n\n### Passing data through context {/*passing-data-through-context*/}\n\nAnother alternative to `cloneElement` is to [pass data through context.](/learn/passing-data-deeply-with-context)\n\nFor example, you can call [`createContext`](/reference/react/createContext) to define a `HighlightContext`:\n\n```js\n\nexport const HighlightContext = createContext(false);\n\n```","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"782":{"pageContent":"For example, you can call [`createContext`](/reference/react/createContext) to define a `HighlightContext`:\n\n```js\n\nexport const HighlightContext = createContext(false);\n\n```\n\nYour `List` component can wrap every item it renders into a `HighlightContext` provider:\n\n```js {8,10}\n\nexport default function List({ items, renderItem }) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nreturn (\n\n<div className=\"List\">\n\n{items.map((item, index) => {\n\nconst isHighlighted = index === selectedIndex;\n\nreturn (\n\n<HighlightContext.Provider key={item.id} value={isHighlighted}>\n\n{renderItem(item)}\n\n</HighlightContext.Provider>\n\n);\n\n})}\n\n```\n\nWith this approach, `Row` does not need to receive an `isHighlighted` prop at all. Instead, it reads the context:\n\n```js Row.js {2}\n\nexport default function Row({ title }) {\n\nconst isHighlighted = useContext(HighlightContext);\n\n// ...\n\n````\n\nThis allows the calling component to not know or worry about passing `isHighlighted` to `<Row>`:\n\n```js {4}\n\n<List\n\nitems={products}\n\nrenderItem={product =>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"783":{"pageContent":"// ...\n\n````\n\nThis allows the calling component to not know or worry about passing `isHighlighted` to `<Row>`:\n\n```js {4}\n\n<List\n\nitems={products}\n\nrenderItem={product =>\n\n<Row title={product.title} />\n\n}\n\n/>\n\n```\n\nInstead, `List` and `Row` coordinate the highlighting logic through context.\n\n<Sandpack>\n\n```js\n\nimport List from './List.js';\n\nimport Row from './Row.js';\n\nimport { products } from './data.js';\n\nexport default function App() {\n\nreturn (\n\n<List\n\nitems={products}\n\nrenderItem={(product) =>\n\n<Row title={product.title} />\n\n}\n\n/>\n\n);\n\n}\n\n```\n\n```js List.js active\n\nimport { useState } from 'react';\n\nimport { HighlightContext } from './HighlightContext.js';\n\nexport default function List({ items, renderItem }) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nreturn (\n\n<div className=\"List\">\n\n{items.map((item, index) => {\n\nconst isHighlighted = index === selectedIndex;\n\nreturn (\n\n<HighlightContext.Provider\n\nkey={item.id}\n\nvalue={isHighlighted}\n\n>\n\n{renderItem(item)}\n\n</HighlightContext.Provider>\n\n);\n\n})}\n\n<hr />\n\n<button onClick={() => {\n\nsetSelectedIndex(i =>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"784":{"pageContent":"return (\n\n<HighlightContext.Provider\n\nkey={item.id}\n\nvalue={isHighlighted}\n\n>\n\n{renderItem(item)}\n\n</HighlightContext.Provider>\n\n);\n\n})}\n\n<hr />\n\n<button onClick={() => {\n\nsetSelectedIndex(i =>\n\n(i + 1) % items.length\n\n);\n\n}}>\n\nNext\n\n</button>\n\n</div>\n\n);\n\n}\n\n```\n\n```js Row.js\n\nimport { useContext } from 'react';\n\nimport { HighlightContext } from './HighlightContext.js';\n\nexport default function Row({ title }) {\n\nconst isHighlighted = useContext(HighlightContext);\n\nreturn (\n\n<div className={[\n\n'Row',\n\nisHighlighted ? 'RowHighlighted' : ''\n\n].join(' ')}>\n\n{title}\n\n</div>\n\n);\n\n}\n\n```\n\n```js HighlightContext.js\n\nimport { createContext } from 'react';\n\nexport const HighlightContext = createContext(false);\n\n```\n\n```js data.js\n\nexport const products = [\n\n{ title: 'Cabbage', id: 1 },\n\n{ title: 'Garlic', id: 2 },\n\n{ title: 'Apple', id: 3 },\n\n];\n\n```\n\n```css\n\n.List {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n.RowHighlighted {\n\nbackground: #ffa;\n\n}\n\nbutton {\n\nheight: 40px;\n\nfont-size: 20px;\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"785":{"pageContent":"border: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n.RowHighlighted {\n\nbackground: #ffa;\n\n}\n\nbutton {\n\nheight: 40px;\n\nfont-size: 20px;\n\n}\n\n```\n\n</Sandpack>\n\n[Learn more about passing data through context.](/reference/react/useContext#passing-data-deeply-into-the-tree)\n\n--\n\n### Extracting logic into a custom Hook {/*extracting-logic-into-a-custom-hook*/}\n\nAnother approach you can try is to extract the \"non-visual\" logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write a `useList` custom Hook like this:\n\n```js\n\nimport { useState } from 'react';\n\nexport default function useList(items) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nfunction onNext() {\n\nsetSelectedIndex(i =>\n\n(i + 1) % items.length\n\n);\n\n}\n\nconst selected = items[selectedIndex];\n\nreturn [selected, onNext];\n\n}\n\n```\n\nThen you could use it like this:\n\n```js {2,9,13}\n\nexport default function App() {\n\nconst [selected, onNext] = useList(products);\n\nreturn (","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"786":{"pageContent":"}\n\nconst selected = items[selectedIndex];\n\nreturn [selected, onNext];\n\n}\n\n```\n\nThen you could use it like this:\n\n```js {2,9,13}\n\nexport default function App() {\n\nconst [selected, onNext] = useList(products);\n\nreturn (\n\n<div className=\"List\">\n\n{products.map(product =>\n\n<Row\n\nkey={product.id}\n\ntitle={product.title}\n\nisHighlighted={selected === product}\n\n/>\n\n)}\n\n<hr />\n\n<button onClick={onNext}>\n\nNext\n\n</button>\n\n</div>\n\n);\n\n}\n\n```\n\nThe data flow is explicit, but the state is inside the `useList` custom Hook that you can use from any component:\n\n<Sandpack>\n\n```js\n\nimport Row from './Row.js';\n\nimport useList from './useList.js';\n\nimport { products } from './data.js';\n\nexport default function App() {\n\nconst [selected, onNext] = useList(products);\n\nreturn (\n\n<div className=\"List\">\n\n{products.map(product =>\n\n<Row\n\nkey={product.id}\n\ntitle={product.title}\n\nisHighlighted={selected === product}\n\n/>\n\n)}\n\n<hr />\n\n<button onClick={onNext}>\n\nNext\n\n</button>\n\n</div>\n\n);\n\n}\n\n```\n\n```js useList.js\n\nimport { useState } from 'react';\n\nexport default function useList(items) {","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"787":{"pageContent":"isHighlighted={selected === product}\n\n/>\n\n)}\n\n<hr />\n\n<button onClick={onNext}>\n\nNext\n\n</button>\n\n</div>\n\n);\n\n}\n\n```\n\n```js useList.js\n\nimport { useState } from 'react';\n\nexport default function useList(items) {\n\nconst [selectedIndex, setSelectedIndex] = useState(0);\n\nfunction onNext() {\n\nsetSelectedIndex(i =>\n\n(i + 1) % items.length\n\n);\n\n}\n\nconst selected = items[selectedIndex];\n\nreturn [selected, onNext];\n\n}\n\n```\n\n```js Row.js\n\nexport default function Row({ title, isHighlighted }) {\n\nreturn (\n\n<div className={[\n\n'Row',\n\nisHighlighted ? 'RowHighlighted' : ''\n\n].join(' ')}>\n\n{title}\n\n</div>\n\n);\n\n}\n\n```\n\n```js data.js\n\nexport const products = [\n\n{ title: 'Cabbage', id: 1 },\n\n{ title: 'Garlic', id: 2 },\n\n{ title: 'Apple', id: 3 },\n\n];\n\n```\n\n```css\n\n.List {\n\ndisplay: flex;\n\nflex-direction: column;\n\nborder: 2px solid grey;\n\npadding: 5px;\n\n}\n\n.Row {\n\nborder: 2px dashed black;\n\npadding: 5px;\n\nmargin: 5px;\n\n}\n\n.RowHighlighted {\n\nbackground: #ffa;\n\n}\n\nbutton {\n\nheight: 40px;\n\nfont-size: 20px;\n\n}\n\n```\n\n</Sandpack>\n\nThis approach is particularly useful if you want to reuse this logic between different components.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/cloneElement.md"}},"788":{"pageContent":"--\n\ntitle: <Fragment> (<>...</>)\n\n--\n\n<Intro>\n\n`<Fragment>`, often used via `<>...</>` syntax, lets you group elements without a wrapper node.\n\n```js\n\n<>\n\n<OneChild />\n\n<AnotherChild />\n\n</>\n\n```\n\n</Intro>\n\n<InlineToc />\n\n--\n\n## Reference {/*reference*/}\n\n### `<Fragment>` {/*fragment*/}\n\nWrap elements in `<Fragment>` to group them together in situations where you need a single element. Grouping elements in `Fragment` has no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag `<></>` is shorthand for `<Fragment></Fragment>` in most cases.\n\n#### Props {/*props*/}\n\n**optional** `key`: Fragments declared with the explicit `<Fragment>` syntax may have [keys.](https://beta.reactjs.org/learn/rendering-lists#keeping-list-items-in-order-with-key)\n\n#### Caveats {/*caveats*/}\n\nIf you want to pass `key` to a Fragment, you can't use the `<>...</>` syntax. You have to explicitly import `Fragment` from `'react'` and render `<Fragment key={yourKey}>...</Fragment>`.","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Fragment.md"}},"789":{"pageContent":"If you want to pass `key` to a Fragment, you can't use the `<>...</>` syntax. You have to explicitly import `Fragment` from `'react'` and render `<Fragment key={yourKey}>...</Fragment>`.\n\nReact does not [reset state](/learn/preserving-and-resetting-state) when you go from rendering `<><Child /></>` to `[<Child />]` or back, or when you go from rendering `<><Child /></>` to `<Child />` and back. This only works a single level deep: for example, going from `<><><Child /></></>` to `<Child />` resets the state. See the precise semantics [here.](https://gist.github.com/clemmy/b3ef00f9507909429d8aa0d3ee4f986b)\n\n--\n\n## Usage {/*usage*/}\n\n### Returning multiple elements {/*returning-multiple-elements*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Fragment.md"}},"790":{"pageContent":"--\n\n## Usage {/*usage*/}\n\n### Returning multiple elements {/*returning-multiple-elements*/}\n\nUse `Fragment`, or the equivalent `<>...</>` syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:\n\n```js {3,6}\n\nfunction Post() {\n\nreturn (\n\n<>\n\n<PostTitle />\n\n<PostBody />\n\n</>\n\n);\n\n}\n\n```\n\nFragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in some other container such as a DOM element. If you inspect this example with the browser tools, you'll see that all `<h1>` and `<p>` DOM nodes appear as siblings without wrappers around them:\n\n<Sandpack>\n\n```js\n\nexport default function Blog() {\n\nreturn (\n\n<>\n\n<Post title=\"An update\" body=\"It's been a while since I posted...\" />\n\n<Post title=\"My new blog\" body=\"I am starting a new blog!\" />","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Fragment.md"}},"791":{"pageContent":"<Sandpack>\n\n```js\n\nexport default function Blog() {\n\nreturn (\n\n<>\n\n<Post title=\"An update\" body=\"It's been a while since I posted...\" />\n\n<Post title=\"My new blog\" body=\"I am starting a new blog!\" />\n\n</>\n\n)\n\n}\n\nfunction Post({ title, body }) {\n\nreturn (\n\n<>\n\n<PostTitle title={title} />\n\n<PostBody body={body} />\n\n</>\n\n);\n\n}\n\nfunction PostTitle({ title }) {\n\nreturn <h1>{title}</h1>\n\n}\n\nfunction PostBody({ body }) {\n\nreturn (\n\n<article>\n\n<p>{body}</p>\n\n</article>\n\n);\n\n}\n\n```\n\n</Sandpack>\n\n<DeepDive>\n\n#### How to write a Fragment without the special syntax? {/*how-to-write-a-fragment-without-the-special-syntax*/}\n\nThe example above is equivalent to importing `Fragment` from React:\n\n```js {1,5,8}\n\nimport { Fragment } from 'react';\n\nfunction Post() {\n\nreturn (\n\n<Fragment>\n\n<PostTitle />\n\n<PostBody />\n\n</Fragment>\n\n);\n\n}\n\n```\n\nUsually you won't need this unless you need to [pass a `key` to your `Fragment`.](#rendering-a-list-of-fragments)\n\n</DeepDive>\n\n--\n\n### Assigning multiple elements to a variable {/*assigning-multiple-elements-to-a-variable*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Fragment.md"}},"792":{"pageContent":"</DeepDive>\n\n--\n\n### Assigning multiple elements to a variable {/*assigning-multiple-elements-to-a-variable*/}\n\nLike any other element, you can assign Fragment elements to variables, pass them as props, and so on:\n\n```js\n\nfunction CloseDialog() {\n\nconst buttons = (\n\n<>\n\n<OKButton />\n\n<CancelButton />\n\n</>\n\n);\n\nreturn (\n\n<AlertDialog buttons={buttons}>\n\nAre you sure you want to leave this page?\n\n</AlertDialog>\n\n);\n\n}\n\n```\n\n--\n\n### Grouping elements with text {/*grouping-elements-with-text*/}\n\nYou can use `Fragment` to group text together with components:\n\n```js\n\nfunction DateRangePicker({ start, end }) {\n\nreturn (\n\n<>\n\nFrom\n\n<DatePicker date={start} />\n\nto\n\n<DatePicker date={end} />\n\n</>\n\n);\n\n}\n\n```\n\n--\n\n### Rendering a list of Fragments {/*rendering-a-list-of-fragments*/}","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Fragment.md"}},"793":{"pageContent":"```js\n\nfunction DateRangePicker({ start, end }) {\n\nreturn (\n\n<>\n\nFrom\n\n<DatePicker date={start} />\n\nto\n\n<DatePicker date={end} />\n\n</>\n\n);\n\n}\n\n```\n\n--\n\n### Rendering a list of Fragments {/*rendering-a-list-of-fragments*/}\n\nHere's a situation where you need to write `Fragment` explicitly instead of using the `<></>` syntax. When you [render multiple elements in a loop](/learn/rendering-lists), you need to assign a `key` to each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide the `key` attribute:\n\n```js {3,6}\n\nfunction Blog() {\n\nreturn posts.map(post =>\n\n<Fragment key={post.id}>\n\n<PostTitle title={post.title} />\n\n<PostBody body={post.body} />\n\n</Fragment>\n\n);\n\n}\n\n```\n\nYou can inspect the DOM to verify that there are no wrapper elements around the Fragment children:\n\n<Sandpack>\n\n```js\n\nimport { Fragment } from 'react';\n\nconst posts = [\n\n{ id: 1, title: 'An update', body: \"It's been a while since I posted...\" },","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Fragment.md"}},"794":{"pageContent":"<Sandpack>\n\n```js\n\nimport { Fragment } from 'react';\n\nconst posts = [\n\n{ id: 1, title: 'An update', body: \"It's been a while since I posted...\" },\n\n{ id: 2, title: 'My new blog', body: 'I am starting a new blog!' }\n\n];\n\nexport default function Blog() {\n\nreturn posts.map(post =>\n\n<Fragment key={post.id}>\n\n<PostTitle title={post.title} />\n\n<PostBody body={post.body} />\n\n</Fragment>\n\n);\n\n}\n\nfunction PostTitle({ title }) {\n\nreturn <h1>{title}</h1>\n\n}\n\nfunction PostBody({ body }) {\n\nreturn (\n\n<article>\n\n<p>{body}</p>\n\n</article>\n\n);\n\n}\n\n```\n\n</Sandpack>","metadata":{"source":"reactjs.org/beta/src/content/reference/react/Fragment.md"}}}